package shell

import (
	"context"
	"fmt"
	"regexp"
	"strings"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ssm"
)

// ssmShellAPI defines the SSM operations used by ShellGenerator.
// This interface enables testing with mock implementations.
type ssmShellAPI interface {
	GetParametersByPath(ctx context.Context, params *ssm.GetParametersByPathInput, optFns ...func(*ssm.Options)) (*ssm.GetParametersByPathOutput, error)
}

// ProfileInfo holds information about a discovered Sentinel profile.
type ProfileInfo struct {
	// Name is the profile name (e.g., "production").
	Name string

	// PolicyPath is the full SSM path (e.g., "/sentinel/policies/production").
	PolicyPath string
}

// ShellFormat represents the shell format for script generation.
type ShellFormat string

const (
	// FormatBash generates bash-compatible shell functions.
	FormatBash ShellFormat = "bash"

	// FormatZsh generates zsh-compatible shell functions.
	FormatZsh ShellFormat = "zsh"
)

// ShellGenerator discovers Sentinel profiles and generates shell wrapper functions.
type ShellGenerator struct {
	ssm ssmShellAPI
}

// NewShellGenerator creates a new ShellGenerator using the provided AWS configuration.
func NewShellGenerator(cfg aws.Config) *ShellGenerator {
	return &ShellGenerator{
		ssm: ssm.NewFromConfig(cfg),
	}
}

// newShellGeneratorWithClient creates a ShellGenerator with a custom SSM client.
// This is primarily used for testing with mock clients.
func newShellGeneratorWithClient(client ssmShellAPI) *ShellGenerator {
	return &ShellGenerator{
		ssm: client,
	}
}

// GetProfiles discovers all Sentinel profiles under the given policy root.
// It queries SSM for parameters and returns a list of ProfileInfo structs.
func (g *ShellGenerator) GetProfiles(ctx context.Context, policyRoot string) ([]ProfileInfo, error) {
	var profiles []ProfileInfo
	var nextToken *string

	for {
		input := &ssm.GetParametersByPathInput{
			Path:      aws.String(policyRoot),
			Recursive: aws.Bool(false),
			NextToken: nextToken,
		}

		output, err := g.ssm.GetParametersByPath(ctx, input)
		if err != nil {
			return nil, fmt.Errorf("failed to list profiles: %w", err)
		}

		// Process parameters from this page
		for _, param := range output.Parameters {
			path := aws.ToString(param.Name)
			name := extractProfileName(policyRoot, path)

			profiles = append(profiles, ProfileInfo{
				Name:       name,
				PolicyPath: path,
			})
		}

		// Check for more pages
		if output.NextToken == nil {
			break
		}
		nextToken = output.NextToken
	}

	return profiles, nil
}

// extractProfileName extracts the profile name from a full parameter path.
// For example, "/sentinel/policies/production" -> "production".
func extractProfileName(policyRoot, paramPath string) string {
	// Remove trailing slash from policyRoot if present
	policyRoot = strings.TrimSuffix(policyRoot, "/")

	// Remove the policy root prefix and leading slash
	name := strings.TrimPrefix(paramPath, policyRoot)
	name = strings.TrimPrefix(name, "/")

	return name
}

// GenerateOptions configures how shell scripts are generated.
type GenerateOptions struct {
	// IncludeServer adds -server variants with --server flag for real-time revocation mode.
	IncludeServer bool
}

// GenerateScript generates shell wrapper functions for the given profiles.
// The generated script defines functions like sentinel-production() that wrap
// sentinel exec with the appropriate profile and policy-parameter flags.
// This is a convenience wrapper around GenerateScriptWithOptions with default options.
func GenerateScript(profiles []ProfileInfo, policyRoot string, format ShellFormat) string {
	return GenerateScriptWithOptions(profiles, policyRoot, format, GenerateOptions{})
}

// GenerateScriptWithOptions generates shell wrapper functions with configurable options.
// When opts.IncludeServer is true, it also generates -server variants that include
// the --server flag for real-time revocation mode.
func GenerateScriptWithOptions(profiles []ProfileInfo, policyRoot string, format ShellFormat, opts GenerateOptions) string {
	var sb strings.Builder

	// Header comment
	sb.WriteString("# Sentinel shell functions - generated by sentinel shell init\n")
	sb.WriteString("# Add to your .bashrc/.zshrc: eval \"$(sentinel shell init)\"\n")
	if opts.IncludeServer {
		sb.WriteString("# -server variants use real-time revocation mode\n")
	}
	sb.WriteString("\n")

	if len(profiles) == 0 {
		sb.WriteString("# No profiles found under " + policyRoot + "\n")
		return sb.String()
	}

	// Collect all function names for completion registration
	var allFuncNames []string

	// Generate a function for each profile
	for _, profile := range profiles {
		funcName := sanitizeFunctionName(profile.Name)
		allFuncNames = append(allFuncNames, funcName)

		// Standard function
		sb.WriteString(fmt.Sprintf("%s() {\n", funcName))
		sb.WriteString(fmt.Sprintf("    sentinel exec --profile %s --policy-parameter %s -- \"$@\"\n",
			shellEscape(profile.Name), shellEscape(profile.PolicyPath)))
		sb.WriteString("}\n")
		sb.WriteString("\n")

		// Server mode variant (if requested)
		if opts.IncludeServer {
			serverFuncName := funcName + "-server"
			allFuncNames = append(allFuncNames, serverFuncName)

			sb.WriteString(fmt.Sprintf("%s() {\n", serverFuncName))
			sb.WriteString(fmt.Sprintf("    sentinel exec --server --profile %s --policy-parameter %s -- \"$@\"\n",
				shellEscape(profile.Name), shellEscape(profile.PolicyPath)))
			sb.WriteString("}\n")
			sb.WriteString("\n")
		}
	}

	// Add completion registrations for all generated functions
	// Bash completion
	sb.WriteString("# Completion registrations (bash)\n")
	sb.WriteString("if [[ -n \"${BASH_VERSION:-}\" ]]; then\n")
	for _, funcName := range allFuncNames {
		sb.WriteString(fmt.Sprintf("    complete -o default -o bashdefault %s\n", funcName))
	}
	sb.WriteString("fi\n\n")

	// Zsh completion
	sb.WriteString("# Completion registrations (zsh)\n")
	sb.WriteString("if [[ -n \"${ZSH_VERSION:-}\" ]]; then\n")
	for _, funcName := range allFuncNames {
		sb.WriteString(fmt.Sprintf("    compdef _command_names %s\n", funcName))
	}
	sb.WriteString("fi\n")

	return sb.String()
}

// sanitizeRegex matches any character that is not alphanumeric.
var sanitizeRegex = regexp.MustCompile(`[^a-zA-Z0-9]`)

// sanitizeFunctionName converts a profile name to a valid shell function name.
// It prefixes with "sentinel-" and replaces non-alphanumeric characters with hyphens.
func sanitizeFunctionName(profileName string) string {
	// Replace non-alphanumeric characters with hyphens
	sanitized := sanitizeRegex.ReplaceAllString(profileName, "-")

	// Remove leading/trailing hyphens that may result from sanitization
	sanitized = strings.Trim(sanitized, "-")

	// Collapse multiple consecutive hyphens into one
	for strings.Contains(sanitized, "--") {
		sanitized = strings.ReplaceAll(sanitized, "--", "-")
	}

	return "sentinel-" + sanitized
}

// shellEscape escapes a string for safe use in shell commands.
// For simplicity, we use single quotes which prevent all interpolation.
func shellEscape(s string) string {
	// If the string contains no special characters, return as-is
	if !strings.ContainsAny(s, " \t\n'\"\\$`!") {
		return s
	}

	// Use single quotes and escape any single quotes within
	// 'foo'\''bar' -> foo'bar
	escaped := strings.ReplaceAll(s, "'", "'\\''")
	return "'" + escaped + "'"
}
