
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>audit: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/byteness/aws-vault/v7/audit/types.go (100.0%)</option>
				
				<option value="file1">github.com/byteness/aws-vault/v7/audit/verifier.go (88.1%)</option>
				
				<option value="file2">github.com/byteness/aws-vault/v7/bootstrap/executor.go (92.6%)</option>
				
				<option value="file3">github.com/byteness/aws-vault/v7/bootstrap/format.go (96.8%)</option>
				
				<option value="file4">github.com/byteness/aws-vault/v7/bootstrap/generator.go (90.0%)</option>
				
				<option value="file5">github.com/byteness/aws-vault/v7/bootstrap/iam.go (90.9%)</option>
				
				<option value="file6">github.com/byteness/aws-vault/v7/bootstrap/planner.go (97.0%)</option>
				
				<option value="file7">github.com/byteness/aws-vault/v7/bootstrap/status.go (95.7%)</option>
				
				<option value="file8">github.com/byteness/aws-vault/v7/bootstrap/types.go (100.0%)</option>
				
				<option value="file9">github.com/byteness/aws-vault/v7/bootstrap/validate.go (97.1%)</option>
				
				<option value="file10">github.com/byteness/aws-vault/v7/breakglass/checker.go (100.0%)</option>
				
				<option value="file11">github.com/byteness/aws-vault/v7/breakglass/dynamodb.go (85.7%)</option>
				
				<option value="file12">github.com/byteness/aws-vault/v7/breakglass/policy.go (94.3%)</option>
				
				<option value="file13">github.com/byteness/aws-vault/v7/breakglass/ratelimit.go (100.0%)</option>
				
				<option value="file14">github.com/byteness/aws-vault/v7/breakglass/types.go (94.1%)</option>
				
				<option value="file15">github.com/byteness/aws-vault/v7/breakglass/validate.go (96.7%)</option>
				
				<option value="file16">github.com/byteness/aws-vault/v7/cmd/sentinel/main.go (0.0%)</option>
				
				<option value="file17">github.com/byteness/aws-vault/v7/enforce/advisor.go (92.5%)</option>
				
				<option value="file18">github.com/byteness/aws-vault/v7/enforce/analyze.go (98.5%)</option>
				
				<option value="file19">github.com/byteness/aws-vault/v7/enforce/drift.go (78.1%)</option>
				
				<option value="file20">github.com/byteness/aws-vault/v7/enforce/evaluate.go (96.8%)</option>
				
				<option value="file21">github.com/byteness/aws-vault/v7/enforce/generate.go (92.9%)</option>
				
				<option value="file22">github.com/byteness/aws-vault/v7/enforce/parse.go (90.6%)</option>
				
				<option value="file23">github.com/byteness/aws-vault/v7/enforce/types.go (87.5%)</option>
				
				<option value="file24">github.com/byteness/aws-vault/v7/identity/request_id.go (83.3%)</option>
				
				<option value="file25">github.com/byteness/aws-vault/v7/identity/types.go (100.0%)</option>
				
				<option value="file26">github.com/byteness/aws-vault/v7/iso8601/iso8601.go (100.0%)</option>
				
				<option value="file27">github.com/byteness/aws-vault/v7/logging/approval.go (100.0%)</option>
				
				<option value="file28">github.com/byteness/aws-vault/v7/logging/breakglass.go (100.0%)</option>
				
				<option value="file29">github.com/byteness/aws-vault/v7/logging/decision.go (100.0%)</option>
				
				<option value="file30">github.com/byteness/aws-vault/v7/logging/logger.go (82.4%)</option>
				
				<option value="file31">github.com/byteness/aws-vault/v7/main.go (0.0%)</option>
				
				<option value="file32">github.com/byteness/aws-vault/v7/notification/breakglass_notifier.go (88.7%)</option>
				
				<option value="file33">github.com/byteness/aws-vault/v7/notification/breakglass_types.go (100.0%)</option>
				
				<option value="file34">github.com/byteness/aws-vault/v7/notification/notifier.go (100.0%)</option>
				
				<option value="file35">github.com/byteness/aws-vault/v7/notification/sns.go (77.8%)</option>
				
				<option value="file36">github.com/byteness/aws-vault/v7/notification/store.go (85.7%)</option>
				
				<option value="file37">github.com/byteness/aws-vault/v7/notification/types.go (100.0%)</option>
				
				<option value="file38">github.com/byteness/aws-vault/v7/notification/webhook.go (88.1%)</option>
				
				<option value="file39">github.com/byteness/aws-vault/v7/policy/approval.go (100.0%)</option>
				
				<option value="file40">github.com/byteness/aws-vault/v7/policy/cache.go (93.3%)</option>
				
				<option value="file41">github.com/byteness/aws-vault/v7/policy/evaluate.go (91.7%)</option>
				
				<option value="file42">github.com/byteness/aws-vault/v7/policy/loader.go (12.5%)</option>
				
				<option value="file43">github.com/byteness/aws-vault/v7/policy/parse.go (91.7%)</option>
				
				<option value="file44">github.com/byteness/aws-vault/v7/policy/types.go (85.7%)</option>
				
				<option value="file45">github.com/byteness/aws-vault/v7/policy/validate.go (100.0%)</option>
				
				<option value="file46">github.com/byteness/aws-vault/v7/prompt/kdialog.go (0.0%)</option>
				
				<option value="file47">github.com/byteness/aws-vault/v7/prompt/osascript.go (0.0%)</option>
				
				<option value="file48">github.com/byteness/aws-vault/v7/prompt/prompt.go (0.0%)</option>
				
				<option value="file49">github.com/byteness/aws-vault/v7/prompt/terminal.go (0.0%)</option>
				
				<option value="file50">github.com/byteness/aws-vault/v7/prompt/ykman.go (0.0%)</option>
				
				<option value="file51">github.com/byteness/aws-vault/v7/prompt/zenity.go (0.0%)</option>
				
				<option value="file52">github.com/byteness/aws-vault/v7/request/checker.go (100.0%)</option>
				
				<option value="file53">github.com/byteness/aws-vault/v7/request/dynamodb.go (76.5%)</option>
				
				<option value="file54">github.com/byteness/aws-vault/v7/request/types.go (92.3%)</option>
				
				<option value="file55">github.com/byteness/aws-vault/v7/request/validate.go (96.4%)</option>
				
				<option value="file56">github.com/byteness/aws-vault/v7/sentinel/assume_role.go (88.5%)</option>
				
				<option value="file57">github.com/byteness/aws-vault/v7/sentinel/provider.go (89.7%)</option>
				
				<option value="file58">github.com/byteness/aws-vault/v7/server/ec2alias_bsd.go (0.0%)</option>
				
				<option value="file59">github.com/byteness/aws-vault/v7/server/ec2proxy.go (0.0%)</option>
				
				<option value="file60">github.com/byteness/aws-vault/v7/server/ec2proxy_unix.go (0.0%)</option>
				
				<option value="file61">github.com/byteness/aws-vault/v7/server/ec2server.go (0.0%)</option>
				
				<option value="file62">github.com/byteness/aws-vault/v7/server/ecsserver.go (0.0%)</option>
				
				<option value="file63">github.com/byteness/aws-vault/v7/server/httplog.go (0.0%)</option>
				
				<option value="file64">github.com/byteness/aws-vault/v7/testutil/mock_aws.go (0.0%)</option>
				
				<option value="file65">github.com/byteness/aws-vault/v7/vault/assumeroleprovider.go (0.0%)</option>
				
				<option value="file66">github.com/byteness/aws-vault/v7/vault/assumerolewithwebidentityprovider.go (0.0%)</option>
				
				<option value="file67">github.com/byteness/aws-vault/v7/vault/cachedsessionprovider.go (0.0%)</option>
				
				<option value="file68">github.com/byteness/aws-vault/v7/vault/config.go (64.2%)</option>
				
				<option value="file69">github.com/byteness/aws-vault/v7/vault/credentialkeyring.go (16.0%)</option>
				
				<option value="file70">github.com/byteness/aws-vault/v7/vault/credentialprocessprovider.go (90.5%)</option>
				
				<option value="file71">github.com/byteness/aws-vault/v7/vault/executeprocess.go (0.0%)</option>
				
				<option value="file72">github.com/byteness/aws-vault/v7/vault/federationtokenprovider.go (0.0%)</option>
				
				<option value="file73">github.com/byteness/aws-vault/v7/vault/getuser.go (0.0%)</option>
				
				<option value="file74">github.com/byteness/aws-vault/v7/vault/keyringprovider.go (0.0%)</option>
				
				<option value="file75">github.com/byteness/aws-vault/v7/vault/mfa.go (0.0%)</option>
				
				<option value="file76">github.com/byteness/aws-vault/v7/vault/mfa_unix.go (0.0%)</option>
				
				<option value="file77">github.com/byteness/aws-vault/v7/vault/oidctokenkeyring.go (0.0%)</option>
				
				<option value="file78">github.com/byteness/aws-vault/v7/vault/sessionkeyring.go (13.6%)</option>
				
				<option value="file79">github.com/byteness/aws-vault/v7/vault/sessiontokenprovider.go (0.0%)</option>
				
				<option value="file80">github.com/byteness/aws-vault/v7/vault/ssorolecredentialsprovider.go (0.0%)</option>
				
				<option value="file81">github.com/byteness/aws-vault/v7/vault/stsendpointresolver.go (11.1%)</option>
				
				<option value="file82">github.com/byteness/aws-vault/v7/vault/vault.go (35.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package audit provides types and functions for CloudTrail session verification.
// It enables querying CloudTrail to verify that AWS sessions have proper Sentinel
// SourceIdentity, detect missing enforcement, and identify potential bypasses.
package audit

import (
        "strings"
        "time"
)

// SessionInfo contains parsed information from a CloudTrail event.
// It represents the relevant details about an AWS session for verification purposes.
type SessionInfo struct {
        // SourceIdentity is the sts:SourceIdentity value (e.g., "sentinel:alice:a1b2c3d4")
        SourceIdentity string `json:"source_identity,omitempty"`
        // EventTime is when the event occurred
        EventTime time.Time `json:"event_time"`
        // EventID is the CloudTrail event ID
        EventID string `json:"event_id"`
        // EventName is the AWS API action (e.g., "AssumeRole")
        EventName string `json:"event_name"`
        // EventSource is the AWS service (e.g., "sts.amazonaws.com")
        EventSource string `json:"event_source"`
        // RoleARN is the target role ARN
        RoleARN string `json:"role_arn,omitempty"`
        // Username is the IAM username or principal
        Username string `json:"username,omitempty"`
        // IsSentinel is true if SourceIdentity starts with "sentinel:"
        IsSentinel bool `json:"is_sentinel"`
        // User is the parsed user from SourceIdentity (if Sentinel)
        User string `json:"user,omitempty"`
        // RequestID is the parsed request-id from SourceIdentity (if Sentinel)
        RequestID string `json:"request_id,omitempty"`
}

// VerificationResult contains the outcome of verifying sessions in a time window.
type VerificationResult struct {
        // StartTime is the query start time
        StartTime time.Time `json:"start_time"`
        // EndTime is the query end time
        EndTime time.Time `json:"end_time"`
        // TotalSessions is the total number of sessions examined
        TotalSessions int `json:"total_sessions"`
        // SentinelSessions is the count of sessions with valid Sentinel SourceIdentity
        SentinelSessions int `json:"sentinel_sessions"`
        // NonSentinelSessions is the count of sessions without Sentinel SourceIdentity
        NonSentinelSessions int `json:"non_sentinel_sessions"`
        // BreakGlassSessions is the count of sessions with break-glass markers (future use)
        BreakGlassSessions int `json:"break_glass_sessions"`
        // UnknownSessions is the count of sessions that couldn't be classified
        UnknownSessions int `json:"unknown_sessions"`
        // Issues lists problems found during verification
        Issues []SessionIssue `json:"issues,omitempty"`
}

// HasIssues returns true if any issues were found during verification.
func (r *VerificationResult) HasIssues() bool <span class="cov5" title="6">{
        return len(r.Issues) &gt; 0
}</span>

// PassRate returns the percentage of sessions with valid Sentinel SourceIdentity.
// Returns 100.0 if there are no sessions, 0.0 if all sessions are non-Sentinel.
func (r *VerificationResult) PassRate() float64 <span class="cov7" title="9">{
        if r.TotalSessions == 0 </span><span class="cov2" title="2">{
                return 100.0
        }</span>
        <span class="cov6" title="7">return float64(r.SentinelSessions) / float64(r.TotalSessions) * 100.0</span>
}

// SessionIssue represents a problem detected during verification.
type SessionIssue struct {
        // Severity indicates the issue severity ("warning" or "error")
        Severity IssueSeverity `json:"severity"`
        // Type indicates the issue type
        Type IssueType `json:"type"`
        // SessionInfo is the problematic session
        SessionInfo *SessionInfo `json:"session_info,omitempty"`
        // Message is a human-readable description
        Message string `json:"message"`
}

// IssueSeverity indicates the severity of a session issue.
type IssueSeverity string

const (
        // SeverityWarning indicates a non-critical issue that should be investigated
        SeverityWarning IssueSeverity = "warning"
        // SeverityError indicates a critical issue requiring immediate attention
        SeverityError IssueSeverity = "error"
)

// IsValid returns true if the IssueSeverity is a known value.
func (s IssueSeverity) IsValid() bool <span class="cov4" title="4">{
        return s == SeverityWarning || s == SeverityError
}</span>

// String returns the string representation of the IssueSeverity.
func (s IssueSeverity) String() string <span class="cov2" title="2">{
        return string(s)
}</span>

// IssueType indicates the type of issue detected during verification.
type IssueType string

const (
        // IssueTypeMissingSourceIdentity indicates a session without SourceIdentity
        IssueTypeMissingSourceIdentity IssueType = "missing_source_identity"
        // IssueTypeBypassDetected indicates a potential bypass of Sentinel enforcement
        IssueTypeBypassDetected IssueType = "bypass_detected"
        // IssueTypeUnexpectedSourceIdentity indicates a SourceIdentity that doesn't match Sentinel format
        IssueTypeUnexpectedSourceIdentity IssueType = "unexpected_source_identity"
)

// IsValid returns true if the IssueType is a known value.
func (t IssueType) IsValid() bool <span class="cov5" title="5">{
        return t == IssueTypeMissingSourceIdentity ||
                t == IssueTypeBypassDetected ||
                t == IssueTypeUnexpectedSourceIdentity
}</span>

// String returns the string representation of the IssueType.
func (t IssueType) String() string <span class="cov4" title="3">{
        return string(t)
}</span>

// VerifyInput contains parameters for session verification.
type VerifyInput struct {
        // StartTime is the beginning of the time window to query
        StartTime time.Time
        // EndTime is the end of the time window to query
        EndTime time.Time
        // RoleARN optionally filters by a specific role
        RoleARN string
        // Username optionally filters by a specific user
        Username string
}

// ParseSourceIdentity parses a SourceIdentity string into its components.
// Returns the user, requestID, and whether it's a valid Sentinel format.
//
// Sentinel SourceIdentity format: "sentinel:&lt;user&gt;:&lt;request-id&gt;"
// Example: "sentinel:alice:a1b2c3d4" -&gt; ("alice", "a1b2c3d4", true)
//
// Non-Sentinel format returns empty strings and false.
func ParseSourceIdentity(sourceIdentity string) (user string, requestID string, isSentinel bool) <span class="cov10" title="27">{
        if sourceIdentity == "" </span><span class="cov5" title="6">{
                return "", "", false
        }</span>

        // Must start with "sentinel:"
        <span class="cov9" title="21">if !strings.HasPrefix(sourceIdentity, "sentinel:") </span><span class="cov4" title="4">{
                return "", "", false
        }</span>

        // Remove the "sentinel:" prefix
        <span class="cov8" title="17">remainder := strings.TrimPrefix(sourceIdentity, "sentinel:")

        // Split by ":" to get user and request-id
        parts := strings.SplitN(remainder, ":", 2)
        if len(parts) != 2 </span><span class="cov2" title="2">{
                return "", "", false
        }</span>

        <span class="cov8" title="15">user = parts[0]
        requestID = parts[1]

        // Both user and requestID must be non-empty
        if user == "" || requestID == "" </span><span class="cov2" title="2">{
                return "", "", false
        }</span>

        <span class="cov8" title="13">return user, requestID, true</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package audit

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/cloudtrail"
        "github.com/aws/aws-sdk-go-v2/service/cloudtrail/types"
)

// cloudtrailAPI defines the CloudTrail operations used by Verifier.
// This interface enables testing with mock implementations.
type cloudtrailAPI interface {
        LookupEvents(ctx context.Context, params *cloudtrail.LookupEventsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.LookupEventsOutput, error)
}

// SessionVerifier defines the interface for session verification.
// Both Verifier and TestVerifier implement this interface.
type SessionVerifier interface {
        Verify(ctx context.Context, input *VerifyInput) (*VerificationResult, error)
}

// Verifier queries CloudTrail and analyzes sessions for Sentinel enforcement.
type Verifier struct {
        client cloudtrailAPI
}

// NewVerifier creates a new Verifier using the provided AWS configuration.
func NewVerifier(cfg aws.Config) *Verifier <span class="cov0" title="0">{
        return &amp;Verifier{
                client: cloudtrail.NewFromConfig(cfg),
        }
}</span>

// newVerifierWithClient creates a Verifier with a custom client.
// This is primarily used for testing with mock clients.
func newVerifierWithClient(client cloudtrailAPI) *Verifier <span class="cov7" title="7">{
        return &amp;Verifier{
                client: client,
        }
}</span>

// Verify queries CloudTrail for sessions in the given time window and analyzes them
// for Sentinel enforcement. It identifies sessions with and without Sentinel SourceIdentity.
func (v *Verifier) Verify(ctx context.Context, input *VerifyInput) (*VerificationResult, error) <span class="cov7" title="7">{
        result := &amp;VerificationResult{
                StartTime: input.StartTime,
                EndTime:   input.EndTime,
        }

        // Build lookup attributes for filtering
        var lookupAttributes []types.LookupAttribute
        if input.Username != "" </span><span class="cov1" title="1">{
                lookupAttributes = append(lookupAttributes, types.LookupAttribute{
                        AttributeKey:   types.LookupAttributeKeyUsername,
                        AttributeValue: aws.String(input.Username),
                })
        }</span>

        // Paginate through all events
        <span class="cov7" title="7">var nextToken *string
        for </span><span class="cov7" title="8">{
                lookupInput := &amp;cloudtrail.LookupEventsInput{
                        StartTime: aws.Time(input.StartTime),
                        EndTime:   aws.Time(input.EndTime),
                        NextToken: nextToken,
                }
                if len(lookupAttributes) &gt; 0 </span><span class="cov1" title="1">{
                        lookupInput.LookupAttributes = lookupAttributes
                }</span>

                <span class="cov7" title="8">output, err := v.client.LookupEvents(ctx, lookupInput)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("lookup events: %w", err)
                }</span>

                // Process each event
                <span class="cov7" title="8">for _, event := range output.Events </span><span class="cov8" title="11">{
                        sessionInfo, err := parseCloudTrailEvent(event)
                        if err != nil </span><span class="cov0" title="0">{
                                // Log parsing error but continue processing
                                result.UnknownSessions++
                                continue</span>
                        }

                        // Skip if filtering by RoleARN and this event doesn't match
                        <span class="cov8" title="11">if input.RoleARN != "" &amp;&amp; sessionInfo.RoleARN != input.RoleARN </span><span class="cov1" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="10">result.TotalSessions++

                        if sessionInfo.IsSentinel </span><span class="cov7" title="7">{
                                result.SentinelSessions++
                        }</span> else<span class="cov4" title="3"> {
                                result.NonSentinelSessions++

                                // Create an issue for non-Sentinel session
                                issue := SessionIssue{
                                        Severity:    SeverityWarning,
                                        Type:        IssueTypeMissingSourceIdentity,
                                        SessionInfo: sessionInfo,
                                        Message:     fmt.Sprintf("Session without Sentinel SourceIdentity: %s (event: %s)", sessionInfo.Username, sessionInfo.EventName),
                                }
                                result.Issues = append(result.Issues, issue)
                        }</span>
                }

                // Check for more pages
                <span class="cov7" title="8">nextToken = output.NextToken
                if nextToken == nil </span><span class="cov7" title="7">{
                        break</span>
                }
        }

        <span class="cov7" title="7">return result, nil</span>
}

// cloudTrailEventPayload represents the parsed JSON from CloudTrailEvent field.
type cloudTrailEventPayload struct {
        UserIdentity struct {
                SourceIdentity string `json:"sourceIdentity"`
                ARN            string `json:"arn"`
                Type           string `json:"type"`
                UserName       string `json:"userName"`
                SessionContext struct {
                        SessionIssuer struct {
                                ARN string `json:"arn"`
                        } `json:"sessionIssuer"`
                } `json:"sessionContext"`
        } `json:"userIdentity"`
        EventTime   string `json:"eventTime"`
        EventName   string `json:"eventName"`
        EventSource string `json:"eventSource"`
        EventID     string `json:"eventID"`
}

// parseCloudTrailEvent parses a CloudTrail event and extracts session information.
func parseCloudTrailEvent(event types.Event) (*SessionInfo, error) <span class="cov10" title="16">{
        info := &amp;SessionInfo{}

        // Get EventID from the event object
        if event.EventId != nil </span><span class="cov10" title="16">{
                info.EventID = *event.EventId
        }</span>

        // Get EventName from the event object
        <span class="cov10" title="16">if event.EventName != nil </span><span class="cov10" title="16">{
                info.EventName = *event.EventName
        }</span>

        // Get EventSource from the event object
        <span class="cov10" title="16">if event.EventSource != nil </span><span class="cov9" title="15">{
                info.EventSource = *event.EventSource
        }</span>

        // Get EventTime from the event object
        <span class="cov10" title="16">if event.EventTime != nil </span><span class="cov9" title="15">{
                info.EventTime = *event.EventTime
        }</span>

        // Get Username from the event object
        <span class="cov10" title="16">if event.Username != nil </span><span class="cov9" title="15">{
                info.Username = *event.Username
        }</span>

        // Parse the CloudTrailEvent JSON for additional details
        <span class="cov10" title="16">if event.CloudTrailEvent != nil </span><span class="cov9" title="15">{
                var payload cloudTrailEventPayload
                if err := json.Unmarshal([]byte(*event.CloudTrailEvent), &amp;payload); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("unmarshal cloudtrail event: %w", err)
                }</span>

                // Extract SourceIdentity from userIdentity
                <span class="cov9" title="14">info.SourceIdentity = payload.UserIdentity.SourceIdentity

                // Extract RoleARN from sessionContext.sessionIssuer.arn
                if payload.UserIdentity.SessionContext.SessionIssuer.ARN != "" </span><span class="cov6" title="6">{
                        info.RoleARN = payload.UserIdentity.SessionContext.SessionIssuer.ARN
                }</span>

                // Fallback username from payload if not in event object
                <span class="cov9" title="14">if info.Username == "" &amp;&amp; payload.UserIdentity.UserName != "" </span><span class="cov0" title="0">{
                        info.Username = payload.UserIdentity.UserName
                }</span>
        }

        // Parse SourceIdentity to determine if it's a Sentinel session
        <span class="cov9" title="15">user, requestID, isSentinel := ParseSourceIdentity(info.SourceIdentity)
        info.IsSentinel = isSentinel
        if isSentinel </span><span class="cov8" title="9">{
                info.User = user
                info.RequestID = requestID
        }</span>

        <span class="cov9" title="15">return info, nil</span>
}

// VerifyFunc is a function type for custom verify implementations (used for testing).
type VerifyFunc func(ctx context.Context, input *VerifyInput) (*VerificationResult, error)

// TestVerifier wraps a VerifyFunc for testing purposes.
// Use NewVerifierForTest to create instances.
type TestVerifier struct {
        verifyFunc VerifyFunc
}

// NewVerifierForTest creates a TestVerifier that uses a custom verify function.
// This is used for testing CLI commands without actual AWS calls.
func NewVerifierForTest(fn VerifyFunc) *TestVerifier <span class="cov0" title="0">{
        return &amp;TestVerifier{
                verifyFunc: fn,
        }
}</span>

// Verify calls the custom verify function.
func (v *TestVerifier) Verify(ctx context.Context, input *VerifyInput) (*VerificationResult, error) <span class="cov0" title="0">{
        return v.verifyFunc(ctx, input)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package bootstrap

import (
        "context"
        "errors"
        "fmt"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/ssm"
        "github.com/aws/aws-sdk-go-v2/service/ssm/types"
)

// ssmWriterAPI defines the SSM write operations used by Executor.
// This interface enables testing with mock implementations.
type ssmWriterAPI interface {
        PutParameter(ctx context.Context, params *ssm.PutParameterInput, optFns ...func(*ssm.Options)) (*ssm.PutParameterOutput, error)
}

// Executor applies a BootstrapPlan by creating or updating SSM parameters.
// It provides terraform apply-style execution after planning.
type Executor struct {
        ssm ssmWriterAPI
}

// NewExecutor creates a new Executor using the provided AWS configuration.
func NewExecutor(cfg aws.Config) *Executor <span class="cov0" title="0">{
        return &amp;Executor{
                ssm: ssm.NewFromConfig(cfg),
        }
}</span>

// newExecutorWithClient creates an Executor with a custom SSM client.
// This is primarily used for testing with mock clients.
func newExecutorWithClient(client ssmWriterAPI) *Executor <span class="cov8" title="10">{
        return &amp;Executor{
                ssm: client,
        }
}</span>

// ApplyError represents a failed parameter operation.
type ApplyError struct {
        // Name is the parameter name that failed.
        Name string `json:"name"`
        // Error is the error message.
        Error string `json:"error"`
}

// ApplyResult contains the results of applying a bootstrap plan.
type ApplyResult struct {
        // Created contains names of successfully created parameters.
        Created []string `json:"created"`
        // Updated contains names of successfully updated parameters.
        Updated []string `json:"updated"`
        // Skipped contains names of skipped parameters.
        Skipped []string `json:"skipped"`
        // Failed contains parameters that failed to create or update.
        Failed []ApplyError `json:"failed"`
}

// Apply executes a BootstrapPlan, creating or updating SSM parameters.
// It continues processing on individual failures, collecting all errors in the result.
func (e *Executor) Apply(ctx context.Context, plan *BootstrapPlan) (*ApplyResult, error) <span class="cov8" title="10">{
        result := &amp;ApplyResult{
                Created: []string{},
                Updated: []string{},
                Skipped: []string{},
                Failed:  []ApplyError{},
        }

        for _, resource := range plan.Resources </span><span class="cov10" title="16">{
                // Skip non-SSM resources (IAM policies are not created via SSM)
                if resource.Type != ResourceTypeSSMParameter </span><span class="cov3" title="2">{
                        result.Skipped = append(result.Skipped, resource.Name)
                        continue</span>
                }

                <span class="cov9" title="14">switch resource.State </span>{
                case StateExists, StateSkip:<span class="cov5" title="4">
                        result.Skipped = append(result.Skipped, resource.Name)</span>

                case StateCreate:<span class="cov7" title="8">
                        err := e.putParameter(ctx, resource.Name, "", false)
                        if err != nil </span><span class="cov4" title="3">{
                                result.Failed = append(result.Failed, ApplyError{
                                        Name:  resource.Name,
                                        Error: err.Error(),
                                })
                        }</span> else<span class="cov6" title="5"> {
                                result.Created = append(result.Created, resource.Name)
                        }</span>

                case StateUpdate:<span class="cov3" title="2">
                        err := e.putParameter(ctx, resource.Name, "", true)
                        if err != nil </span><span class="cov0" title="0">{
                                result.Failed = append(result.Failed, ApplyError{
                                        Name:  resource.Name,
                                        Error: err.Error(),
                                })
                        }</span> else<span class="cov3" title="2"> {
                                result.Updated = append(result.Updated, resource.Name)
                        }</span>
                }
        }

        <span class="cov8" title="10">return result, nil</span>
}

// putParameter creates or updates an SSM parameter.
func (e *Executor) putParameter(ctx context.Context, name, value string, overwrite bool) error <span class="cov8" title="10">{
        // Use empty policy placeholder if no value provided
        if value == "" </span><span class="cov8" title="10">{
                value = "# Sentinel policy placeholder\nversion: \"1\"\nrules: []\n"
        }</span>

        <span class="cov8" title="10">_, err := e.ssm.PutParameter(ctx, &amp;ssm.PutParameterInput{
                Name:      aws.String(name),
                Value:     aws.String(value),
                Type:      types.ParameterTypeString,
                Overwrite: aws.Bool(overwrite),
        })

        if err != nil </span><span class="cov4" title="3">{
                var alreadyExists *types.ParameterAlreadyExists
                if errors.As(err, &amp;alreadyExists) </span><span class="cov1" title="1">{
                        return fmt.Errorf("parameter already exists (possible race condition): %s", name)
                }</span>
                <span class="cov3" title="2">return fmt.Errorf("SSM PutParameter failed: %w", err)</span>
        }

        <span class="cov7" title="7">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package bootstrap

import (
        "encoding/json"
        "fmt"
        "strings"
)

// stateSymbol returns the visual indicator for a resource state.
func stateSymbol(state ResourceState) string <span class="cov10" title="15">{
        switch state </span>{
        case StateCreate:<span class="cov6" title="6">
                return "+"</span>
        case StateUpdate:<span class="cov3" title="2">
                return "~"</span>
        case StateExists:<span class="cov5" title="4">
                return "="</span>
        case StateSkip:<span class="cov3" title="2">
                return "-"</span>
        default:<span class="cov1" title="1">
                return "?"</span>
        }
}

// stateLabel returns the human-readable label for a resource state.
func stateLabel(state ResourceState) string <span class="cov9" title="13">{
        switch state </span>{
        case StateCreate:<span class="cov5" title="4">
                return "create"</span>
        case StateUpdate:<span class="cov3" title="2">
                return "update"</span>
        case StateExists:<span class="cov5" title="4">
                return "exists"</span>
        case StateSkip:<span class="cov3" title="2">
                return "skip"</span>
        default:<span class="cov1" title="1">
                return "unknown"</span>
        }
}

// FormatPlan produces human-readable output for a BootstrapPlan.
// The output format is similar to terraform plan output.
func FormatPlan(plan *BootstrapPlan) string <span class="cov6" title="6">{
        var sb strings.Builder

        // Header
        sb.WriteString("Bootstrap Plan\n")
        sb.WriteString("==============\n")

        // Config summary
        sb.WriteString(fmt.Sprintf("Policy Root: %s\n", plan.Config.PolicyRoot))
        region := plan.Config.Region
        if region == "" </span><span class="cov6" title="5">{
                region = "default"
        }</span>
        <span class="cov6" title="6">sb.WriteString(fmt.Sprintf("Region: %s\n", region))
        sb.WriteString("\n")

        // Empty plan check
        if len(plan.Resources) == 0 </span><span class="cov1" title="1">{
                sb.WriteString("Resources: (none)\n\n")
                sb.WriteString("Summary: No resources to manage\n")
                return sb.String()
        }</span>

        // Separate resources by type
        <span class="cov6" title="5">var ssmParams, iamPolicies []ResourceSpec
        for _, r := range plan.Resources </span><span class="cov8" title="10">{
                switch r.Type </span>{
                case ResourceTypeSSMParameter:<span class="cov7" title="8">
                        ssmParams = append(ssmParams, r)</span>
                case ResourceTypeIAMPolicy:<span class="cov3" title="2">
                        iamPolicies = append(iamPolicies, r)</span>
                }
        }

        // Check if we need to group by type
        <span class="cov6" title="5">hasMultipleTypes := len(ssmParams) &gt; 0 &amp;&amp; len(iamPolicies) &gt; 0

        if hasMultipleTypes </span><span class="cov1" title="1">{
                // Grouped output
                if len(ssmParams) &gt; 0 </span><span class="cov1" title="1">{
                        sb.WriteString("SSM Parameters:\n")
                        for _, r := range ssmParams </span><span class="cov1" title="1">{
                                sb.WriteString(formatResource(r))
                        }</span>
                        <span class="cov1" title="1">sb.WriteString("\n")</span>
                }
                <span class="cov1" title="1">if len(iamPolicies) &gt; 0 </span><span class="cov1" title="1">{
                        sb.WriteString("IAM Policy Documents:\n")
                        for _, r := range iamPolicies </span><span class="cov3" title="2">{
                                sb.WriteString(formatIAMResource(r))
                        }</span>
                        <span class="cov1" title="1">sb.WriteString("\n")</span>
                }
        } else<span class="cov5" title="4"> {
                // Simple output
                sb.WriteString("Resources:\n")
                for _, r := range plan.Resources </span><span class="cov7" title="7">{
                        if r.Type == ResourceTypeIAMPolicy </span><span class="cov0" title="0">{
                                sb.WriteString(formatIAMResource(r))
                        }</span> else<span class="cov7" title="7"> {
                                sb.WriteString(formatResource(r))
                        }</span>
                }
                <span class="cov5" title="4">sb.WriteString("\n")</span>
        }

        // Summary line
        <span class="cov6" title="5">sb.WriteString(fmt.Sprintf("Summary: %d to create, %d to update, %d existing\n",
                plan.Summary.ToCreate,
                plan.Summary.ToUpdate,
                plan.Summary.ToSkip,
        ))

        return sb.String()</span>
}

// formatResource formats a single SSM parameter resource line.
func formatResource(r ResourceSpec) string <span class="cov7" title="8">{
        symbol := stateSymbol(r.State)
        label := stateLabel(r.State)

        // Build version info if available
        versionInfo := ""
        if r.CurrentVersion != "" </span><span class="cov5" title="4">{
                versionInfo = fmt.Sprintf(", v%s", r.CurrentVersion)
        }</span>

        <span class="cov7" title="8">return fmt.Sprintf("  %s %-35s (SSM Parameter - %s%s)\n",
                symbol, r.Name, label, versionInfo)</span>
}

// formatIAMResource formats a single IAM policy resource line.
func formatIAMResource(r ResourceSpec) string <span class="cov3" title="2">{
        symbol := stateSymbol(r.State)

        // IAM policies are always generated (documents, not actual IAM resources)
        action := "generate"
        if r.State == StateSkip </span><span class="cov0" title="0">{
                action = "skip"
        }</span>

        <span class="cov3" title="2">return fmt.Sprintf("  %s %-35s (%s)\n", symbol, r.Name, action)</span>
}

// FormatPlanJSON produces JSON output for a BootstrapPlan.
// This is useful for machine-readable output and piping to other tools.
func FormatPlanJSON(plan *BootstrapPlan) ([]byte, error) <span class="cov3" title="2">{
        return json.MarshalIndent(plan, "", "  ")
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package bootstrap

import (
        "bytes"
        "fmt"
        "time"

        "github.com/byteness/aws-vault/v7/policy"
        "gopkg.in/yaml.v3"
)

// GenerateSamplePolicy creates a valid starter policy YAML for a profile.
// The generated policy contains a default deny rule that users can customize.
// It returns an error if the profile name is empty.
func GenerateSamplePolicy(profile, description string) (string, error) <span class="cov10" title="11">{
        if profile == "" </span><span class="cov1" title="1">{
                return "", fmt.Errorf("profile name cannot be empty")
        }</span>

        // Build policy struct
        <span class="cov9" title="10">p := policy.Policy{
                Version: PolicyVersion,
                Rules: []policy.Rule{
                        {
                                Name:   "default-deny",
                                Effect: policy.EffectDeny,
                                Conditions: policy.Condition{
                                        Profiles: []string{profile},
                                },
                                Reason: "Default deny - customize this policy",
                        },
                },
        }

        // Validate before marshaling
        if err := p.Validate(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("generated policy is invalid: %w", err)
        }</span>

        // Marshal to YAML with 2-space indent
        <span class="cov9" title="10">var buf bytes.Buffer
        encoder := yaml.NewEncoder(&amp;buf)
        encoder.SetIndent(2)
        if err := encoder.Encode(&amp;p); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal policy: %w", err)
        }</span>
        <span class="cov9" title="10">encoder.Close()

        // Build header comment
        header := buildPolicyHeader(profile, description)

        return header + buf.String(), nil</span>
}

// buildPolicyHeader creates the comment header for a generated policy.
func buildPolicyHeader(profile, description string) string <span class="cov9" title="10">{
        var header bytes.Buffer

        header.WriteString(fmt.Sprintf("# Sentinel policy for profile: %s\n", profile))
        if description != "" </span><span class="cov6" title="4">{
                header.WriteString(fmt.Sprintf("# %s\n", description))
        }</span>
        <span class="cov9" title="10">header.WriteString(fmt.Sprintf("# Generated: %s\n", time.Now().UTC().Format(time.RFC3339)))
        header.WriteString("# Customize this policy to match your access requirements.\n\n")

        return header.String()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package bootstrap

import (
        "encoding/json"
        "strings"
)

// IAMPolicyDocument represents an AWS IAM policy document.
type IAMPolicyDocument struct {
        Version   string         `json:"Version"`
        Statement []IAMStatement `json:"Statement"`
}

// IAMStatement represents a single statement in an IAM policy.
type IAMStatement struct {
        Sid      string   `json:"Sid,omitempty"`
        Effect   string   `json:"Effect"`
        Action   []string `json:"Action"`
        Resource []string `json:"Resource"`
}

// IAM policy version required by AWS.
const iamPolicyVersion = "2012-10-17"

// SSM read actions for the reader policy.
var ssmReadActions = []string{
        "ssm:GetParameter",
        "ssm:GetParameters",
        "ssm:GetParametersByPath",
}

// SSM write actions for the admin policy (in addition to read actions).
var ssmWriteActions = []string{
        "ssm:PutParameter",
        "ssm:DeleteParameter",
        "ssm:AddTagsToResource",
        "ssm:RemoveTagsFromResource",
}

// GenerateReaderPolicy creates an IAM policy document for read-only access
// to Sentinel policy parameters in SSM.
func GenerateReaderPolicy(policyRoot string) IAMPolicyDocument <span class="cov8" title="9">{
        return IAMPolicyDocument{
                Version: iamPolicyVersion,
                Statement: []IAMStatement{
                        {
                                Sid:      "SentinelPolicyRead",
                                Effect:   "Allow",
                                Action:   ssmReadActions,
                                Resource: []string{buildSSMResourceARN(policyRoot)},
                        },
                },
        }
}</span>

// GenerateAdminPolicy creates an IAM policy document for full access
// to Sentinel policy parameters in SSM.
func GenerateAdminPolicy(policyRoot string) IAMPolicyDocument <span class="cov4" title="3">{
        // Combine read and write actions
        allActions := make([]string, 0, len(ssmReadActions)+len(ssmWriteActions))
        allActions = append(allActions, ssmReadActions...)
        allActions = append(allActions, ssmWriteActions...)

        return IAMPolicyDocument{
                Version: iamPolicyVersion,
                Statement: []IAMStatement{
                        {
                                Sid:      "SentinelPolicyAdmin",
                                Effect:   "Allow",
                                Action:   allActions,
                                Resource: []string{buildSSMResourceARN(policyRoot)},
                        },
                },
        }
}</span>

// FormatIAMPolicy marshals an IAM policy document to indented JSON.
func FormatIAMPolicy(doc IAMPolicyDocument) (string, error) <span class="cov4" title="3">{
        data, err := json.MarshalIndent(doc, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov4" title="3">return string(data), nil</span>
}

// buildSSMResourceARN constructs the ARN pattern for SSM parameters.
// Uses wildcards for region and account for portability.
// Format: arn:aws:ssm:*:*:parameter{policyRoot}/*
func buildSSMResourceARN(policyRoot string) string <span class="cov10" title="12">{
        // Normalize: remove trailing slash if present
        root := strings.TrimSuffix(policyRoot, "/")
        return "arn:aws:ssm:*:*:parameter" + root + "/*"
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package bootstrap

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/ssm"
        "github.com/aws/aws-sdk-go-v2/service/ssm/types"
)

// ssmAPI defines the SSM operations used by Planner.
// This interface enables testing with mock implementations.
type ssmAPI interface {
        GetParameter(ctx context.Context, params *ssm.GetParameterInput, optFns ...func(*ssm.Options)) (*ssm.GetParameterOutput, error)
}

// Planner checks AWS SSM for existing parameters and produces a BootstrapPlan.
// It enables dry-run workflow (terraform plan-style) before making changes.
type Planner struct {
        ssm ssmAPI
}

// NewPlanner creates a new Planner using the provided AWS configuration.
func NewPlanner(cfg aws.Config) *Planner <span class="cov0" title="0">{
        return &amp;Planner{
                ssm: ssm.NewFromConfig(cfg),
        }
}</span>

// newPlannerWithClient creates a Planner with a custom SSM client.
// This is primarily used for testing with mock clients.
func newPlannerWithClient(client ssmAPI) *Planner <span class="cov8" title="9">{
        return &amp;Planner{
                ssm: client,
        }
}</span>

// Plan checks SSM for existing parameters and produces a BootstrapPlan.
// It validates the config first, then checks each profile's parameter existence.
func (p *Planner) Plan(ctx context.Context, config *BootstrapConfig) (*BootstrapPlan, error) <span class="cov8" title="9">{
        // Validate config first
        if err := config.Validate(); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid config: %w", err)
        }</span>

        <span class="cov8" title="8">var resources []ResourceSpec

        // Check each profile's SSM parameter
        for _, profile := range config.Profiles </span><span class="cov10" title="12">{
                // Determine parameter name
                paramName := profile.PolicyParameterName
                if paramName == "" </span><span class="cov9" title="11">{
                        paramName = DefaultPolicyParameterName(config.PolicyRoot, profile.Name)
                }</span>

                // Check if parameter exists
                <span class="cov10" title="12">exists, version, err := p.checkSSMParameter(ctx, paramName)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("check parameter %s: %w", paramName, err)
                }</span>

                // Build resource spec
                <span class="cov9" title="11">spec := ResourceSpec{
                        Type:        ResourceTypeSSMParameter,
                        Name:        paramName,
                        Description: fmt.Sprintf("Policy parameter for profile %s", profile.Name),
                }

                if exists </span><span class="cov4" title="3">{
                        spec.State = StateExists
                        spec.CurrentVersion = version
                }</span> else<span class="cov8" title="8"> {
                        spec.State = StateCreate
                }</span>

                <span class="cov9" title="11">resources = append(resources, spec)</span>
        }

        // Add IAM policy document specs if requested
        <span class="cov8" title="7">if config.GenerateIAMPolicies </span><span class="cov1" title="1">{
                resources = append(resources,
                        ResourceSpec{
                                Type:        ResourceTypeIAMPolicy,
                                Name:        IAMPolicyName("Policy", "Reader"),
                                State:       StateCreate,
                                Description: "IAM policy document for read-only access to Sentinel policies",
                        },
                        ResourceSpec{
                                Type:        ResourceTypeIAMPolicy,
                                Name:        IAMPolicyName("Policy", "Admin"),
                                State:       StateCreate,
                                Description: "IAM policy document for administrative access to Sentinel policies",
                        },
                )
        }</span>

        // Build plan
        <span class="cov8" title="7">plan := &amp;BootstrapPlan{
                Config:      *config,
                Resources:   resources,
                GeneratedAt: time.Now(),
        }

        // Compute summary
        plan.Summary.Compute(resources)

        return plan, nil</span>
}

// checkSSMParameter checks if an SSM parameter exists.
// Returns (exists, version, error).
func (p *Planner) checkSSMParameter(ctx context.Context, paramName string) (bool, string, error) <span class="cov10" title="12">{
        output, err := p.ssm.GetParameter(ctx, &amp;ssm.GetParameterInput{
                Name: aws.String(paramName),
        })
        if err != nil </span><span class="cov8" title="9">{
                var notFound *types.ParameterNotFound
                if errors.As(err, &amp;notFound) </span><span class="cov8" title="8">{
                        return false, "", nil
                }</span>
                <span class="cov1" title="1">return false, "", err</span>
        }

        // Extract version from response
        <span class="cov4" title="3">version := ""
        if output.Parameter != nil &amp;&amp; output.Parameter.Version != 0 </span><span class="cov4" title="3">{
                version = fmt.Sprintf("%d", output.Parameter.Version)
        }</span>

        <span class="cov4" title="3">return true, version, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package bootstrap

import (
        "context"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/ssm"
)

// ssmStatusAPI defines the SSM operations used by StatusChecker.
// This interface enables testing with mock implementations.
// Note: This is separate from ssmAPI in planner.go as they have different method needs.
type ssmStatusAPI interface {
        GetParametersByPath(ctx context.Context, params *ssm.GetParametersByPathInput, optFns ...func(*ssm.Options)) (*ssm.GetParametersByPathOutput, error)
}

// ParameterInfo holds status information about a single SSM parameter.
type ParameterInfo struct {
        // Name is the parameter name (extracted from path, e.g., "production").
        Name string `json:"name"`

        // Path is the full SSM path (e.g., "/sentinel/policies/production").
        Path string `json:"path"`

        // Version is the SSM version number.
        Version int64 `json:"version"`

        // LastModified is when the parameter was last modified.
        LastModified time.Time `json:"last_modified"`

        // Type is the parameter type (String or SecureString).
        Type string `json:"type"`
}

// StatusResult contains the results of a status query.
type StatusResult struct {
        // PolicyRoot is the root path that was queried.
        PolicyRoot string `json:"policy_root"`

        // Parameters contains information about found parameters.
        Parameters []ParameterInfo `json:"parameters"`

        // Count is the total number of parameters found.
        Count int `json:"count"`
}

// StatusChecker queries SSM for existing policy parameters.
type StatusChecker struct {
        ssm ssmStatusAPI
}

// NewStatusChecker creates a new StatusChecker using the provided AWS configuration.
func NewStatusChecker(cfg aws.Config) *StatusChecker <span class="cov0" title="0">{
        return &amp;StatusChecker{
                ssm: ssm.NewFromConfig(cfg),
        }
}</span>

// newStatusCheckerWithClient creates a StatusChecker with a custom SSM client.
// This is primarily used for testing with mock clients.
func newStatusCheckerWithClient(client ssmStatusAPI) *StatusChecker <span class="cov7" title="7">{
        return &amp;StatusChecker{
                ssm: client,
        }
}</span>

// GetStatus queries SSM for parameters under the given policy root.
// It returns a StatusResult with information about all found parameters.
func (s *StatusChecker) GetStatus(ctx context.Context, policyRoot string) (*StatusResult, error) <span class="cov7" title="7">{
        result := &amp;StatusResult{
                PolicyRoot: policyRoot,
                Parameters: []ParameterInfo{},
        }

        var nextToken *string

        for </span><span class="cov8" title="9">{
                input := &amp;ssm.GetParametersByPathInput{
                        Path:      aws.String(policyRoot),
                        Recursive: aws.Bool(false),
                        NextToken: nextToken,
                }

                output, err := s.ssm.GetParametersByPath(ctx, input)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>

                // Process parameters from this page
                <span class="cov8" title="8">for _, param := range output.Parameters </span><span class="cov8" title="9">{
                        path := aws.ToString(param.Name)
                        name := extractProfileName(policyRoot, path)

                        info := ParameterInfo{
                                Name:         name,
                                Path:         path,
                                Version:      param.Version,
                                Type:         string(param.Type),
                                LastModified: aws.ToTime(param.LastModifiedDate),
                        }
                        result.Parameters = append(result.Parameters, info)
                }</span>

                // Check for more pages
                <span class="cov8" title="8">if output.NextToken == nil </span><span class="cov7" title="6">{
                        break</span>
                }
                <span class="cov3" title="2">nextToken = output.NextToken</span>
        }

        <span class="cov7" title="6">result.Count = len(result.Parameters)
        return result, nil</span>
}

// extractProfileName extracts the profile name from a full parameter path.
// For example, "/sentinel/policies/production" -&gt; "production".
func extractProfileName(policyRoot, paramPath string) string <span class="cov10" title="13">{
        // Remove trailing slash from policyRoot if present
        policyRoot = strings.TrimSuffix(policyRoot, "/")

        // Remove the policy root prefix and leading slash
        name := strings.TrimPrefix(paramPath, policyRoot)
        name = strings.TrimPrefix(name, "/")

        return name
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package bootstrap provides configuration and state management for Sentinel AWS setup automation.
// It defines types for specifying which SSM parameters to create and tracking what resources exist.
package bootstrap

import "time"

const (
        // DefaultPolicyRoot is the default SSM parameter path prefix for policies.
        DefaultPolicyRoot = "/sentinel/policies"

        // PolicyVersion is the current policy schema version.
        PolicyVersion = "1"

        // MaxProfileNameLength is the maximum length for AWS profile names.
        MaxProfileNameLength = 64

        // MaxPolicyRootLength is the maximum length for SSM parameter paths.
        MaxPolicyRootLength = 512
)

// ResourceType identifies the kind of AWS resource being managed.
type ResourceType string

const (
        // ResourceTypeSSMParameter represents a policy parameter in SSM.
        ResourceTypeSSMParameter ResourceType = "ssm_parameter"
        // ResourceTypeIAMPolicy represents a generated IAM policy document.
        ResourceTypeIAMPolicy ResourceType = "iam_policy"
)

// IsValid returns true if the ResourceType is a known value.
func (t ResourceType) IsValid() bool <span class="cov9" title="16">{
        switch t </span>{
        case ResourceTypeSSMParameter, ResourceTypeIAMPolicy:<span class="cov8" title="10">
                return true</span>
        }
        <span class="cov6" title="6">return false</span>
}

// String returns the string representation of the ResourceType.
func (t ResourceType) String() string <span class="cov6" title="5">{
        return string(t)
}</span>

// ResourceState represents the planned action for a resource.
type ResourceState string

const (
        // StateExists indicates the resource already exists in AWS.
        StateExists ResourceState = "exists"
        // StateCreate indicates the resource needs to be created.
        StateCreate ResourceState = "create"
        // StateUpdate indicates the resource exists but needs updating.
        StateUpdate ResourceState = "update"
        // StateSkip indicates no action is needed for this resource.
        StateSkip ResourceState = "skip"
)

// IsValid returns true if the ResourceState is a known value.
func (s ResourceState) IsValid() bool <span class="cov9" title="13">{
        switch s </span>{
        case StateExists, StateCreate, StateUpdate, StateSkip:<span class="cov7" title="8">
                return true</span>
        }
        <span class="cov6" title="5">return false</span>
}

// String returns the string representation of the ResourceState.
func (s ResourceState) String() string <span class="cov6" title="6">{
        return string(s)
}</span>

// BootstrapConfig is the top-level bootstrap specification.
// It defines which profiles to bootstrap and where to store policies.
type BootstrapConfig struct {
        // PolicyRoot is the SSM parameter path prefix (e.g., "/sentinel/policies").
        PolicyRoot string `yaml:"policy_root" json:"policy_root"`

        // Profiles lists the profiles to bootstrap.
        Profiles []ProfileConfig `yaml:"profiles" json:"profiles"`

        // GenerateIAMPolicies controls whether to generate IAM policy documents.
        GenerateIAMPolicies bool `yaml:"generate_iam_policies,omitempty" json:"generate_iam_policies,omitempty"`

        // Region is the AWS region (optional - uses default if empty).
        Region string `yaml:"region,omitempty" json:"region,omitempty"`
}

// ProfileConfig defines per-profile bootstrap configuration.
type ProfileConfig struct {
        // Name is the AWS profile name.
        Name string `yaml:"name" json:"name"`

        // Description is the profile description for policy comments.
        Description string `yaml:"description,omitempty" json:"description,omitempty"`

        // PolicyParameterName is the full SSM parameter name (auto-generated if empty).
        PolicyParameterName string `yaml:"policy_parameter_name,omitempty" json:"policy_parameter_name,omitempty"`

        // InitialPolicy is the initial policy YAML content (optional).
        InitialPolicy string `yaml:"initial_policy,omitempty" json:"initial_policy,omitempty"`
}

// ResourceSpec describes a planned resource operation.
type ResourceSpec struct {
        // Type identifies the kind of resource.
        Type ResourceType `yaml:"type" json:"type"`

        // Name is the resource identifier (SSM param name or IAM policy name).
        Name string `yaml:"name" json:"name"`

        // State is the planned action for this resource.
        State ResourceState `yaml:"state" json:"state"`

        // CurrentVersion is the existing version if any.
        CurrentVersion string `yaml:"current_version,omitempty" json:"current_version,omitempty"`

        // Description is a human-readable description.
        Description string `yaml:"description,omitempty" json:"description,omitempty"`
}

// BootstrapPlan represents the full bootstrap plan output.
type BootstrapPlan struct {
        // Config is the input configuration.
        Config BootstrapConfig `yaml:"config" json:"config"`

        // Resources lists the planned operations.
        Resources []ResourceSpec `yaml:"resources" json:"resources"`

        // Summary contains operation counts by state.
        Summary PlanSummary `yaml:"summary" json:"summary"`

        // GeneratedAt is when the plan was generated.
        GeneratedAt time.Time `yaml:"generated_at" json:"generated_at"`
}

// PlanSummary contains operation counts.
type PlanSummary struct {
        // ToCreate is the number of resources to create.
        ToCreate int `yaml:"to_create" json:"to_create"`

        // ToUpdate is the number of resources to update.
        ToUpdate int `yaml:"to_update" json:"to_update"`

        // ToSkip is the number of resources to skip.
        ToSkip int `yaml:"to_skip" json:"to_skip"`

        // Total is the total number of resources in the plan.
        Total int `yaml:"total" json:"total"`
}

// DefaultPolicyParameterName returns the default SSM parameter name for a profile.
// Format: "{policyRoot}/{profile}"
func DefaultPolicyParameterName(policyRoot, profile string) string <span class="cov10" title="17">{
        return policyRoot + "/" + profile
}</span>

// IAMPolicyName returns the IAM policy name in Sentinel format.
// Format: "Sentinel{Prefix}{Suffix}"
func IAMPolicyName(prefix, suffix string) string <span class="cov7" title="7">{
        return "Sentinel" + prefix + suffix
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package bootstrap

import (
        "fmt"
        "regexp"
        "strings"

        "gopkg.in/yaml.v3"
)

// validSSMPathRegex matches valid SSM parameter path characters.
// SSM paths can contain alphanumeric characters, forward slashes, hyphens, and underscores.
var validSSMPathRegex = regexp.MustCompile(`^/[a-zA-Z0-9/_-]+$`)

// validProfileNameRegex matches valid AWS profile names.
// Profile names can contain alphanumeric characters, hyphens, and underscores.
var validProfileNameRegex = regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)

// isValidSSMPath validates an SSM parameter path format.
func isValidSSMPath(path string) bool <span class="cov9" title="29">{
        if path == "" </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov9" title="28">if !strings.HasPrefix(path, "/") </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov8" title="27">if len(path) &gt; MaxPolicyRootLength </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="27">return validSSMPathRegex.MatchString(path)</span>
}

// isValidProfileName validates an AWS profile name format.
func isValidProfileName(name string) bool <span class="cov10" title="41">{
        if name == "" </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov9" title="40">if len(name) &gt; MaxProfileNameLength </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov9" title="40">return validProfileNameRegex.MatchString(name)</span>
}

// Validate checks if the BootstrapConfig is semantically correct.
// It verifies all required fields are present and valid.
func (c *BootstrapConfig) Validate() error <span class="cov8" title="26">{
        // Validate PolicyRoot
        if c.PolicyRoot == "" </span><span class="cov3" title="3">{
                return fmt.Errorf("policy_root cannot be empty")
        }</span>
        <span class="cov8" title="23">if !strings.HasPrefix(c.PolicyRoot, "/") </span><span class="cov1" title="1">{
                return fmt.Errorf("policy_root must start with '/'")
        }</span>
        <span class="cov8" title="22">if len(c.PolicyRoot) &gt; MaxPolicyRootLength </span><span class="cov1" title="1">{
                return fmt.Errorf("policy_root exceeds maximum length of %d characters", MaxPolicyRootLength)
        }</span>
        <span class="cov8" title="21">if !isValidSSMPath(c.PolicyRoot) </span><span class="cov2" title="2">{
                return fmt.Errorf("policy_root contains invalid characters: only alphanumeric, '/', '-', '_' allowed")
        }</span>

        // Validate profiles
        <span class="cov8" title="19">if len(c.Profiles) == 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("at least one profile is required")
        }</span>

        <span class="cov7" title="17">for i, profile := range c.Profiles </span><span class="cov8" title="23">{
                if err := profile.Validate(); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("profile[%d]: %w", i, err)
                }</span>
        }

        <span class="cov7" title="16">return nil</span>
}

// Validate checks if the ProfileConfig is semantically correct.
// It verifies all required fields are present and valid.
func (p *ProfileConfig) Validate() error <span class="cov9" title="36">{
        // Validate name
        if p.Name == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("name cannot be empty")
        }</span>
        <span class="cov9" title="34">if len(p.Name) &gt; MaxProfileNameLength </span><span class="cov1" title="1">{
                return fmt.Errorf("name exceeds maximum length of %d characters", MaxProfileNameLength)
        }</span>
        <span class="cov9" title="33">if !isValidProfileName(p.Name) </span><span class="cov3" title="3">{
                return fmt.Errorf("name contains invalid characters: only alphanumeric, '-', '_' allowed")
        }</span>

        // Validate InitialPolicy if provided (YAML parse check only)
        <span class="cov9" title="30">if p.InitialPolicy != "" </span><span class="cov3" title="3">{
                var parsed interface{}
                if err := yaml.Unmarshal([]byte(p.InitialPolicy), &amp;parsed); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("initial_policy is not valid YAML: %w", err)
                }</span>
        }

        <span class="cov9" title="29">return nil</span>
}

// Validate checks if the ResourceSpec is semantically correct.
// It verifies all required fields are present and valid.
func (r *ResourceSpec) Validate() error <span class="cov6" title="11">{
        if !r.Type.IsValid() </span><span class="cov3" title="3">{
                return fmt.Errorf("invalid resource type: %q", r.Type)
        }</span>
        <span class="cov6" title="8">if r.Name == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("name cannot be empty")
        }</span>
        <span class="cov5" title="6">if !r.State.IsValid() </span><span class="cov2" title="2">{
                return fmt.Errorf("invalid resource state: %q", r.State)
        }</span>
        <span class="cov4" title="4">return nil</span>
}

// Validate checks if the BootstrapPlan is semantically correct.
// It verifies the config and all resources are valid.
func (p *BootstrapPlan) Validate() error <span class="cov4" title="5">{
        if err := p.Config.Validate(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("config: %w", err)
        }</span>

        <span class="cov4" title="4">for i, resource := range p.Resources </span><span class="cov4" title="4">{
                if err := resource.Validate(); err != nil </span><span class="cov2" title="2">{
                        return fmt.Errorf("resource[%d]: %w", i, err)
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// HasChanges returns true if any resource requires create or update action.
func (p *BootstrapPlan) HasChanges() bool <span class="cov5" title="7">{
        for _, r := range p.Resources </span><span class="cov6" title="11">{
                if r.State == StateCreate || r.State == StateUpdate </span><span class="cov4" title="4">{
                        return true
                }</span>
        }
        <span class="cov3" title="3">return false</span>
}

// CountByState returns the number of resources in the given state.
func (p *BootstrapPlan) CountByState(state ResourceState) int <span class="cov5" title="6">{
        count := 0
        for _, r := range p.Resources </span><span class="cov7" title="12">{
                if r.State == state </span><span class="cov5" title="7">{
                        count++
                }</span>
        }
        <span class="cov5" title="6">return count</span>
}

// Compute populates the summary from a resource list.
func (s *PlanSummary) Compute(resources []ResourceSpec) <span class="cov7" title="12">{
        s.ToCreate = 0
        s.ToUpdate = 0
        s.ToSkip = 0
        s.Total = len(resources)

        for _, r := range resources </span><span class="cov8" title="22">{
                switch r.State </span>{
                case StateCreate:<span class="cov7" title="13">
                        s.ToCreate++</span>
                case StateUpdate:<span class="cov1" title="1">
                        s.ToUpdate++</span>
                case StateSkip, StateExists:<span class="cov6" title="8">
                        s.ToSkip++</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package breakglass

import (
        "context"
        "fmt"
        "time"
)

// RateLimitResult contains the result of a rate limit check.
// It indicates whether break-glass is allowed and provides context
// about current usage counts and escalation status.
type RateLimitResult struct {
        // Allowed indicates whether break-glass is allowed.
        Allowed bool
        // Reason explains why break-glass was blocked (empty if allowed).
        Reason string
        // RetryAfter indicates when to retry if blocked by cooldown (0 if allowed or permanent block).
        RetryAfter time.Duration
        // UserCount is the current count of events for the user in the quota window.
        UserCount int
        // ProfileCount is the current count of events for the profile in the quota window.
        ProfileCount int
        // ShouldEscalate indicates whether the escalation threshold was exceeded.
        ShouldEscalate bool
}

// CheckRateLimit checks if break-glass is allowed for the given user and profile.
// It checks cooldown, per-user quota, and per-profile quota against the policy.
// Returns RateLimitResult indicating if allowed and why if blocked.
//
// The check order is:
//  1. Find matching rule (nil policy or no matching rule = allowed)
//  2. Check cooldown (minimum time between events per user+profile)
//  3. Check per-user quota (max events per user in window)
//  4. Check per-profile quota (max events per profile in window)
//  5. Check escalation threshold (flags for notification but doesn't block)
func CheckRateLimit(ctx context.Context, store Store, policy *RateLimitPolicy, invoker, profile string, now time.Time) (*RateLimitResult, error) <span class="cov10" title="13">{
        // 1. Find matching rule - nil policy or no matching rule means no limits
        rule := FindRateLimitRule(policy, profile)
        if rule == nil </span><span class="cov3" title="2">{
                return &amp;RateLimitResult{Allowed: true}, nil
        }</span>

        <span class="cov9" title="11">result := &amp;RateLimitResult{Allowed: true}

        // 2. Check cooldown if configured
        if rule.Cooldown &gt; 0 </span><span class="cov6" title="5">{
                lastEvent, err := store.GetLastByInvokerAndProfile(ctx, invoker, profile)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to get last event for cooldown check: %w", err)
                }</span>
                <span class="cov5" title="4">if lastEvent != nil </span><span class="cov4" title="3">{
                        elapsed := now.Sub(lastEvent.CreatedAt)
                        if elapsed &lt; rule.Cooldown </span><span class="cov1" title="1">{
                                remaining := rule.Cooldown - elapsed
                                return &amp;RateLimitResult{
                                        Allowed:    false,
                                        Reason:     "cooldown period not elapsed",
                                        RetryAfter: remaining,
                                }, nil
                        }</span>
                }
        }

        // 3. Check per-user quota if configured
        <span class="cov8" title="9">if rule.MaxPerUser &gt; 0 </span><span class="cov7" title="7">{
                since := now.Add(-rule.QuotaWindow)
                count, err := store.CountByInvokerSince(ctx, invoker, since)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to count user events for quota check: %w", err)
                }</span>
                <span class="cov7" title="6">result.UserCount = count
                if count &gt;= rule.MaxPerUser </span><span class="cov3" title="2">{
                        return &amp;RateLimitResult{
                                Allowed:   false,
                                Reason:    "user quota exceeded",
                                UserCount: count,
                        }, nil
                }</span>
        }

        // 4. Check per-profile quota if configured
        <span class="cov7" title="6">if rule.MaxPerProfile &gt; 0 </span><span class="cov4" title="3">{
                since := now.Add(-rule.QuotaWindow)
                count, err := store.CountByProfileSince(ctx, profile, since)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to count profile events for quota check: %w", err)
                }</span>
                <span class="cov3" title="2">result.ProfileCount = count
                if count &gt;= rule.MaxPerProfile </span><span class="cov1" title="1">{
                        return &amp;RateLimitResult{
                                Allowed:      false,
                                Reason:       "profile quota exceeded",
                                ProfileCount: count,
                        }, nil
                }</span>
        }

        // 5. Check escalation threshold (doesn't block, just flags for notification)
        <span class="cov5" title="4">if rule.EscalationThreshold &gt; 0 &amp;&amp; result.UserCount &gt;= rule.EscalationThreshold </span><span class="cov1" title="1">{
                result.ShouldEscalate = true
        }</span>

        <span class="cov5" title="4">return result, nil</span>
}

// FindActiveBreakGlass searches for a valid active break-glass event for a specific invoker and profile.
// It queries the store for all events by the invoker, then filters for:
//   - Status == StatusActive
//   - Profile matches the requested profile
//   - ExpiresAt &gt; now (not expired)
//
// Returns the first matching event if found, or nil if no valid active event exists.
// Returns error only for store errors, not for "no active event found".
func FindActiveBreakGlass(ctx context.Context, store Store, invoker string, profile string) (*BreakGlassEvent, error) <span class="cov8" title="8">{
        events, err := store.ListByInvoker(ctx, invoker, MaxQueryLimit)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="7">for _, event := range events </span><span class="cov8" title="8">{
                if event.Status == StatusActive &amp;&amp; event.Profile == profile &amp;&amp; isBreakGlassValid(event) </span><span class="cov3" title="2">{
                        return event, nil
                }</span>
        }

        <span class="cov6" title="5">return nil, nil</span>
}

// RemainingDuration returns the time remaining until the break-glass event expires.
// Returns 0 if the event is already expired or has zero ExpiresAt.
func RemainingDuration(event *BreakGlassEvent) time.Duration <span class="cov5" title="4">{
        if event.ExpiresAt.IsZero() </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov4" title="3">remaining := time.Until(event.ExpiresAt)
        if remaining &lt; 0 </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov3" title="2">return remaining</span>
}

// isBreakGlassValid checks if a break-glass event is still valid for credential issuance.
// An event is valid if:
//   - Status is active (not closed or expired)
//   - ExpiresAt &gt; now (event hasn't expired)
func isBreakGlassValid(event *BreakGlassEvent) bool <span class="cov7" title="7">{
        // Check status is active
        if event.Status != StatusActive </span><span class="cov3" title="2">{
                return false
        }</span>

        // Check event hasn't expired
        <span class="cov6" title="5">if time.Now().After(event.ExpiresAt) </span><span class="cov3" title="2">{
                return false
        }</span>

        <span class="cov4" title="3">return true</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package breakglass

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// GSI name constants for DynamoDB Global Secondary Indexes.
// These indexes are created externally via Terraform/CloudFormation.
const (
        // GSIInvoker indexes events by invoker with created_at sort key.
        GSIInvoker = "gsi-invoker"
        // GSIStatus indexes events by status with created_at sort key.
        GSIStatus = "gsi-status"
        // GSIProfile indexes events by profile with created_at sort key.
        GSIProfile = "gsi-profile"
)

// dynamoDBAPI defines the DynamoDB operations used by DynamoDBStore.
// This interface enables testing with mock implementations.
type dynamoDBAPI interface {
        PutItem(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error)
        GetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)
        DeleteItem(ctx context.Context, params *dynamodb.DeleteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error)
        Query(ctx context.Context, params *dynamodb.QueryInput, optFns ...func(*dynamodb.Options)) (*dynamodb.QueryOutput, error)
}

// DynamoDBStore implements Store using AWS DynamoDB.
// It provides CRUD operations for break-glass events with optimistic locking.
//
// Table schema assumptions (created externally via Terraform/CloudFormation):
//   - Partition key: id (String)
//   - TTL attribute: ttl (Number, Unix timestamp)
//   - GSI: gsi-invoker (invoker, created_at)
//   - GSI: gsi-status (status, created_at)
//   - GSI: gsi-profile (profile, created_at)
//   - All BreakGlassEvent fields stored as attributes
type DynamoDBStore struct {
        client    dynamoDBAPI
        tableName string
}

// NewDynamoDBStore creates a new DynamoDBStore using the provided AWS configuration.
// The tableName specifies the DynamoDB table for storing break-glass events.
func NewDynamoDBStore(cfg aws.Config, tableName string) *DynamoDBStore <span class="cov0" title="0">{
        return &amp;DynamoDBStore{
                client:    dynamodb.NewFromConfig(cfg),
                tableName: tableName,
        }
}</span>

// newDynamoDBStoreWithClient creates a DynamoDBStore with a custom client.
// This is primarily used for testing with mock clients.
func newDynamoDBStoreWithClient(client dynamoDBAPI, tableName string) *DynamoDBStore <span class="cov10" title="34">{
        return &amp;DynamoDBStore{
                client:    client,
                tableName: tableName,
        }
}</span>

// dynamoItem represents the DynamoDB item structure for a BreakGlassEvent.
// It uses explicit field mapping for proper serialization of Go types.
type dynamoItem struct {
        ID            string `dynamodbav:"id"`
        Invoker       string `dynamodbav:"invoker"`
        Profile       string `dynamodbav:"profile"`
        ReasonCode    string `dynamodbav:"reason_code"`
        Justification string `dynamodbav:"justification"`
        Duration      int64  `dynamodbav:"duration"`     // nanoseconds
        Status        string `dynamodbav:"status"`       // BreakGlassStatus as string
        CreatedAt     string `dynamodbav:"created_at"`   // RFC3339Nano
        UpdatedAt     string `dynamodbav:"updated_at"`   // RFC3339Nano
        ExpiresAt     string `dynamodbav:"expires_at"`   // RFC3339Nano
        TTL           int64  `dynamodbav:"ttl"`          // Unix timestamp for DynamoDB TTL
        ClosedBy      string `dynamodbav:"closed_by"`    // may be empty
        ClosedReason  string `dynamodbav:"closed_reason"` // may be empty
        RequestID     string `dynamodbav:"request_id"`   // may be empty
}

// eventToItem converts a BreakGlassEvent to a DynamoDB item structure.
func eventToItem(event *BreakGlassEvent) *dynamoItem <span class="cov8" title="17">{
        return &amp;dynamoItem{
                ID:            event.ID,
                Invoker:       event.Invoker,
                Profile:       event.Profile,
                ReasonCode:    string(event.ReasonCode),
                Justification: event.Justification,
                Duration:      int64(event.Duration),
                Status:        string(event.Status),
                CreatedAt:     event.CreatedAt.Format(time.RFC3339Nano),
                UpdatedAt:     event.UpdatedAt.Format(time.RFC3339Nano),
                ExpiresAt:     event.ExpiresAt.Format(time.RFC3339Nano),
                TTL:           event.ExpiresAt.Unix(),
                ClosedBy:      event.ClosedBy,
                ClosedReason:  event.ClosedReason,
                RequestID:     event.RequestID,
        }
}</span>

// itemToEvent converts a DynamoDB item structure back to a BreakGlassEvent.
func itemToEvent(item *dynamoItem) (*BreakGlassEvent, error) <span class="cov6" title="9">{
        createdAt, err := time.Parse(time.RFC3339Nano, item.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse created_at: %w", err)
        }</span>
        <span class="cov6" title="9">updatedAt, err := time.Parse(time.RFC3339Nano, item.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse updated_at: %w", err)
        }</span>
        <span class="cov6" title="9">expiresAt, err := time.Parse(time.RFC3339Nano, item.ExpiresAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse expires_at: %w", err)
        }</span>

        <span class="cov6" title="9">return &amp;BreakGlassEvent{
                ID:            item.ID,
                Invoker:       item.Invoker,
                Profile:       item.Profile,
                ReasonCode:    ReasonCode(item.ReasonCode),
                Justification: item.Justification,
                Duration:      time.Duration(item.Duration),
                Status:        BreakGlassStatus(item.Status),
                CreatedAt:     createdAt,
                UpdatedAt:     updatedAt,
                ExpiresAt:     expiresAt,
                ClosedBy:      item.ClosedBy,
                ClosedReason:  item.ClosedReason,
                RequestID:     item.RequestID,
        }, nil</span>
}

// Create stores a new break-glass event. Returns ErrEventExists if ID already exists.
func (s *DynamoDBStore) Create(ctx context.Context, event *BreakGlassEvent) error <span class="cov3" title="3">{
        item := eventToItem(event)
        av, err := attributevalue.MarshalMap(item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal event: %w", err)
        }</span>

        <span class="cov3" title="3">_, err = s.client.PutItem(ctx, &amp;dynamodb.PutItemInput{
                TableName:           aws.String(s.tableName),
                Item:                av,
                ConditionExpression: aws.String("attribute_not_exists(id)"),
        })
        if err != nil </span><span class="cov2" title="2">{
                var ccf *types.ConditionalCheckFailedException
                if errors.As(err, &amp;ccf) </span><span class="cov1" title="1">{
                        return fmt.Errorf("%s: %w", event.ID, ErrEventExists)
                }</span>
                <span class="cov1" title="1">return fmt.Errorf("dynamodb PutItem: %w", err)</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// Get retrieves a break-glass event by ID. Returns ErrEventNotFound if not exists.
func (s *DynamoDBStore) Get(ctx context.Context, id string) (*BreakGlassEvent, error) <span class="cov3" title="3">{
        output, err := s.client.GetItem(ctx, &amp;dynamodb.GetItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "id": &amp;types.AttributeValueMemberS{Value: id},
                },
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("dynamodb GetItem: %w", err)
        }</span>

        <span class="cov2" title="2">if output.Item == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("%s: %w", id, ErrEventNotFound)
        }</span>

        <span class="cov1" title="1">var item dynamoItem
        if err := attributevalue.UnmarshalMap(output.Item, &amp;item); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal event: %w", err)
        }</span>

        <span class="cov1" title="1">return itemToEvent(&amp;item)</span>
}

// Update modifies an existing event using optimistic locking.
// Returns ErrEventNotFound if event doesn't exist.
// Returns ErrConcurrentModification if event was modified since last read.
func (s *DynamoDBStore) Update(ctx context.Context, event *BreakGlassEvent) error <span class="cov3" title="3">{
        item := eventToItem(event)
        av, err := attributevalue.MarshalMap(item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal event: %w", err)
        }</span>

        // Build condition: item must exist AND updated_at must match
        // This implements optimistic locking - if someone else updated the item,
        // the condition will fail.
        <span class="cov3" title="3">_, err = s.client.PutItem(ctx, &amp;dynamodb.PutItemInput{
                TableName:           aws.String(s.tableName),
                Item:                av,
                ConditionExpression: aws.String("attribute_exists(id) AND updated_at = :old_updated_at"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":old_updated_at": &amp;types.AttributeValueMemberS{Value: event.UpdatedAt.Format(time.RFC3339Nano)},
                },
        })
        if err != nil </span><span class="cov2" title="2">{
                var ccf *types.ConditionalCheckFailedException
                if errors.As(err, &amp;ccf) </span><span class="cov2" title="2">{
                        // Could be either not found or concurrent modification
                        // Check if item exists to differentiate
                        exists, checkErr := s.exists(ctx, event.ID)
                        if checkErr != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("dynamodb PutItem condition failed, check exists: %w", checkErr)
                        }</span>
                        <span class="cov2" title="2">if !exists </span><span class="cov1" title="1">{
                                return fmt.Errorf("%s: %w", event.ID, ErrEventNotFound)
                        }</span>
                        <span class="cov1" title="1">return fmt.Errorf("%s: %w", event.ID, ErrConcurrentModification)</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("dynamodb PutItem: %w", err)</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// Delete removes a break-glass event by ID. No-op if not exists (idempotent).
func (s *DynamoDBStore) Delete(ctx context.Context, id string) error <span class="cov2" title="2">{
        _, err := s.client.DeleteItem(ctx, &amp;dynamodb.DeleteItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "id": &amp;types.AttributeValueMemberS{Value: id},
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dynamodb DeleteItem: %w", err)
        }</span>

        <span class="cov2" title="2">return nil</span>
}

// exists checks if an event with the given ID exists in the store.
func (s *DynamoDBStore) exists(ctx context.Context, id string) (bool, error) <span class="cov2" title="2">{
        output, err := s.client.GetItem(ctx, &amp;dynamodb.GetItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "id": &amp;types.AttributeValueMemberS{Value: id},
                },
                ProjectionExpression: aws.String("id"),
        })
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("dynamodb GetItem: %w", err)
        }</span>

        <span class="cov2" title="2">return output.Item != nil, nil</span>
}

// ListByInvoker returns all events from a specific user, ordered by created_at desc.
// Returns empty slice if no events found.
func (s *DynamoDBStore) ListByInvoker(ctx context.Context, invoker string, limit int) ([]*BreakGlassEvent, error) <span class="cov5" title="7">{
        return s.queryByIndex(ctx, GSIInvoker, "invoker", invoker, limit)
}</span>

// ListByStatus returns all events with a specific status, ordered by created_at desc.
// Commonly used to list active break-glass events for security review.
func (s *DynamoDBStore) ListByStatus(ctx context.Context, status BreakGlassStatus, limit int) ([]*BreakGlassEvent, error) <span class="cov2" title="2">{
        return s.queryByIndex(ctx, GSIStatus, "status", string(status), limit)
}</span>

// ListByProfile returns all events for a specific AWS profile, ordered by created_at desc.
// Useful for viewing break-glass history for a profile.
func (s *DynamoDBStore) ListByProfile(ctx context.Context, profile string, limit int) ([]*BreakGlassEvent, error) <span class="cov2" title="2">{
        return s.queryByIndex(ctx, GSIProfile, "profile", profile, limit)
}</span>

// FindActiveByInvokerAndProfile checks if the user already has active break-glass access
// for a profile. Returns the active event if found, nil if no active event exists.
// This is critical to prevent stacking of break-glass access.
func (s *DynamoDBStore) FindActiveByInvokerAndProfile(ctx context.Context, invoker, profile string) (*BreakGlassEvent, error) <span class="cov3" title="3">{
        // Query by invoker GSI with filter for profile and active status
        output, err := s.client.Query(ctx, &amp;dynamodb.QueryInput{
                TableName:              aws.String(s.tableName),
                IndexName:              aws.String(GSIInvoker),
                KeyConditionExpression: aws.String("invoker = :invoker"),
                FilterExpression:       aws.String("profile = :profile AND #status = :status"),
                ExpressionAttributeNames: map[string]string{
                        "#status": "status", // status is a reserved word
                },
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":invoker": &amp;types.AttributeValueMemberS{Value: invoker},
                        ":profile": &amp;types.AttributeValueMemberS{Value: profile},
                        ":status":  &amp;types.AttributeValueMemberS{Value: string(StatusActive)},
                },
                ScanIndexForward: aws.Bool(false), // Newest first
                Limit:            aws.Int32(1),    // We only need one
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("dynamodb Query: %w", err)
        }</span>

        <span class="cov2" title="2">if len(output.Items) == 0 </span><span class="cov1" title="1">{
                return nil, nil // No active event found
        }</span>

        <span class="cov1" title="1">var item dynamoItem
        if err := attributevalue.UnmarshalMap(output.Items[0], &amp;item); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal event: %w", err)
        }</span>

        <span class="cov1" title="1">return itemToEvent(&amp;item)</span>
}

// queryByIndex executes a query against a GSI with the given partition key.
// Results are ordered by created_at descending (newest first).
func (s *DynamoDBStore) queryByIndex(ctx context.Context, indexName, keyAttr, keyValue string, limit int) ([]*BreakGlassEvent, error) <span class="cov7" title="11">{
        // Apply limit defaults and cap
        effectiveLimit := limit
        if effectiveLimit &lt;= 0 </span><span class="cov2" title="2">{
                effectiveLimit = DefaultQueryLimit
        }</span>
        <span class="cov7" title="11">if effectiveLimit &gt; MaxQueryLimit </span><span class="cov1" title="1">{
                effectiveLimit = MaxQueryLimit
        }</span>

        // Use expression attribute names for reserved words
        <span class="cov7" title="11">keyCondition := fmt.Sprintf("#pk = :v")
        exprAttrNames := map[string]string{
                "#pk": keyAttr,
        }

        output, err := s.client.Query(ctx, &amp;dynamodb.QueryInput{
                TableName:                 aws.String(s.tableName),
                IndexName:                 aws.String(indexName),
                KeyConditionExpression:    aws.String(keyCondition),
                ExpressionAttributeNames:  exprAttrNames,
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":v": &amp;types.AttributeValueMemberS{Value: keyValue},
                },
                ScanIndexForward: aws.Bool(false), // Descending order (newest first)
                Limit:            aws.Int32(int32(effectiveLimit)),
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("dynamodb Query %s: %w", indexName, err)
        }</span>

        // Convert items to events
        <span class="cov6" title="10">events := make([]*BreakGlassEvent, 0, len(output.Items))
        for _, av := range output.Items </span><span class="cov4" title="4">{
                var item dynamoItem
                if err := attributevalue.UnmarshalMap(av, &amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unmarshal event: %w", err)
                }</span>
                <span class="cov4" title="4">event, err := itemToEvent(&amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov4" title="4">events = append(events, event)</span>
        }

        <span class="cov6" title="10">return events, nil</span>
}

// CountByInvokerSince counts events from a specific user since the given time.
// Uses Select: COUNT for efficiency, minimizing data transfer.
func (s *DynamoDBStore) CountByInvokerSince(ctx context.Context, invoker string, since time.Time) (int, error) <span class="cov3" title="3">{
        return s.countByIndexSince(ctx, GSIInvoker, "invoker", invoker, since)
}</span>

// CountByProfileSince counts events for a specific profile since the given time.
// Uses Select: COUNT for efficiency, minimizing data transfer.
func (s *DynamoDBStore) CountByProfileSince(ctx context.Context, profile string, since time.Time) (int, error) <span class="cov3" title="3">{
        return s.countByIndexSince(ctx, GSIProfile, "profile", profile, since)
}</span>

// GetLastByInvokerAndProfile returns the most recent event for a user+profile combination.
// Returns nil, nil if no events found. Used for cooldown checking.
func (s *DynamoDBStore) GetLastByInvokerAndProfile(ctx context.Context, invoker, profile string) (*BreakGlassEvent, error) <span class="cov3" title="3">{
        output, err := s.client.Query(ctx, &amp;dynamodb.QueryInput{
                TableName:              aws.String(s.tableName),
                IndexName:              aws.String(GSIInvoker),
                KeyConditionExpression: aws.String("invoker = :invoker"),
                FilterExpression:       aws.String("profile = :profile"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":invoker": &amp;types.AttributeValueMemberS{Value: invoker},
                        ":profile": &amp;types.AttributeValueMemberS{Value: profile},
                },
                ScanIndexForward: aws.Bool(false), // Newest first
                Limit:            aws.Int32(1),    // Only need the most recent
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("dynamodb Query: %w", err)
        }</span>

        <span class="cov2" title="2">if len(output.Items) == 0 </span><span class="cov1" title="1">{
                return nil, nil // No events found
        }</span>

        <span class="cov1" title="1">var item dynamoItem
        if err := attributevalue.UnmarshalMap(output.Items[0], &amp;item); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal event: %w", err)
        }</span>

        <span class="cov1" title="1">return itemToEvent(&amp;item)</span>
}

// countByIndexSince counts events matching the given index key since a specific time.
// Uses Select: COUNT for efficiency - only returns count, not full items.
func (s *DynamoDBStore) countByIndexSince(ctx context.Context, indexName, keyAttr, keyValue string, since time.Time) (int, error) <span class="cov5" title="6">{
        // Format time as RFC3339Nano for string comparison in DynamoDB
        sinceStr := since.Format(time.RFC3339Nano)

        output, err := s.client.Query(ctx, &amp;dynamodb.QueryInput{
                TableName:              aws.String(s.tableName),
                IndexName:              aws.String(indexName),
                KeyConditionExpression: aws.String("#pk = :v"),
                FilterExpression:       aws.String("created_at &gt;= :since"),
                ExpressionAttributeNames: map[string]string{
                        "#pk": keyAttr,
                },
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":v":     &amp;types.AttributeValueMemberS{Value: keyValue},
                        ":since": &amp;types.AttributeValueMemberS{Value: sinceStr},
                },
                Select: types.SelectCount, // Only return count, not items
        })
        if err != nil </span><span class="cov2" title="2">{
                return 0, fmt.Errorf("dynamodb Query %s: %w", indexName, err)
        }</span>

        <span class="cov4" title="4">return int(output.Count), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Break-glass policy types and validation for authorization rules.
// Follows the ApprovalPolicy pattern from policy/approval.go.

package breakglass

import (
        "fmt"
        "time"

        "github.com/byteness/aws-vault/v7/policy"
)

// BreakGlassPolicy defines authorization rules for break-glass invocation.
// It contains a version identifier and a list of rules that determine
// who can invoke break-glass for which profiles.
type BreakGlassPolicy struct {
        Version string               `yaml:"version" json:"version"`
        Rules   []BreakGlassPolicyRule `yaml:"rules" json:"rules"`
}

// BreakGlassPolicyRule defines who can invoke break-glass for matching profiles.
// Rules are evaluated to authorize users and enforce restrictions.
type BreakGlassPolicyRule struct {
        // Name identifies this policy rule for logging and debugging.
        Name string `yaml:"name" json:"name"`

        // Profiles lists which AWS profiles this rule applies to.
        // If empty, the rule applies to all profiles (wildcard).
        Profiles []string `yaml:"profiles,omitempty" json:"profiles,omitempty"`

        // Users lists who is authorized to invoke break-glass for matching profiles.
        // At least one user must be specified.
        Users []string `yaml:"users" json:"users"`

        // AllowedReasonCodes restricts which reason codes can be used.
        // If empty, all reason codes are allowed.
        AllowedReasonCodes []ReasonCode `yaml:"allowed_reason_codes,omitempty" json:"allowed_reason_codes,omitempty"`

        // Time restricts when break-glass can be invoked (nil = any time).
        Time *policy.TimeWindow `yaml:"time,omitempty" json:"time,omitempty"`

        // MaxDuration caps the duration for this rule (0 = use system default).
        MaxDuration time.Duration `yaml:"max_duration,omitempty" json:"max_duration,omitempty"`
}

// Validate checks if the BreakGlassPolicy is semantically correct.
// It verifies at least one rule exists and all rules are valid.
func (p *BreakGlassPolicy) Validate() error <span class="cov8" title="17">{
        if len(p.Rules) == 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("break-glass policy must have at least one rule")
        }</span>

        <span class="cov8" title="15">for i, rule := range p.Rules </span><span class="cov8" title="16">{
                if err := rule.validate(i); err != nil </span><span class="cov7" title="9">{
                        return err
                }</span>
        }

        <span class="cov5" title="6">return nil</span>
}

// validate checks if a BreakGlassPolicyRule is semantically correct.
// It verifies name is present, at least one user exists, and all
// optional constraints are valid.
func (r *BreakGlassPolicyRule) validate(index int) error <span class="cov9" title="22">{
        if r.Name == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("break-glass policy rule at index %d missing name", index)
        }</span>

        <span class="cov9" title="20">if len(r.Users) == 0 </span><span class="cov4" title="3">{
                return fmt.Errorf("break-glass policy rule '%s' must have at least one user", r.Name)
        }</span>

        // Validate reason codes if specified
        <span class="cov8" title="17">for _, rc := range r.AllowedReasonCodes </span><span class="cov7" title="9">{
                if !rc.IsValid() </span><span class="cov2" title="2">{
                        return fmt.Errorf("break-glass policy rule '%s' has invalid reason code '%s'", r.Name, rc)
                }</span>
        }

        // Validate time window if specified
        <span class="cov8" title="15">if r.Time != nil </span><span class="cov4" title="4">{
                if err := validateTimeWindow(r.Time, r.Name); err != nil </span><span class="cov4" title="3">{
                        return err
                }</span>
        }

        // Validate MaxDuration
        <span class="cov7" title="12">if r.MaxDuration &lt; 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("break-glass policy rule '%s' has negative max_duration", r.Name)
        }</span>

        <span class="cov7" title="10">if r.MaxDuration &gt; MaxDuration </span><span class="cov2" title="2">{
                return fmt.Errorf("break-glass policy rule '%s' max_duration exceeds maximum of %v", r.Name, MaxDuration)
        }</span>

        <span class="cov6" title="8">return nil</span>
}

// validateTimeWindow validates a TimeWindow for a rule.
// Replicates policy.TimeWindow.validate logic since it's not exported.
func validateTimeWindow(tw *policy.TimeWindow, ruleName string) error <span class="cov7" title="9">{
        for _, day := range tw.Days </span><span class="cov6" title="8">{
                if !day.IsValid() </span><span class="cov2" title="2">{
                        return fmt.Errorf("invalid weekday '%s' in rule '%s'", day, ruleName)
                }</span>
        }

        <span class="cov6" title="7">if tw.Timezone != "" </span><span class="cov4" title="4">{
                if _, err := time.LoadLocation(tw.Timezone); err != nil </span><span class="cov2" title="2">{
                        return fmt.Errorf("invalid timezone '%s' in rule '%s'", tw.Timezone, ruleName)
                }</span>
        }

        <span class="cov5" title="5">if tw.Hours != nil </span><span class="cov4" title="4">{
                if err := tw.Hours.Validate(); err != nil </span><span class="cov2" title="2">{
                        return fmt.Errorf("in rule '%s': %w", ruleName, err)
                }</span>
        }

        <span class="cov4" title="3">return nil</span>
}

// FindBreakGlassPolicyRule returns the first rule matching the given profile.
// An empty Profiles list in a rule acts as a wildcard and matches any profile.
// Returns nil if no rule matches or if policy is nil.
func FindBreakGlassPolicyRule(p *BreakGlassPolicy, profile string) *BreakGlassPolicyRule <span class="cov6" title="8">{
        if p == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov6" title="7">for i := range p.Rules </span><span class="cov6" title="8">{
                rule := &amp;p.Rules[i]
                if containsOrEmpty(rule.Profiles, profile) </span><span class="cov5" title="6">{
                        return rule
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// CanInvokeBreakGlass returns true if the given user is authorized to invoke
// break-glass for the profile matched by this rule.
// Returns false if rule is nil or user is not in the Users list.
func CanInvokeBreakGlass(rule *BreakGlassPolicyRule, user string) bool <span class="cov9" title="24">{
        if rule == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov9" title="23">for _, u := range rule.Users </span><span class="cov10" title="26">{
                if u == user </span><span class="cov9" title="19">{
                        return true
                }</span>
        }
        <span class="cov4" title="4">return false</span>
}

// IsBreakGlassAllowed performs a comprehensive authorization check.
// It verifies:
//   - User is in rule.Users (via CanInvokeBreakGlass)
//   - ReasonCode is in AllowedReasonCodes (empty = all allowed)
//   - requestTime falls within Time window (nil = any time)
//   - duration is &lt;= MaxDuration (0 = no cap)
//
// Returns false if rule is nil.
func IsBreakGlassAllowed(rule *BreakGlassPolicyRule, user string, reasonCode ReasonCode, requestTime time.Time, duration time.Duration) bool <span class="cov8" title="18">{
        if rule == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check user authorization
        <span class="cov8" title="17">if !CanInvokeBreakGlass(rule, user) </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check reason code (empty = all allowed)
        <span class="cov8" title="16">if len(rule.AllowedReasonCodes) &gt; 0 </span><span class="cov4" title="4">{
                found := false
                for _, rc := range rule.AllowedReasonCodes </span><span class="cov5" title="6">{
                        if rc == reasonCode </span><span class="cov4" title="3">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov4" title="4">if !found </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check time window (nil = any time)
        <span class="cov8" title="15">if rule.Time != nil </span><span class="cov5" title="6">{
                if !matchesTimeWindow(rule.Time, requestTime) </span><span class="cov2" title="2">{
                        return false
                }</span>
        }

        // Check duration cap (0 = no cap)
        <span class="cov8" title="13">if rule.MaxDuration &gt; 0 &amp;&amp; duration &gt; rule.MaxDuration </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov7" title="12">return true</span>
}

// matchesTimeWindow checks if the request time falls within the time window.
// Replicates policy.matchesTimeWindow logic since it's not exported.
func matchesTimeWindow(tw *policy.TimeWindow, t time.Time) bool <span class="cov8" title="14">{
        if tw == nil </span><span class="cov1" title="1">{
                return true
        }</span>

        // Convert time to the rule's timezone if specified
        <span class="cov8" title="13">evalTime := t
        if tw.Timezone != "" </span><span class="cov7" title="11">{
                loc, err := time.LoadLocation(tw.Timezone)
                if err == nil </span><span class="cov7" title="11">{
                        evalTime = t.In(loc)
                }</span>
        }

        // Check day of week constraint
        <span class="cov8" title="13">if !matchesDays(tw.Days, evalTime) </span><span class="cov2" title="2">{
                return false
        }</span>

        // Check hour range constraint
        <span class="cov7" title="11">if !matchesHours(tw.Hours, evalTime) </span><span class="cov4" title="3">{
                return false
        }</span>

        <span class="cov6" title="8">return true</span>
}

// matchesDays checks if the time falls on one of the specified days.
// An empty days list matches any day.
func matchesDays(days []policy.Weekday, t time.Time) bool <span class="cov8" title="13">{
        if len(days) == 0 </span><span class="cov5" title="5">{
                return true
        }</span>

        <span class="cov6" title="8">goDay := t.Weekday()
        requestDay := goWeekdayToWeekday(goDay)

        for _, d := range days </span><span class="cov8" title="13">{
                if d == requestDay </span><span class="cov5" title="6">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// goWeekdayToWeekday converts Go's time.Weekday to policy.Weekday.
func goWeekdayToWeekday(d time.Weekday) policy.Weekday <span class="cov6" title="8">{
        switch d </span>{
        case time.Monday:<span class="cov5" title="6">
                return policy.Monday</span>
        case time.Tuesday:<span class="cov0" title="0">
                return policy.Tuesday</span>
        case time.Wednesday:<span class="cov0" title="0">
                return policy.Wednesday</span>
        case time.Thursday:<span class="cov0" title="0">
                return policy.Thursday</span>
        case time.Friday:<span class="cov0" title="0">
                return policy.Friday</span>
        case time.Saturday:<span class="cov2" title="2">
                return policy.Saturday</span>
        case time.Sunday:<span class="cov0" title="0">
                return policy.Sunday</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// matchesHours checks if the time falls within the hour range.
// A nil hour range matches any time of day.
func matchesHours(hr *policy.HourRange, t time.Time) bool <span class="cov7" title="11">{
        if hr == nil </span><span class="cov4" title="4">{
                return true
        }</span>

        <span class="cov6" title="7">startHour, startMin := parseHourMinute(hr.Start)
        endHour, endMin := parseHourMinute(hr.End)

        reqHour := t.Hour()
        reqMin := t.Minute()

        // Convert to minutes since midnight for easier comparison
        reqMinutes := reqHour*60 + reqMin
        startMinutes := startHour*60 + startMin
        endMinutes := endHour*60 + endMin

        // Check if request time is in range [start, end)
        return reqMinutes &gt;= startMinutes &amp;&amp; reqMinutes &lt; endMinutes</span>
}

// parseHourMinute parses a HH:MM string and returns hour and minute.
func parseHourMinute(s string) (hour, minute int) <span class="cov9" title="24">{
        if len(s) != 5 || s[2] != ':' </span><span class="cov5" title="5">{
                return 0, 0
        }</span>
        <span class="cov9" title="19">hour = int(s[0]-'0')*10 + int(s[1]-'0')
        minute = int(s[3]-'0')*10 + int(s[4]-'0')
        return hour, minute</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Rate limiting types and validation for break-glass abuse prevention.
// Follows the ApprovalPolicy pattern from policy/approval.go.

package breakglass

import (
        "fmt"
        "time"
)

// RateLimitPolicy defines cooldown and quota rules for break-glass events.
// It contains a version identifier and a list of rate limit rules that
// prevent abuse while allowing legitimate emergency access.
type RateLimitPolicy struct {
        Version string          `yaml:"version" json:"version"`
        Rules   []RateLimitRule `yaml:"rules" json:"rules"`
}

// RateLimitRule defines rate limits for matching profiles.
// Rules are evaluated to enforce cooldowns, quotas, and escalation thresholds.
type RateLimitRule struct {
        // Name identifies this rate limit rule for logging and debugging.
        Name string `yaml:"name" json:"name"`

        // Profiles lists which AWS profiles this rule applies to.
        // If empty, the rule applies to all profiles (wildcard).
        Profiles []string `yaml:"profiles,omitempty" json:"profiles,omitempty"`

        // Cooldown is the minimum time between break-glass events per user+profile.
        // Zero means no cooldown requirement.
        Cooldown time.Duration `yaml:"cooldown,omitempty" json:"cooldown,omitempty"`

        // MaxPerUser is the maximum break-glass events per user within QuotaWindow.
        // Zero means no per-user quota.
        MaxPerUser int `yaml:"max_per_user,omitempty" json:"max_per_user,omitempty"`

        // MaxPerProfile is the maximum break-glass events per profile within QuotaWindow.
        // Zero means no per-profile quota.
        MaxPerProfile int `yaml:"max_per_profile,omitempty" json:"max_per_profile,omitempty"`

        // QuotaWindow is the time window for quota counting (e.g., 24h).
        // Required if MaxPerUser &gt; 0 or MaxPerProfile &gt; 0.
        QuotaWindow time.Duration `yaml:"quota_window,omitempty" json:"quota_window,omitempty"`

        // EscalationThreshold triggers escalated notification when user exceeds this count.
        // Zero means no escalation notifications.
        EscalationThreshold int `yaml:"escalation_threshold,omitempty" json:"escalation_threshold,omitempty"`
}

// Validate checks if the RateLimitPolicy is semantically correct.
// It verifies at least one rule exists and all rules are valid.
func (p *RateLimitPolicy) Validate() error <span class="cov7" title="11">{
        if len(p.Rules) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("rate limit policy must have at least one rule")
        }</span>

        <span class="cov6" title="10">for i, rule := range p.Rules </span><span class="cov6" title="10">{
                if err := rule.validate(i); err != nil </span><span class="cov6" title="7">{
                        return err
                }</span>
        }

        <span class="cov3" title="3">return nil</span>
}

// validate checks if a RateLimitRule is semantically correct.
func (r *RateLimitRule) validate(index int) error <span class="cov6" title="10">{
        if r.Name == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("rate limit rule at index %d missing name", index)
        }</span>

        <span class="cov6" title="9">if r.Cooldown &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("rate limit rule '%s' has negative cooldown", r.Name)
        }</span>

        <span class="cov6" title="8">if r.MaxPerUser &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("rate limit rule '%s' has negative max_per_user", r.Name)
        }</span>

        <span class="cov6" title="7">if r.MaxPerProfile &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("rate limit rule '%s' has negative max_per_profile", r.Name)
        }</span>

        // QuotaWindow must be &gt; 0 if any quota is set
        <span class="cov5" title="6">hasQuota := r.MaxPerUser &gt; 0 || r.MaxPerProfile &gt; 0
        if hasQuota &amp;&amp; r.QuotaWindow &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("rate limit rule '%s' has quota limits but missing or invalid quota_window", r.Name)
        }</span>

        // At least one limit must be set
        <span class="cov5" title="5">hasLimit := r.Cooldown &gt; 0 || r.MaxPerUser &gt; 0 || r.MaxPerProfile &gt; 0
        if !hasLimit </span><span class="cov1" title="1">{
                return fmt.Errorf("rate limit rule '%s' must have at least one limit (cooldown, max_per_user, or max_per_profile)", r.Name)
        }</span>

        <span class="cov4" title="4">if r.EscalationThreshold &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("rate limit rule '%s' has negative escalation_threshold", r.Name)
        }</span>

        <span class="cov3" title="3">return nil</span>
}

// FindRateLimitRule returns the first rule matching the given profile.
// An empty Profiles list in a rule acts as a wildcard and matches any profile.
// Returns nil if no rule matches or if policy is nil.
func FindRateLimitRule(policy *RateLimitPolicy, profile string) *RateLimitRule <span class="cov8" title="20">{
        if policy == nil </span><span class="cov2" title="2">{
                return nil
        }</span>
        <span class="cov8" title="18">for i := range policy.Rules </span><span class="cov8" title="19">{
                rule := &amp;policy.Rules[i]
                if containsOrEmpty(rule.Profiles, profile) </span><span class="cov8" title="16">{
                        return rule
                }</span>
        }
        <span class="cov2" title="2">return nil</span>
}

// containsOrEmpty returns true if the slice is empty (wildcard) or contains the value.
func containsOrEmpty(slice []string, value string) bool <span class="cov10" title="32">{
        if len(slice) == 0 </span><span class="cov6" title="7">{
                return true // empty slice = wildcard
        }</span>
        <span class="cov9" title="25">for _, s := range slice </span><span class="cov9" title="27">{
                if s == value </span><span class="cov8" title="18">{
                        return true
                }</span>
        }
        <span class="cov6" title="7">return false</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Package breakglass defines Sentinel's break-glass emergency access schema.
// Break-glass events represent emergency access bypasses where users invoke
// elevated privileges with mandatory justification and audit trail.
//
// # Break-Glass State Machine
//
// Valid state transitions:
//   - active -&gt; closed (by invoker or security)
//   - active -&gt; expired (by TTL)
//
// Terminal states (closed, expired) cannot transition.
// Unlike approval requests, break-glass events start active (no pending state).
//
// # Break-Glass ID Format
//
// Break-glass IDs are 16-character lowercase hexadecimal strings (64 bits of entropy),
// providing uniqueness and correlation across break-glass operations and CloudTrail.
package breakglass

import (
        "crypto/rand"
        "encoding/hex"
        "regexp"
        "time"
)

const (
        // DefaultBreakGlassTTL is how long break-glass access remains valid.
        // Shorter than approval requests - emergency access should be brief.
        DefaultBreakGlassTTL = 4 * time.Hour

        // MaxJustificationLength is the maximum length for justification text.
        // Longer than approval requests - incidents need detailed explanation.
        MaxJustificationLength = 1000

        // MinJustificationLength is the minimum length for justification text.
        // Requires meaningful explanation of the emergency.
        MinJustificationLength = 20

        // BreakGlassIDLength is the exact length for break-glass IDs (16 hex chars).
        BreakGlassIDLength = 16

        // MaxDuration is the maximum access duration for break-glass events.
        // Cap emergency access to limit exposure window.
        MaxDuration = 4 * time.Hour
)

// BreakGlassStatus represents the current state of a break-glass event.
// It can be active, closed, or expired.
type BreakGlassStatus string

const (
        // StatusActive indicates emergency access is currently in use.
        StatusActive BreakGlassStatus = "active"
        // StatusClosed indicates access was manually closed by invoker or security.
        StatusClosed BreakGlassStatus = "closed"
        // StatusExpired indicates access expired due to TTL elapsed.
        StatusExpired BreakGlassStatus = "expired"
)

// IsValid returns true if the BreakGlassStatus is a known value.
func (s BreakGlassStatus) IsValid() bool <span class="cov5" title="35">{
        switch s </span>{
        case StatusActive, StatusClosed, StatusExpired:<span class="cov5" title="28">
                return true</span>
        }
        <span class="cov3" title="7">return false</span>
}

// String returns the string representation of the BreakGlassStatus.
func (s BreakGlassStatus) String() string <span class="cov2" title="4">{
        return string(s)
}</span>

// IsTerminal returns true if the status is a terminal state that cannot transition.
func (s BreakGlassStatus) IsTerminal() bool <span class="cov4" title="15">{
        switch s </span>{
        case StatusClosed, StatusExpired:<span class="cov3" title="8">
                return true</span>
        }
        <span class="cov3" title="7">return false</span>
}

// ReasonCode represents predefined categories for break-glass justification.
// Users must select a reason code and provide detailed justification.
type ReasonCode string

const (
        // ReasonIncident indicates production incident response.
        ReasonIncident ReasonCode = "incident"
        // ReasonMaintenance indicates emergency maintenance.
        ReasonMaintenance ReasonCode = "maintenance"
        // ReasonSecurity indicates security incident response.
        ReasonSecurity ReasonCode = "security"
        // ReasonRecovery indicates disaster recovery.
        ReasonRecovery ReasonCode = "recovery"
        // ReasonOther indicates other reason (requires detailed justification).
        ReasonOther ReasonCode = "other"
)

// IsValid returns true if the ReasonCode is a known value.
func (r ReasonCode) IsValid() bool <span class="cov5" title="44">{
        switch r </span>{
        case ReasonIncident, ReasonMaintenance, ReasonSecurity, ReasonRecovery, ReasonOther:<span class="cov5" title="37">
                return true</span>
        }
        <span class="cov3" title="7">return false</span>
}

// String returns the string representation of the ReasonCode.
func (r ReasonCode) String() string <span class="cov3" title="8">{
        return string(r)
}</span>

// BreakGlassEvent represents an emergency access bypass event.
// It contains the invoker's information, why they invoked break-glass,
// and the current state of the emergency access.
type BreakGlassEvent struct {
        // ID is the unique break-glass identifier (16 lowercase hex chars).
        ID string `yaml:"id" json:"id"`

        // Invoker is the username who invoked break-glass.
        Invoker string `yaml:"invoker" json:"invoker"`

        // Profile is the AWS profile being accessed.
        Profile string `yaml:"profile" json:"profile"`

        // ReasonCode is the predefined category for the emergency.
        ReasonCode ReasonCode `yaml:"reason_code" json:"reason_code"`

        // Justification is the detailed explanation for the emergency access.
        Justification string `yaml:"justification" json:"justification"`

        // Duration is how long emergency access is requested for.
        Duration time.Duration `yaml:"duration" json:"duration"`

        // Status is the current state of the break-glass event.
        Status BreakGlassStatus `yaml:"status" json:"status"`

        // CreatedAt is when break-glass was invoked.
        CreatedAt time.Time `yaml:"created_at" json:"created_at"`

        // UpdatedAt is when the event was last modified.
        UpdatedAt time.Time `yaml:"updated_at" json:"updated_at"`

        // ExpiresAt is when emergency access expires.
        ExpiresAt time.Time `yaml:"expires_at" json:"expires_at"`

        // ClosedBy is who closed the break-glass event (empty if expired).
        ClosedBy string `yaml:"closed_by,omitempty" json:"closed_by,omitempty"`

        // ClosedReason is why it was closed early (empty if expired).
        ClosedReason string `yaml:"closed_reason,omitempty" json:"closed_reason,omitempty"`

        // RequestID is the Sentinel request ID for CloudTrail correlation.
        RequestID string `yaml:"request_id,omitempty" json:"request_id,omitempty"`
}

// breakGlassIDRegex matches valid break-glass IDs (16 lowercase hex chars).
var breakGlassIDRegex = regexp.MustCompile(`^[0-9a-f]{16}$`)

// NewBreakGlassID generates a new 16-character lowercase hex break-glass ID.
// It uses crypto/rand for cryptographic randomness.
//
// The break-glass ID provides:
//   - Uniqueness per break-glass event
//   - Correlation across break-glass operations
//   - CloudTrail audit trail linkage
//   - No PII or sensitive data (just random identifier)
func NewBreakGlassID() string <span class="cov10" title="1011">{
        // Generate 8 random bytes (64 bits of entropy)
        bytes := make([]byte, 8)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                // This should never happen with crypto/rand
                // Fall back to zeros rather than panic
                return "0000000000000000"
        }</span>

        // Encode as 16-character lowercase hex string
        <span class="cov10" title="1011">return hex.EncodeToString(bytes)</span>
}

// ValidateBreakGlassID checks if the given string is a valid break-glass ID.
// A valid break-glass ID is exactly 16 lowercase hexadecimal characters.
func ValidateBreakGlassID(id string) bool <span class="cov6" title="59">{
        return breakGlassIDRegex.MatchString(id)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package breakglass

import (
        "fmt"
)

// Validate checks if the BreakGlassEvent is semantically correct.
// It verifies all required fields are present and valid.
func (e *BreakGlassEvent) Validate() error <span class="cov10" title="34">{
        // Validate ID
        if !ValidateBreakGlassID(e.ID) </span><span class="cov5" title="6">{
                return fmt.Errorf("invalid break-glass ID: must be %d lowercase hex characters", BreakGlassIDLength)
        }</span>

        // Validate invoker
        <span class="cov9" title="28">if e.Invoker == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("invoker cannot be empty")
        }</span>

        // Validate profile
        <span class="cov9" title="27">if e.Profile == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("profile cannot be empty")
        }</span>

        // Validate reason code
        <span class="cov9" title="26">if !e.ReasonCode.IsValid() </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid reason code: %q", e.ReasonCode)
        }</span>

        // Validate justification
        <span class="cov9" title="25">if len(e.Justification) &lt; MinJustificationLength </span><span class="cov2" title="2">{
                return fmt.Errorf("justification too short: minimum %d characters", MinJustificationLength)
        }</span>
        <span class="cov9" title="23">if len(e.Justification) &gt; MaxJustificationLength </span><span class="cov2" title="2">{
                return fmt.Errorf("justification too long: maximum %d characters", MaxJustificationLength)
        }</span>

        // Validate status
        <span class="cov8" title="21">if !e.Status.IsValid() </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid status: %q", e.Status)
        }</span>

        // Validate duration
        <span class="cov8" title="20">if e.Duration &lt;= 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("duration must be positive")
        }</span>
        <span class="cov8" title="18">if e.Duration &gt; MaxDuration </span><span class="cov2" title="2">{
                return fmt.Errorf("duration exceeds maximum of %v", MaxDuration)
        }</span>

        // Validate timestamps
        <span class="cov8" title="16">if e.CreatedAt.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("created_at cannot be zero")
        }</span>
        <span class="cov7" title="15">if e.UpdatedAt.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("updated_at cannot be zero")
        }</span>
        <span class="cov7" title="14">if e.ExpiresAt.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("expires_at cannot be zero")
        }</span>

        <span class="cov7" title="13">return nil</span>
}

// CanTransitionTo checks if the break-glass event can transition to the given status.
// Only active events can transition; terminal states cannot change.
//
// Valid transitions:
//   - active -&gt; closed (by invoker or security)
//   - active -&gt; expired (by TTL)
func (e *BreakGlassEvent) CanTransitionTo(newStatus BreakGlassStatus) bool <span class="cov7" title="12">{
        // Terminal states cannot transition
        if e.Status.IsTerminal() </span><span class="cov5" title="6">{
                return false
        }</span>

        // Only active can transition
        <span class="cov5" title="6">if e.Status != StatusActive </span><span class="cov0" title="0">{
                return false
        }</span>

        // New status must be valid and terminal (transitions from active always go to terminal)
        // Cannot transition to same status (active -&gt; active is not allowed)
        <span class="cov5" title="6">return newStatus.IsValid() &amp;&amp; newStatus != StatusActive</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "os"

        "github.com/alecthomas/kingpin/v2"
        "github.com/byteness/aws-vault/v7/cli"
)

// Version is provided at compile time
var Version = "dev"

func main() <span class="cov0" title="0">{
        app := kingpin.New("sentinel", "Intent-aware access control for AWS credentials")
        app.Version(Version)

        s := cli.ConfigureSentinelGlobals(app)
        cli.ConfigureCredentialsCommand(app, s)
        cli.ConfigureSentinelExecCommand(app, s)
        cli.ConfigureRequestCommand(app, s)
        cli.ConfigureSentinelListCommand(app, s)
        cli.ConfigureCheckCommand(app, s)
        cli.ConfigureApproveCommand(app, s)
        cli.ConfigureDenyCommand(app, s)

        // Break-glass emergency access commands
        cli.ConfigureBreakGlassCommand(app, s)
        cli.ConfigureBreakGlassListCommand(app, s)
        cli.ConfigureBreakGlassCheckCommand(app, s)
        cli.ConfigureBreakGlassCloseCommand(app, s)

        // Bootstrap commands
        cli.ConfigureBootstrapCommand(app, s)
        cli.ConfigureStatusCommand(app, s)

        // Enforcement commands
        cli.ConfigureEnforcePlanCommand(app, s)
        cli.ConfigureEnforceGenerateTrustPolicyCommand(app, s)

        // Audit commands
        cli.ConfigureAuditVerifyCommand(app, s)

        kingpin.MustParse(app.Parse(os.Args[1:]))
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package enforce

import (
        "context"
        "fmt"
        "net/url"
        "strings"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/iam"
)

// iamAPI defines the IAM operations used by the Advisor.
// This interface enables testing with mock implementations.
type iamAPI interface {
        GetRole(ctx context.Context, params *iam.GetRoleInput, optFns ...func(*iam.Options)) (*iam.GetRoleOutput, error)
}

// Advisor provides trust policy analysis for IAM roles.
// It fetches trust policies from IAM and analyzes them for Sentinel enforcement.
type Advisor struct {
        client iamAPI
}

// NewAdvisor creates a new Advisor with the given AWS config.
func NewAdvisor(cfg aws.Config) *Advisor <span class="cov0" title="0">{
        return &amp;Advisor{
                client: iam.NewFromConfig(cfg),
        }
}</span>

// NewAdvisorWithClient creates a new Advisor with a custom IAM client.
// This is useful for testing with mock implementations.
func NewAdvisorWithClient(client iamAPI) *Advisor <span class="cov8" title="15">{
        return &amp;Advisor{
                client: client,
        }
}</span>

// RoleAnalysis contains the result of analyzing an IAM role's trust policy.
type RoleAnalysis struct {
        // RoleARN is the full ARN of the analyzed role.
        RoleARN string `json:"role_arn"`
        // RoleName is the name portion of the role ARN.
        RoleName string `json:"role_name"`
        // Analysis contains the enforcement analysis result.
        Analysis *AnalysisResult `json:"analysis,omitempty"`
        // Error contains any error message if analysis failed.
        Error string `json:"error,omitempty"`
}

// AnalyzeRole fetches and analyzes a single IAM role's trust policy.
// The roleARN should be a full IAM role ARN (arn:aws:iam::ACCOUNT:role/NAME).
func (a *Advisor) AnalyzeRole(ctx context.Context, roleARN string) (*RoleAnalysis, error) <span class="cov9" title="16">{
        result := &amp;RoleAnalysis{
                RoleARN: roleARN,
        }

        // Extract role name from ARN
        // ARN format: arn:aws:iam::ACCOUNT:role/PATH/NAME or arn:aws:iam::ACCOUNT:role/NAME
        roleName, err := extractRoleName(roleARN)
        if err != nil </span><span class="cov3" title="2">{
                result.Error = err.Error()
                return result, nil
        }</span>
        <span class="cov8" title="14">result.RoleName = roleName

        // Fetch role from IAM
        output, err := a.client.GetRole(ctx, &amp;iam.GetRoleInput{
                RoleName: aws.String(roleName),
        })
        if err != nil </span><span class="cov4" title="3">{
                result.Error = fmt.Sprintf("failed to get role: %v", err)
                return result, nil
        }</span>

        <span class="cov7" title="11">if output.Role == nil || output.Role.AssumeRolePolicyDocument == nil </span><span class="cov1" title="1">{
                result.Error = "role has no trust policy"
                return result, nil
        }</span>

        // IAM returns URL-encoded JSON for trust policy
        <span class="cov7" title="10">policyJSON, err := url.QueryUnescape(*output.Role.AssumeRolePolicyDocument)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Sprintf("failed to decode trust policy: %v", err)
                return result, nil
        }</span>

        // Parse trust policy
        <span class="cov7" title="10">policy, err := ParseTrustPolicy([]byte(policyJSON))
        if err != nil </span><span class="cov1" title="1">{
                result.Error = fmt.Sprintf("failed to parse trust policy: %v", err)
                return result, nil
        }</span>

        // Analyze trust policy
        <span class="cov7" title="9">result.Analysis = AnalyzeTrustPolicy(policy)

        return result, nil</span>
}

// AnalyzeRoles analyzes multiple IAM roles' trust policies.
// It processes all roles and collects results, continuing even if some fail.
// Returns results for all roles, with errors captured in each RoleAnalysis.Error.
func (a *Advisor) AnalyzeRoles(ctx context.Context, roleARNs []string) ([]*RoleAnalysis, error) <span class="cov3" title="2">{
        results := make([]*RoleAnalysis, 0, len(roleARNs))

        for _, arn := range roleARNs </span><span class="cov4" title="3">{
                result, _ := a.AnalyzeRole(ctx, arn)
                results = append(results, result)
        }</span>

        <span class="cov3" title="2">return results, nil</span>
}

// extractRoleName extracts the role name from an IAM role ARN.
// ARN formats:
//   - arn:aws:iam::123456789012:role/RoleName
//   - arn:aws:iam::123456789012:role/path/to/RoleName
func extractRoleName(arn string) (string, error) <span class="cov10" title="22">{
        if arn == "" </span><span class="cov1" title="1">{
                return "", fmt.Errorf("empty role ARN")
        }</span>

        // Check for role ARN format
        <span class="cov9" title="21">if !strings.Contains(arn, ":role/") </span><span class="cov4" title="3">{
                return "", fmt.Errorf("invalid role ARN format: must contain :role/")
        }</span>

        // Extract everything after :role/
        <span class="cov9" title="18">parts := strings.SplitN(arn, ":role/", 2)
        if len(parts) != 2 || parts[1] == "" </span><span class="cov1" title="1">{
                return "", fmt.Errorf("invalid role ARN format: missing role name")
        }</span>

        // The role name is the last segment (handles paths like role/path/to/name)
        <span class="cov9" title="17">rolePath := parts[1]
        segments := strings.Split(rolePath, "/")
        return segments[len(segments)-1], nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package enforce

// AnalyzeTrustPolicy analyzes a trust policy document to determine its
// Sentinel enforcement status. It examines all statements to determine
// if SourceIdentity conditions are properly configured.
//
// Analysis logic:
//   - Full: At least one Allow statement has sts:SourceIdentity with sentinel:* pattern
//   - Partial: Statements have SourceIdentity but not with sentinel:* pattern
//   - None: No SourceIdentity conditions found
func AnalyzeTrustPolicy(policy *TrustPolicyDocument) *AnalysisResult <span class="cov9" title="28">{
        if policy == nil </span><span class="cov2" title="2">{
                return &amp;AnalysisResult{
                        Level:                      EnforcementLevelAdvisory,
                        Status:                     EnforcementStatusNone,
                        HasSourceIdentityCondition: false,
                        Issues:                     []string{"policy document is nil"},
                        Recommendations:            []string{"Provide a valid trust policy document"},
                }
        }</span>

        <span class="cov9" title="26">result := &amp;AnalysisResult{
                Level:                      EnforcementLevelTrustPolicy,
                Status:                     EnforcementStatusNone,
                HasSourceIdentityCondition: false,
                Issues:                     []string{},
                Recommendations:            []string{},
        }

        var (
                hasAnySourceIdentity     bool
                hasSentinelWildcard      bool
                hasUserSpecificPatterns  bool
                hasStringEqualsForWild   bool
                allowStatementsCount     int
                enforcedStatementsCount  int
                legacyStatementsExist    bool
        )

        for _, stmt := range policy.Statement </span><span class="cov10" title="33">{
                if stmt.Effect != "Allow" </span><span class="cov1" title="1">{
                        // Deny statements with StringNotLike are SCP patterns
                        if stmt.Effect == "Deny" &amp;&amp; stmt.Condition.HasSourceIdentityDeny() </span><span class="cov1" title="1">{
                                result.Level = EnforcementLevelSCP
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }

                <span class="cov9" title="32">allowStatementsCount++
                patterns := GetSourceIdentityPatterns(&amp;stmt)

                if len(patterns) &gt; 0 </span><span class="cov8" title="20">{
                        hasAnySourceIdentity = true
                        result.HasSourceIdentityCondition = true

                        // Check for sentinel:* wildcard pattern
                        if HasSentinelWildcardPattern(patterns) </span><span class="cov8" title="16">{
                                hasSentinelWildcard = true
                                enforcedStatementsCount++
                        }</span> else<span class="cov4" title="4"> {
                                // Check if patterns are sentinel user-specific
                                for _, p := range patterns </span><span class="cov6" title="7">{
                                        if IsSentinelPattern(p) &amp;&amp; p != "sentinel:*" </span><span class="cov5" title="6">{
                                                hasUserSpecificPatterns = true
                                                enforcedStatementsCount++
                                        }</span>
                                }
                        }

                        // Check if StringEquals is used (won't work with dynamic request-id)
                        <span class="cov8" title="20">if stringEquals, ok := stmt.Condition["StringEquals"]; ok </span><span class="cov2" title="2">{
                                if values, ok := stringEquals["sts:SourceIdentity"]; ok </span><span class="cov2" title="2">{
                                        for _, v := range values </span><span class="cov2" title="2">{
                                                if v == "sentinel:*" || (len(v) &gt; 9 &amp;&amp; v[:9] == "sentinel:" &amp;&amp; v[len(v)-1] == '*') </span><span class="cov2" title="2">{
                                                        hasStringEqualsForWild = true
                                                }</span>
                                        }
                                }
                        }
                } else<span class="cov7" title="12"> {
                        // Allow statement without SourceIdentity condition (legacy/migration)
                        legacyStatementsExist = true
                }</span>
        }

        // Determine enforcement status
        <span class="cov9" title="26">if hasAnySourceIdentity </span><span class="cov8" title="19">{
                if hasSentinelWildcard &amp;&amp; !legacyStatementsExist </span><span class="cov6" title="9">{
                        result.Status = EnforcementStatusFull
                }</span> else<span class="cov6" title="10"> if hasUserSpecificPatterns &amp;&amp; !legacyStatementsExist </span><span class="cov3" title="3">{
                        result.Status = EnforcementStatusFull
                }</span> else<span class="cov6" title="7"> if enforcedStatementsCount &gt; 0 &amp;&amp; legacyStatementsExist </span><span class="cov5" title="6">{
                        result.Status = EnforcementStatusPartial
                }</span> else<span class="cov1" title="1"> if enforcedStatementsCount &gt; 0 </span><span class="cov0" title="0">{
                        result.Status = EnforcementStatusFull
                }</span> else<span class="cov1" title="1"> {
                        result.Status = EnforcementStatusPartial
                }</span>
        } else<span class="cov6" title="7"> {
                result.Status = EnforcementStatusNone
                result.Level = EnforcementLevelAdvisory
        }</span>

        // Generate issues
        <span class="cov9" title="26">if !hasAnySourceIdentity </span><span class="cov6" title="7">{
                result.Issues = append(result.Issues, "No sts:SourceIdentity condition found in any Allow statement")
        }</span>

        <span class="cov9" title="26">if hasAnySourceIdentity &amp;&amp; !hasSentinelWildcard &amp;&amp; !hasUserSpecificPatterns </span><span class="cov1" title="1">{
                result.Issues = append(result.Issues, "SourceIdentity condition exists but pattern does not match sentinel:*")
        }</span>

        <span class="cov9" title="26">if hasStringEqualsForWild </span><span class="cov2" title="2">{
                result.Issues = append(result.Issues, "Using StringEquals with wildcard pattern - use StringLike instead for pattern matching")
        }</span>

        <span class="cov9" title="26">if legacyStatementsExist &amp;&amp; hasAnySourceIdentity </span><span class="cov5" title="6">{
                result.Issues = append(result.Issues, "Mixed enforcement: some Allow statements lack SourceIdentity condition (migration mode)")
        }</span>

        // Generate recommendations
        <span class="cov9" title="26">switch result.Status </span>{
        case EnforcementStatusNone:<span class="cov6" title="7">
                result.Recommendations = append(result.Recommendations,
                        "Add StringLike condition for sts:SourceIdentity with pattern sentinel:* to require Sentinel enforcement")</span>
        case EnforcementStatusPartial:<span class="cov6" title="7">
                if legacyStatementsExist </span><span class="cov5" title="6">{
                        result.Recommendations = append(result.Recommendations,
                                "Add sts:SourceIdentity condition to all Allow statements, or remove legacy statements after migration")
                }</span>
                <span class="cov6" title="7">if !hasSentinelWildcard &amp;&amp; hasUserSpecificPatterns </span>{<span class="cov0" title="0">
                        // User-specific patterns are valid full enforcement
                        // No recommendation needed
                }</span> else<span class="cov6" title="7"> if !hasSentinelWildcard </span><span class="cov1" title="1">{
                        result.Recommendations = append(result.Recommendations,
                                "Update SourceIdentity pattern to sentinel:* for full Sentinel enforcement")
                }</span>
        case EnforcementStatusFull:<span class="cov7" title="12"></span>
                // No recommendations for compliant policies
        }

        <span class="cov9" title="26">if hasStringEqualsForWild </span><span class="cov2" title="2">{
                result.Recommendations = append(result.Recommendations,
                        "Change StringEquals to StringLike for wildcard patterns (sentinel:*)")
        }</span>

        <span class="cov9" title="26">return result</span>
}

// IsEnforced returns true if the trust policy has full Sentinel enforcement.
// This is a convenience function for simple compliance checks.
func IsEnforced(policy *TrustPolicyDocument) bool <span class="cov4" title="4">{
        result := AnalyzeTrustPolicy(policy)
        return result.Status == EnforcementStatusFull
}</span>

// AnalyzeStatement analyzes a single statement for Sentinel enforcement.
// Returns true if the statement requires Sentinel SourceIdentity.
func AnalyzeStatement(stmt *Statement) (enforced bool, patterns []string) <span class="cov5" title="6">{
        if stmt == nil || stmt.Effect != "Allow" </span><span class="cov2" title="2">{
                return false, nil
        }</span>

        <span class="cov4" title="4">patterns = GetSourceIdentityPatterns(stmt)
        if len(patterns) == 0 </span><span class="cov1" title="1">{
                return false, nil
        }</span>

        // Check if any pattern is a sentinel pattern
        <span class="cov3" title="3">for _, p := range patterns </span><span class="cov3" title="3">{
                if IsSentinelPattern(p) </span><span class="cov2" title="2">{
                        return true, patterns
                }</span>
        }

        <span class="cov1" title="1">return false, patterns</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package enforce

import (
        "context"

        "github.com/aws/aws-sdk-go-v2/aws"
)

// DriftStatus indicates the Sentinel enforcement state of a role.
type DriftStatus string

const (
        // DriftStatusOK means the role has full Sentinel enforcement.
        DriftStatusOK DriftStatus = "ok"
        // DriftStatusPartial means the role has partial enforcement (some statements missing).
        DriftStatusPartial DriftStatus = "partial"
        // DriftStatusNone means the role has no Sentinel enforcement.
        DriftStatusNone DriftStatus = "none"
        // DriftStatusUnknown means the check failed (e.g., IAM API error).
        DriftStatusUnknown DriftStatus = "unknown"
)

// String returns the string representation of the DriftStatus.
func (s DriftStatus) String() string <span class="cov8" title="4">{
        return string(s)
}</span>

// DriftCheckResult contains the outcome of checking a role for Sentinel enforcement drift.
type DriftCheckResult struct {
        // Status is the drift status determined by the check.
        Status DriftStatus `json:"status"`
        // RoleARN is the ARN of the role that was checked.
        RoleARN string `json:"role_arn"`
        // Message is a human-readable explanation of the status.
        Message string `json:"message"`
        // Error is the error message if the check failed (Status=DriftStatusUnknown).
        Error string `json:"error,omitempty"`
}

// DriftChecker checks IAM roles for Sentinel enforcement drift.
type DriftChecker interface {
        // CheckRole analyzes a role's trust policy for Sentinel enforcement.
        // Returns DriftCheckResult with the enforcement status.
        CheckRole(ctx context.Context, roleARN string) (*DriftCheckResult, error)
}

// driftChecker implements DriftChecker using the Advisor for IAM analysis.
type driftChecker struct {
        advisor *Advisor
}

// NewDriftChecker creates a new DriftChecker with the given AWS config.
func NewDriftChecker(cfg aws.Config) DriftChecker <span class="cov0" title="0">{
        return &amp;driftChecker{
                advisor: NewAdvisor(cfg),
        }
}</span>

// NewDriftCheckerWithAdvisor creates a DriftChecker with a custom Advisor.
// This is useful for testing.
func NewDriftCheckerWithAdvisor(advisor *Advisor) DriftChecker <span class="cov10" title="5">{
        return &amp;driftChecker{
                advisor: advisor,
        }
}</span>

// CheckRole analyzes a role's trust policy for Sentinel enforcement.
func (c *driftChecker) CheckRole(ctx context.Context, roleARN string) (*DriftCheckResult, error) <span class="cov10" title="5">{
        result := &amp;DriftCheckResult{
                RoleARN: roleARN,
        }

        // Use Advisor to analyze the role
        analysis, err := c.advisor.AnalyzeRole(ctx, roleARN)
        if err != nil </span><span class="cov0" title="0">{
                result.Status = DriftStatusUnknown
                result.Error = err.Error()
                result.Message = "Failed to analyze role"
                return result, nil
        }</span>

        // Check if analysis itself had an error
        <span class="cov10" title="5">if analysis.Error != "" </span><span class="cov4" title="2">{
                result.Status = DriftStatusUnknown
                result.Error = analysis.Error
                result.Message = "Failed to analyze role trust policy"
                return result, nil
        }</span>

        // Map AnalysisResult.Status to DriftStatus
        <span class="cov7" title="3">switch analysis.Analysis.Status </span>{
        case EnforcementStatusFull:<span class="cov1" title="1">
                result.Status = DriftStatusOK
                result.Message = "Role has full Sentinel enforcement"</span>
        case EnforcementStatusPartial:<span class="cov1" title="1">
                result.Status = DriftStatusPartial
                result.Message = "Role has partial Sentinel enforcement"
                if len(analysis.Analysis.Issues) &gt; 0 </span><span class="cov1" title="1">{
                        result.Message = analysis.Analysis.Issues[0]
                }</span>
        case EnforcementStatusNone:<span class="cov1" title="1">
                result.Status = DriftStatusNone
                result.Message = "Role has no Sentinel enforcement"
                if len(analysis.Analysis.Recommendations) &gt; 0 </span><span class="cov1" title="1">{
                        result.Message = analysis.Analysis.Recommendations[0]
                }</span>
        default:<span class="cov0" title="0">
                result.Status = DriftStatusUnknown
                result.Message = "Unknown enforcement status"</span>
        }

        <span class="cov7" title="3">return result, nil</span>
}

// TestDriftChecker is a DriftChecker implementation for testing.
// It allows tests to control the drift check results.
type TestDriftChecker struct {
        // CheckFunc is called by CheckRole. If nil, returns DriftStatusOK.
        CheckFunc func(ctx context.Context, roleARN string) (*DriftCheckResult, error)
}

// CheckRole calls the configured CheckFunc or returns DriftStatusOK by default.
func (t *TestDriftChecker) CheckRole(ctx context.Context, roleARN string) (*DriftCheckResult, error) <span class="cov10" title="5">{
        if t.CheckFunc != nil </span><span class="cov8" title="4">{
                return t.CheckFunc(ctx, roleARN)
        }</span>
        <span class="cov1" title="1">return &amp;DriftCheckResult{
                Status:  DriftStatusOK,
                RoleARN: roleARN,
                Message: "Role has full Sentinel enforcement",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package enforce

import (
        "strings"
)

// MatchPattern implements AWS StringLike wildcard matching.
// Wildcards:
//   - "*" matches any sequence of characters (including empty)
//   - "?" matches any single character
//
// Matching is case-sensitive (AWS default behavior).
func MatchPattern(pattern, value string) bool <span class="cov6" title="31">{
        return matchPattern(pattern, value)
}</span>

// matchPattern is a recursive implementation of AWS StringLike matching.
func matchPattern(pattern, value string) bool <span class="cov8" title="79">{
        for len(pattern) &gt; 0 </span><span class="cov10" title="221">{
                switch pattern[0] </span>{
                case '*':<span class="cov5" title="17">
                        // Try matching the rest of the pattern with different amounts of consumed value
                        // First, skip consecutive stars
                        for len(pattern) &gt; 0 &amp;&amp; pattern[0] == '*' </span><span class="cov5" title="18">{
                                pattern = pattern[1:]
                        }</span>
                        // If pattern is exhausted after stars, it matches any remaining value
                        <span class="cov5" title="17">if len(pattern) == 0 </span><span class="cov4" title="10">{
                                return true
                        }</span>
                        // Try matching rest of pattern at each position in value
                        <span class="cov4" title="7">for i := 0; i &lt;= len(value); i++ </span><span class="cov7" title="48">{
                                if matchPattern(pattern, value[i:]) </span><span class="cov3" title="6">{
                                        return true
                                }</span>
                        }
                        <span class="cov1" title="1">return false</span>
                case '?':<span class="cov5" title="18">
                        // Must match exactly one character
                        if len(value) == 0 </span><span class="cov1" title="1">{
                                return false
                        }</span>
                        <span class="cov5" title="17">pattern = pattern[1:]
                        value = value[1:]</span>
                default:<span class="cov9" title="186">
                        // Literal character must match
                        if len(value) == 0 || pattern[0] != value[0] </span><span class="cov7" title="42">{
                                return false
                        }</span>
                        <span class="cov9" title="144">pattern = pattern[1:]
                        value = value[1:]</span>
                }
        }
        // Pattern exhausted - value must also be exhausted
        <span class="cov5" title="19">return len(value) == 0</span>
}

// HasSourceIdentityCondition checks if a statement requires sts:SourceIdentity
// with a sentinel:* pattern.
func HasSourceIdentityCondition(stmt *Statement) bool <span class="cov4" title="8">{
        if stmt == nil || stmt.Condition == nil </span><span class="cov2" title="2">{
                return false
        }</span>

        // Check StringLike operator
        <span class="cov3" title="6">if stringLike, ok := stmt.Condition["StringLike"]; ok </span><span class="cov3" title="5">{
                if hasSentinelPattern(stringLike, "sts:SourceIdentity") </span><span class="cov2" title="3">{
                        return true
                }</span>
        }

        // Check StringEquals operator (exact match)
        <span class="cov2" title="3">if stringEquals, ok := stmt.Condition["StringEquals"]; ok </span><span class="cov1" title="1">{
                if hasSentinelPattern(stringEquals, "sts:SourceIdentity") </span><span class="cov1" title="1">{
                        return true
                }</span>
        }

        <span class="cov2" title="2">return false</span>
}

// hasSentinelPattern checks if a condition operator has a sentinel:* pattern
// for the given condition key.
func hasSentinelPattern(op ConditionOperator, key string) bool <span class="cov3" title="6">{
        values, ok := op[key]
        if !ok </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov3" title="5">for _, v := range values </span><span class="cov3" title="5">{
                if strings.HasPrefix(v, "sentinel:") </span><span class="cov3" title="4">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

// GetSourceIdentityPatterns extracts SourceIdentity patterns from a statement's
// condition block. It checks StringLike and StringEquals operators.
func GetSourceIdentityPatterns(stmt *Statement) []string <span class="cov7" title="42">{
        if stmt == nil || stmt.Condition == nil </span><span class="cov5" title="15">{
                return nil
        }</span>

        <span class="cov6" title="27">var patterns []string

        // Check StringLike operator
        if stringLike, ok := stmt.Condition["StringLike"]; ok </span><span class="cov6" title="24">{
                if values, ok := stringLike["sts:SourceIdentity"]; ok </span><span class="cov6" title="24">{
                        patterns = append(patterns, values...)
                }</span>
        }

        // Check StringEquals operator
        <span class="cov6" title="27">if stringEquals, ok := stmt.Condition["StringEquals"]; ok </span><span class="cov2" title="3">{
                if values, ok := stringEquals["sts:SourceIdentity"]; ok </span><span class="cov2" title="3">{
                        patterns = append(patterns, values...)
                }</span>
        }

        // Check StringNotLike operator (for Deny statements / SCPs)
        <span class="cov6" title="27">if stringNotLike, ok := stmt.Condition["StringNotLike"]; ok </span><span class="cov1" title="1">{
                if values, ok := stringNotLike["sts:SourceIdentity"]; ok </span><span class="cov1" title="1">{
                        patterns = append(patterns, values...)
                }</span>
        }

        // Check StringNotEquals operator
        <span class="cov6" title="27">if stringNotEquals, ok := stmt.Condition["StringNotEquals"]; ok </span><span class="cov0" title="0">{
                if values, ok := stringNotEquals["sts:SourceIdentity"]; ok </span><span class="cov0" title="0">{
                        patterns = append(patterns, values...)
                }</span>
        }

        <span class="cov6" title="27">return patterns</span>
}

// EvaluateCondition evaluates a condition against a given value.
// Supports: StringLike, StringNotLike, StringEquals, StringNotEquals
func EvaluateCondition(operator string, pattern, value string) bool <span class="cov4" title="9">{
        switch operator </span>{
        case "StringLike":<span class="cov2" title="2">
                return MatchPattern(pattern, value)</span>
        case "StringNotLike":<span class="cov2" title="2">
                return !MatchPattern(pattern, value)</span>
        case "StringEquals":<span class="cov2" title="2">
                return pattern == value</span>
        case "StringNotEquals":<span class="cov2" title="2">
                return pattern != value</span>
        default:<span class="cov1" title="1">
                return false</span>
        }
}

// HasSentinelWildcardPattern checks if any pattern in the slice is "sentinel:*"
// (the general wildcard pattern for any Sentinel-issued credentials).
func HasSentinelWildcardPattern(patterns []string) bool <span class="cov6" title="25">{
        for _, p := range patterns </span><span class="cov6" title="29">{
                if p == "sentinel:*" </span><span class="cov5" title="18">{
                        return true
                }</span>
        }
        <span class="cov4" title="7">return false</span>
}

// IsSentinelPattern checks if a pattern matches Sentinel format.
// Valid patterns:
//   - "sentinel:*" (any Sentinel credential)
//   - "sentinel:alice:*" (specific user)
//   - "sentinel:bob:a1b2c3d4" (specific session)
func IsSentinelPattern(pattern string) bool <span class="cov5" title="16">{
        return strings.HasPrefix(pattern, "sentinel:")
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package enforce

import (
        "errors"
        "fmt"
)

// TrustPolicyPattern represents the three documented patterns from ENFORCEMENT.md
type TrustPolicyPattern string

const (
        // PatternA represents any Sentinel-issued credentials.
        // Requires SourceIdentity to match sentinel:*
        PatternA TrustPolicyPattern = "any-sentinel"
        // PatternB represents Sentinel + specific users.
        // Requires SourceIdentity to match sentinel:&lt;user&gt;:*
        PatternB TrustPolicyPattern = "specific-users"
        // PatternC represents Sentinel OR legacy (migration period).
        // Includes both Sentinel condition and legacy principal without condition.
        PatternC TrustPolicyPattern = "migration"
)

// IsValid returns true if the pattern is a known value.
func (p TrustPolicyPattern) IsValid() bool <span class="cov10" title="20">{
        return p == PatternA || p == PatternB || p == PatternC
}</span>

// String returns the string representation of the pattern.
func (p TrustPolicyPattern) String() string <span class="cov4" title="3">{
        return string(p)
}</span>

// GenerateInput contains options for trust policy generation.
type GenerateInput struct {
        // Pattern is the trust policy pattern to generate.
        Pattern TrustPolicyPattern
        // PrincipalARN is the AWS principal ARN (e.g., "arn:aws:iam::123456789012:root").
        PrincipalARN string
        // Users is the list of usernames to allow for Pattern B (e.g., ["alice", "bob"]).
        Users []string
        // LegacyPrincipal is the legacy principal ARN for Pattern C.
        LegacyPrincipal string
}

// GenerateOutput contains the generated trust policy.
type GenerateOutput struct {
        // Pattern is the pattern that was used to generate the policy.
        Pattern TrustPolicyPattern `json:"pattern"`
        // Policy is the generated trust policy document.
        Policy *TrustPolicyDocument `json:"policy"`
}

// GenerateTrustPolicy generates a trust policy document based on the input pattern.
// It validates the input and returns an error for invalid combinations.
func GenerateTrustPolicy(input GenerateInput) (*GenerateOutput, error) <span class="cov8" title="12">{
        // Validate pattern
        if !input.Pattern.IsValid() </span><span class="cov3" title="2">{
                return nil, errors.New("pattern is required: must be one of 'any-sentinel', 'specific-users', or 'migration'")
        }</span>

        // Validate principal ARN
        <span class="cov7" title="10">if input.PrincipalARN == "" </span><span class="cov1" title="1">{
                return nil, errors.New("principal ARN is required")
        }</span>

        // Pattern-specific validation
        <span class="cov7" title="9">switch input.Pattern </span>{
        case PatternB:<span class="cov5" title="4">
                if len(input.Users) == 0 </span><span class="cov3" title="2">{
                        return nil, errors.New("users list is required for 'specific-users' pattern")
                }</span>
        case PatternC:<span class="cov3" title="2">
                if input.LegacyPrincipal == "" </span><span class="cov1" title="1">{
                        return nil, errors.New("legacy principal is required for 'migration' pattern")
                }</span>
        }

        // Generate policy based on pattern
        <span class="cov6" title="6">var policy *TrustPolicyDocument
        var err error

        switch input.Pattern </span>{
        case PatternA:<span class="cov4" title="3">
                policy, err = generatePatternA(input.PrincipalARN)</span>
        case PatternB:<span class="cov3" title="2">
                policy, err = generatePatternB(input.PrincipalARN, input.Users)</span>
        case PatternC:<span class="cov1" title="1">
                policy, err = generatePatternC(input.PrincipalARN, input.LegacyPrincipal)</span>
        }

        <span class="cov6" title="6">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="6">return &amp;GenerateOutput{
                Pattern: input.Pattern,
                Policy:  policy,
        }, nil</span>
}

// generatePatternA creates a trust policy that allows any Sentinel-issued credentials.
// This is Pattern A from ENFORCEMENT.md.
func generatePatternA(principalARN string) (*TrustPolicyDocument, error) <span class="cov4" title="3">{
        return &amp;TrustPolicyDocument{
                Version: "2012-10-17",
                Statement: []Statement{
                        {
                                Sid:    "AllowSentinelAccess",
                                Effect: "Allow",
                                Principal: Principal{
                                        AWS: StringOrSlice{principalARN},
                                },
                                Action: StringOrSlice{"sts:AssumeRole"},
                                Condition: ConditionBlock{
                                        "StringLike": ConditionOperator{
                                                "sts:SourceIdentity": StringOrSlice{"sentinel:*"},
                                        },
                                },
                        },
                },
        }, nil
}</span>

// generatePatternB creates a trust policy that allows specific Sentinel users.
// This is Pattern B from ENFORCEMENT.md.
func generatePatternB(principalARN string, users []string) (*TrustPolicyDocument, error) <span class="cov3" title="2">{
        if len(users) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("at least one user is required for pattern B")
        }</span>

        // Build user-specific patterns: sentinel:alice:*, sentinel:bob:*
        <span class="cov3" title="2">patterns := make(StringOrSlice, len(users))
        for i, user := range users </span><span class="cov5" title="5">{
                patterns[i] = fmt.Sprintf("sentinel:%s:*", user)
        }</span>

        <span class="cov3" title="2">return &amp;TrustPolicyDocument{
                Version: "2012-10-17",
                Statement: []Statement{
                        {
                                Sid:    "AllowSentinelUsers",
                                Effect: "Allow",
                                Principal: Principal{
                                        AWS: StringOrSlice{principalARN},
                                },
                                Action: StringOrSlice{"sts:AssumeRole"},
                                Condition: ConditionBlock{
                                        "StringLike": ConditionOperator{
                                                "sts:SourceIdentity": patterns,
                                        },
                                },
                        },
                },
        }, nil</span>
}

// generatePatternC creates a trust policy with both Sentinel and legacy access.
// This is Pattern C from ENFORCEMENT.md (migration mode).
func generatePatternC(principalARN, legacyPrincipal string) (*TrustPolicyDocument, error) <span class="cov1" title="1">{
        return &amp;TrustPolicyDocument{
                Version: "2012-10-17",
                Statement: []Statement{
                        {
                                Sid:    "AllowSentinelAccess",
                                Effect: "Allow",
                                Principal: Principal{
                                        AWS: StringOrSlice{principalARN},
                                },
                                Action: StringOrSlice{"sts:AssumeRole"},
                                Condition: ConditionBlock{
                                        "StringLike": ConditionOperator{
                                                "sts:SourceIdentity": StringOrSlice{"sentinel:*"},
                                        },
                                },
                        },
                        {
                                Sid:    "AllowLegacyAccess",
                                Effect: "Allow",
                                Principal: Principal{
                                        AWS: StringOrSlice{legacyPrincipal},
                                },
                                Action: StringOrSlice{"sts:AssumeRole"},
                        },
                },
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package enforce

import (
        "encoding/json"
        "fmt"
)

// ParseTrustPolicy parses a JSON byte slice into a TrustPolicyDocument.
// It handles the flexible AWS JSON format where Principal and Action
// can be strings, arrays, or objects.
func ParseTrustPolicy(data []byte) (*TrustPolicyDocument, error) <span class="cov8" title="31">{
        if len(data) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("empty trust policy")
        }</span>

        <span class="cov8" title="30">var doc TrustPolicyDocument
        if err := json.Unmarshal(data, &amp;doc); err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("invalid JSON: %w", err)
        }</span>

        <span class="cov8" title="28">if err := doc.Validate(); err != nil </span><span class="cov4" title="4">{
                return nil, err
        }</span>

        <span class="cov7" title="24">return &amp;doc, nil</span>
}

// Validate checks that the TrustPolicyDocument has required fields
// and valid values.
func (d *TrustPolicyDocument) Validate() error <span class="cov8" title="28">{
        if d.Version == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("missing Version field")
        }</span>
        <span class="cov8" title="27">if len(d.Statement) == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("missing Statement field")
        }</span>
        <span class="cov8" title="26">for i, stmt := range d.Statement </span><span class="cov8" title="29">{
                if stmt.Effect != "Allow" &amp;&amp; stmt.Effect != "Deny" </span><span class="cov1" title="1">{
                        return fmt.Errorf("statement %d: Effect must be Allow or Deny, got %q", i, stmt.Effect)
                }</span>
                <span class="cov8" title="28">if len(stmt.Action) == 0 </span><span class="cov1" title="1">{
                        return fmt.Errorf("statement %d: missing Action field", i)
                }</span>
        }
        <span class="cov7" title="24">return nil</span>
}

// UnmarshalJSON implements custom JSON unmarshaling for StringOrSlice.
// It handles both single string values and arrays of strings.
func (s *StringOrSlice) UnmarshalJSON(data []byte) error <span class="cov10" title="61">{
        // First try as string
        var str string
        if err := json.Unmarshal(data, &amp;str); err == nil </span><span class="cov9" title="57">{
                *s = StringOrSlice{str}
                return nil
        }</span>

        // Then try as array
        <span class="cov4" title="4">var arr []string
        if err := json.Unmarshal(data, &amp;arr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("expected string or []string: %w", err)
        }</span>
        <span class="cov4" title="4">*s = StringOrSlice(arr)
        return nil</span>
}

// MarshalJSON implements JSON marshaling for StringOrSlice.
// If there's a single value, it marshals as a string; otherwise as an array.
func (s StringOrSlice) MarshalJSON() ([]byte, error) <span class="cov3" title="3">{
        if len(s) == 1 </span><span class="cov3" title="3">{
                return json.Marshal(s[0])
        }</span>
        <span class="cov0" title="0">return json.Marshal([]string(s))</span>
}

// UnmarshalJSON implements custom JSON unmarshaling for Principal.
// AWS trust policies allow Principal to be:
//   - "*" (any principal)
//   - {"AWS": "arn:..."} or {"AWS": ["arn1", "arn2"]}
//   - {"Service": "ec2.amazonaws.com"}
//   - {"Federated": "arn:..."}
func (p *Principal) UnmarshalJSON(data []byte) error <span class="cov8" title="30">{
        // First try as wildcard string "*"
        var str string
        if err := json.Unmarshal(data, &amp;str); err == nil </span><span class="cov6" title="12">{
                if str == "*" </span><span class="cov6" title="12">{
                        p.Wildcard = true
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("Principal string must be \"*\", got %q", str)</span>
        }

        // Then try as object with AWS/Service/Federated keys
        <span class="cov7" title="18">type principalAlias struct {
                AWS       StringOrSlice `json:"AWS,omitempty"`
                Service   StringOrSlice `json:"Service,omitempty"`
                Federated StringOrSlice `json:"Federated,omitempty"`
        }
        var obj principalAlias
        if err := json.Unmarshal(data, &amp;obj); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("expected Principal as \"*\" or object: %w", err)
        }</span>

        <span class="cov7" title="18">p.AWS = obj.AWS
        p.Service = obj.Service
        p.Federated = obj.Federated
        p.Wildcard = false
        return nil</span>
}

// MarshalJSON implements JSON marshaling for Principal.
func (p Principal) MarshalJSON() ([]byte, error) <span class="cov1" title="1">{
        if p.Wildcard </span><span class="cov0" title="0">{
                return json.Marshal("*")
        }</span>
        <span class="cov1" title="1">type principalAlias struct {
                AWS       StringOrSlice `json:"AWS,omitempty"`
                Service   StringOrSlice `json:"Service,omitempty"`
                Federated StringOrSlice `json:"Federated,omitempty"`
        }
        return json.Marshal(principalAlias{
                AWS:       p.AWS,
                Service:   p.Service,
                Federated: p.Federated,
        })</span>
}

// Contains checks if the StringOrSlice contains the given value.
func (s StringOrSlice) Contains(value string) bool <span class="cov2" title="2">{
        for _, v := range s </span><span class="cov3" title="3">{
                if v == value </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package enforce provides types and functions for analyzing IAM trust policy
// enforcement of Sentinel SourceIdentity requirements.
package enforce

// EnforcementLevel indicates the strictness of Sentinel enforcement.
// It represents the three levels documented in ENFORCEMENT.md:
// Advisory (logging only), TrustPolicy (per-role), and SCP (organization-wide).
type EnforcementLevel string

const (
        // EnforcementLevelAdvisory means Sentinel logs decisions but doesn't enforce.
        // AWS accepts any valid credentials regardless of SourceIdentity.
        EnforcementLevelAdvisory EnforcementLevel = "advisory"
        // EnforcementLevelTrustPolicy means individual roles require Sentinel SourceIdentity.
        // Non-Sentinel credentials are rejected by the role's trust policy.
        EnforcementLevelTrustPolicy EnforcementLevel = "trust_policy"
        // EnforcementLevelSCP means organization-wide policies require Sentinel.
        // Applied via Service Control Policies across accounts.
        EnforcementLevelSCP EnforcementLevel = "scp"
)

// IsValid returns true if the EnforcementLevel is a known value.
func (e EnforcementLevel) IsValid() bool <span class="cov9" title="5">{
        return e == EnforcementLevelAdvisory || e == EnforcementLevelTrustPolicy || e == EnforcementLevelSCP
}</span>

// String returns the string representation of the EnforcementLevel.
func (e EnforcementLevel) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

// EnforcementStatus indicates the completeness of Sentinel enforcement.
type EnforcementStatus string

const (
        // EnforcementStatusNone means no Sentinel enforcement is configured.
        // The role accepts credentials without SourceIdentity requirements.
        EnforcementStatusNone EnforcementStatus = "none"
        // EnforcementStatusPartial means some statements enforce Sentinel but not all.
        // This may occur during migration periods (Pattern C from ENFORCEMENT.md).
        EnforcementStatusPartial EnforcementStatus = "partial"
        // EnforcementStatusFull means all Allow statements require Sentinel SourceIdentity.
        // Non-Sentinel credentials cannot assume this role.
        EnforcementStatusFull EnforcementStatus = "full"
)

// IsValid returns true if the EnforcementStatus is a known value.
func (e EnforcementStatus) IsValid() bool <span class="cov9" title="5">{
        return e == EnforcementStatusNone || e == EnforcementStatusPartial || e == EnforcementStatusFull
}</span>

// String returns the string representation of the EnforcementStatus.
func (e EnforcementStatus) String() string <span class="cov0" title="0">{
        return string(e)
}</span>

// AnalysisResult contains the outcome of analyzing a trust policy for Sentinel enforcement.
type AnalysisResult struct {
        // Level indicates the enforcement strictness detected.
        Level EnforcementLevel `json:"level"`
        // Status indicates how completely Sentinel enforcement is configured.
        Status EnforcementStatus `json:"status"`
        // HasSourceIdentityCondition is true if any statement has sts:SourceIdentity condition.
        HasSourceIdentityCondition bool `json:"has_source_identity_condition"`
        // Issues lists problems found during analysis.
        Issues []string `json:"issues,omitempty"`
        // Recommendations suggests improvements for better enforcement.
        Recommendations []string `json:"recommendations,omitempty"`
}

// TrustPolicyDocument represents an IAM trust policy (AssumeRolePolicyDocument).
// AWS trust policies define who can assume a role using sts:AssumeRole.
type TrustPolicyDocument struct {
        Version   string      `json:"Version"`
        Statement []Statement `json:"Statement"`
}

// Statement represents a single statement in a trust policy.
// Each statement specifies who (Principal) can perform what (Action)
// under what conditions (Condition).
type Statement struct {
        // Sid is an optional statement identifier for documentation.
        Sid string `json:"Sid,omitempty"`
        // Effect must be "Allow" or "Deny".
        Effect string `json:"Effect"`
        // Principal specifies who can assume the role.
        Principal Principal `json:"Principal"`
        // Action specifies the allowed actions (typically sts:AssumeRole).
        Action StringOrSlice `json:"Action"`
        // Condition specifies additional requirements (like sts:SourceIdentity).
        Condition ConditionBlock `json:"Condition,omitempty"`
}

// Principal represents the Principal element in a trust policy statement.
// AWS allows several formats:
//   - "*" (any principal)
//   - {"AWS": "arn:aws:iam::123456789012:root"}
//   - {"AWS": ["arn1", "arn2"]}
//   - {"Service": "ec2.amazonaws.com"}
//   - {"Federated": "arn:aws:iam::123456789012:saml-provider/ExampleProvider"}
type Principal struct {
        // AWS contains AWS account or IAM principal ARNs.
        AWS StringOrSlice `json:"AWS,omitempty"`
        // Service contains AWS service principals (e.g., ec2.amazonaws.com).
        Service StringOrSlice `json:"Service,omitempty"`
        // Federated contains federated identity provider ARNs.
        Federated StringOrSlice `json:"Federated,omitempty"`
        // Wildcard is true if Principal was "*" (any principal).
        Wildcard bool `json:"-"`
}

// StringOrSlice handles AWS JSON fields that can be a string or []string.
// For example, Action can be "sts:AssumeRole" or ["sts:AssumeRole", "sts:AssumeRoleWithSAML"].
type StringOrSlice []string

// ConditionBlock represents the Condition element in a trust policy statement.
// The structure is: Operator -&gt; ConditionKey -&gt; Values
// Example: {"StringLike": {"sts:SourceIdentity": "sentinel:*"}}
type ConditionBlock map[string]ConditionOperator

// ConditionOperator maps condition keys to their required values.
// Example: {"sts:SourceIdentity": ["sentinel:*"]}
type ConditionOperator map[string]StringOrSlice

// HasSourceIdentityCondition checks if the condition block contains
// an sts:SourceIdentity condition with a sentinel:* pattern.
func (c ConditionBlock) HasSourceIdentityCondition() bool <span class="cov9" title="5">{
        // Check StringLike for sentinel:* pattern
        if stringLike, ok := c["StringLike"]; ok </span><span class="cov6" title="3">{
                if values, ok := stringLike["sts:SourceIdentity"]; ok </span><span class="cov4" title="2">{
                        for _, v := range values </span><span class="cov4" title="2">{
                                if v == "sentinel:*" || len(v) &gt; 9 &amp;&amp; v[:9] == "sentinel:" </span><span class="cov4" title="2">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov6" title="3">return false</span>
}

// HasSourceIdentityDeny checks if the condition block denies requests
// without Sentinel SourceIdentity (using StringNotLike).
func (c ConditionBlock) HasSourceIdentityDeny() bool <span class="cov10" title="6">{
        // Check StringNotLike for sentinel:* pattern (used in SCPs)
        if stringNotLike, ok := c["StringNotLike"]; ok </span><span class="cov4" title="2">{
                if values, ok := stringNotLike["sts:SourceIdentity"]; ok </span><span class="cov4" title="2">{
                        for _, v := range values </span><span class="cov4" title="2">{
                                if v == "sentinel:*" || len(v) &gt; 9 &amp;&amp; v[:9] == "sentinel:" </span><span class="cov4" title="2">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov7" title="4">return false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package identity

import (
        "crypto/rand"
        "encoding/hex"
)

// NewRequestID generates a new 8-character lowercase hex request-id.
// It uses crypto/rand for cryptographic randomness.
//
// The request-id provides:
//   - Uniqueness per credential request
//   - Correlation between Sentinel logs and CloudTrail events
//   - No PII or sensitive data (just random identifier)
func NewRequestID() string <span class="cov10" title="1011">{
        // Generate 4 random bytes (32 bits of entropy)
        bytes := make([]byte, 4)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                // This should never happen with crypto/rand
                // Fall back to zeros rather than panic
                return "00000000"
        }</span>

        // Encode as 8-character lowercase hex string
        <span class="cov10" title="1011">return hex.EncodeToString(bytes)</span>
}

// ValidateRequestID checks if the given string is a valid request-id.
// A valid request-id is exactly 8 lowercase hexadecimal characters.
func ValidateRequestID(id string) bool <span class="cov5" title="45">{
        return requestIDRegex.MatchString(id)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package identity provides types and functions for Sentinel's SourceIdentity
// stamping mechanism. SourceIdentity is stamped on AWS STS AssumeRole calls
// to make Sentinel's access decisions visible and enforceable inside AWS.
//
// # SourceIdentity Format
//
// The SourceIdentity format is: sentinel:&lt;user&gt;:&lt;request-id&gt;
//
// Components:
//   - "sentinel:" - Fixed prefix identifying Sentinel-issued credentials
//   - user - Sanitized username (alphanumeric only, max 20 chars)
//   - request-id - 8-character lowercase hex string (32 bits of entropy)
//
// Example: sentinel:alice:a1b2c3d4
//
// # AWS Constraints
//
// SourceIdentity in AWS has the following constraints:
//   - Maximum 64 characters total
//   - Allowed characters: alphanumeric and =,.@-
//   - Set once on AssumeRole, immutable for session lifetime
//   - Propagates through role chaining via session tags
//
// The format is designed to stay well under these limits:
//   - Prefix "sentinel:" = 9 chars
//   - User (max) = 20 chars
//   - Separator ":" = 1 char
//   - Request-ID = 8 chars
//   - Total max = 38 chars (well under 64)
package identity

import (
        "errors"
        "fmt"
        "regexp"
        "strings"
)

const (
        // Prefix is the fixed prefix for Sentinel SourceIdentity values.
        Prefix = "sentinel"

        // MaxUserLength is the maximum length for the user component.
        MaxUserLength = 20

        // RequestIDLength is the exact length for request-id (8 hex chars).
        RequestIDLength = 8

        // MaxSourceIdentityLength is AWS's maximum SourceIdentity length.
        MaxSourceIdentityLength = 64

        // separator is the delimiter between components.
        separator = ":"
)

var (
        // ErrEmptyUser indicates the user field is empty.
        ErrEmptyUser = errors.New("user cannot be empty")

        // ErrUserTooLong indicates the user exceeds MaxUserLength.
        ErrUserTooLong = errors.New("user exceeds maximum length of 20 characters")

        // ErrInvalidUserChars indicates the user contains non-alphanumeric characters.
        ErrInvalidUserChars = errors.New("user must contain only alphanumeric characters")

        // ErrInvalidRequestID indicates the request-id is not valid.
        ErrInvalidRequestID = errors.New("request-id must be exactly 8 lowercase hex characters")

        // ErrInvalidFormat indicates the SourceIdentity string format is invalid.
        ErrInvalidFormat = errors.New("invalid SourceIdentity format: expected sentinel:&lt;user&gt;:&lt;request-id&gt;")

        // ErrWrongPrefix indicates the SourceIdentity doesn't start with "sentinel:".
        ErrWrongPrefix = errors.New("SourceIdentity must start with 'sentinel:'")
)

// userRegex matches valid usernames (alphanumeric only).
var userRegex = regexp.MustCompile(`^[a-zA-Z0-9]+$`)

// requestIDRegex matches valid request-ids (8 lowercase hex chars).
var requestIDRegex = regexp.MustCompile(`^[0-9a-f]{8}$`)

// SourceIdentity represents a Sentinel-stamped identity for AWS STS.
// It contains the user who requested credentials and a unique request-id
// for correlation between Sentinel logs and CloudTrail events.
type SourceIdentity struct {
        // User is the sanitized username (alphanumeric, max 20 chars).
        User string

        // RequestID is the unique 8-character hex identifier for this request.
        RequestID string
}

// New creates a new SourceIdentity with the given user and request-id.
// It validates both fields before returning.
func New(user, requestID string) (*SourceIdentity, error) <span class="cov4" title="8">{
        si := &amp;SourceIdentity{
                User:      user,
                RequestID: requestID,
        }

        if err := si.Validate(); err != nil </span><span class="cov3" title="4">{
                return nil, err
        }</span>

        <span class="cov3" title="4">return si, nil</span>
}

// Format returns the SourceIdentity as a string in the format:
// sentinel:&lt;user&gt;:&lt;request-id&gt;
func (si *SourceIdentity) Format() string <span class="cov5" title="11">{
        return fmt.Sprintf("%s%s%s%s%s", Prefix, separator, si.User, separator, si.RequestID)
}</span>

// String returns the formatted SourceIdentity string.
// This implements the Stringer interface.
func (si *SourceIdentity) String() string <span class="cov3" title="4">{
        return si.Format()
}</span>

// Validate checks if the SourceIdentity fields are valid.
// Returns nil if valid, or an error describing the validation failure.
func (si *SourceIdentity) Validate() error <span class="cov7" title="34">{
        // Validate user
        if si.User == "" </span><span class="cov3" title="4">{
                return ErrEmptyUser
        }</span>
        <span class="cov7" title="30">if len(si.User) &gt; MaxUserLength </span><span class="cov2" title="2">{
                return ErrUserTooLong
        }</span>
        <span class="cov7" title="28">if !userRegex.MatchString(si.User) </span><span class="cov4" title="8">{
                return ErrInvalidUserChars
        }</span>

        // Validate request-id
        <span class="cov6" title="20">if !ValidateRequestID(si.RequestID) </span><span class="cov5" title="12">{
                return ErrInvalidRequestID
        }</span>

        <span class="cov4" title="8">return nil</span>
}

// IsValid returns true if the SourceIdentity passes all validation checks.
func (si *SourceIdentity) IsValid() bool <span class="cov5" title="13">{
        return si.Validate() == nil
}</span>

// Parse parses a SourceIdentity string into its components.
// Expected format: sentinel:&lt;user&gt;:&lt;request-id&gt;
func Parse(s string) (*SourceIdentity, error) <span class="cov5" title="10">{
        // Check prefix
        if !strings.HasPrefix(s, Prefix+separator) </span><span class="cov3" title="3">{
                return nil, ErrWrongPrefix
        }</span>

        // Split into parts
        <span class="cov4" title="7">parts := strings.Split(s, separator)
        if len(parts) != 3 </span><span class="cov2" title="2">{
                return nil, ErrInvalidFormat
        }</span>

        // parts[0] = "sentinel", parts[1] = user, parts[2] = request-id
        <span class="cov4" title="5">user := parts[1]
        requestID := parts[2]

        return New(user, requestID)</span>
}

// SanitizeUser converts a username to a valid SourceIdentity user component.
// It removes non-alphanumeric characters and truncates to MaxUserLength.
// Returns an error if the result would be empty.
func SanitizeUser(username string) (string, error) <span class="cov5" title="10">{
        // Remove all non-alphanumeric characters
        var result strings.Builder
        for _, r := range username </span><span class="cov10" title="114">{
                if (r &gt;= 'a' &amp;&amp; r &lt;= 'z') || (r &gt;= 'A' &amp;&amp; r &lt;= 'Z') || (r &gt;= '0' &amp;&amp; r &lt;= '9') </span><span class="cov9" title="101">{
                        result.WriteRune(r)
                }</span>
        }

        <span class="cov5" title="10">sanitized := result.String()

        // Truncate if necessary
        if len(sanitized) &gt; MaxUserLength </span><span class="cov1" title="1">{
                sanitized = sanitized[:MaxUserLength]
        }</span>

        // Check if result is valid
        <span class="cov5" title="10">if sanitized == "" </span><span class="cov2" title="2">{
                return "", ErrEmptyUser
        }</span>

        <span class="cov4" title="8">return sanitized, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package iso8601

import "time"

// Format outputs an ISO-8601 datetime string from the given time,
// in a format compatible with all of the AWS SDKs
func Format(t time.Time) string <span class="cov10" title="2">{
        return t.UTC().Format(time.RFC3339)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package logging

import (
        "time"

        "github.com/byteness/aws-vault/v7/iso8601"
        "github.com/byteness/aws-vault/v7/notification"
        "github.com/byteness/aws-vault/v7/request"
)

// ApprovalLogEntry captures all context for an approval workflow event.
// Events include: request.created, request.approved, request.denied,
// request.expired, request.cancelled.
type ApprovalLogEntry struct {
        Timestamp       string `json:"timestamp"`                     // ISO8601 format
        Event           string `json:"event"`                         // "request.created", "request.approved", etc.
        RequestID       string `json:"request_id"`                    // 16-char hex request ID
        Requester       string `json:"requester"`                     // Who requested access
        Profile         string `json:"profile"`                       // AWS profile requested
        Status          string `json:"status"`                        // Current status after event
        Actor           string `json:"actor"`                         // Who triggered event (requester, approver, or "system")
        Justification   string `json:"justification,omitempty"`       // Reason for request (on create)
        Duration        int    `json:"duration_seconds,omitempty"`    // Requested duration (on create)
        Approver        string `json:"approver,omitempty"`            // Who approved/denied
        ApproverComment string `json:"approver_comment,omitempty"`    // Comment from approver
        AutoApproved    bool   `json:"auto_approved,omitempty"`       // True if auto-approved by policy
}

// NewApprovalLogEntry creates an ApprovalLogEntry from a notification event.
// It populates fields based on the event type:
//   - request.created: includes justification, duration
//   - request.approved/denied: includes approver, approver_comment, auto_approved
//   - request.expired/cancelled: no additional optional fields
func NewApprovalLogEntry(event notification.EventType, req *request.Request, actor string) ApprovalLogEntry <span class="cov10" title="29">{
        entry := ApprovalLogEntry{
                Timestamp: iso8601.Format(time.Now()),
                Event:     string(event),
                RequestID: req.ID,
                Requester: req.Requester,
                Profile:   req.Profile,
                Status:    string(req.Status),
                Actor:     actor,
        }

        // Populate optional fields based on event type
        switch event </span>{
        case notification.EventRequestCreated:<span class="cov8" title="15">
                entry.Justification = req.Justification
                if req.Duration &gt; 0 </span><span class="cov2" title="2">{
                        entry.Duration = int(req.Duration.Seconds())
                }</span>

        case notification.EventRequestApproved, notification.EventRequestDenied:<span class="cov6" title="9">
                entry.Approver = req.Approver
                entry.ApproverComment = req.ApproverComment
                // Auto-approved if actor equals requester (self-approval via policy)
                if actor == req.Requester </span><span class="cov5" title="5">{
                        entry.AutoApproved = true
                }</span>
        }

        <span class="cov10" title="29">return entry</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package logging

import (
        "time"

        "github.com/byteness/aws-vault/v7/breakglass"
        "github.com/byteness/aws-vault/v7/iso8601"
)

// Break-glass event type constants for audit logging.
const (
        // BreakGlassEventInvoked is logged when break-glass access is invoked.
        BreakGlassEventInvoked = "breakglass.invoked"
        // BreakGlassEventClosed is logged when break-glass access is manually closed.
        BreakGlassEventClosed = "breakglass.closed"
        // BreakGlassEventExpired is logged when break-glass access expires due to TTL.
        BreakGlassEventExpired = "breakglass.expired"
)

// BreakGlassLogEntry captures all context for a break-glass emergency access event.
// Events include: breakglass.invoked, breakglass.closed, breakglass.expired.
type BreakGlassLogEntry struct {
        Timestamp     string `json:"timestamp"`               // ISO8601 format
        Event         string `json:"event"`                   // "breakglass.invoked", "breakglass.closed", "breakglass.expired"
        EventID       string `json:"event_id"`                // 16-char hex break-glass event ID
        RequestID     string `json:"request_id"`              // 16-char hex request ID for CloudTrail correlation
        Invoker       string `json:"invoker"`                 // Who invoked break-glass
        Profile       string `json:"profile"`                 // AWS profile accessed
        ReasonCode    string `json:"reason_code"`             // Incident category (incident, maintenance, security, recovery, other)
        Justification string `json:"justification"`           // Mandatory detailed explanation (20-1000 chars)
        Status        string `json:"status"`                  // Current status (active, closed, expired)
        Duration      int    `json:"duration_seconds"`        // Requested duration in seconds
        ExpiresAt     string `json:"expires_at"`              // ISO8601 expiration time
        ClosedBy      string `json:"closed_by,omitempty"`     // Who closed (for closed events)
        ClosedReason  string `json:"closed_reason,omitempty"` // Why closed early
}

// NewBreakGlassLogEntry creates a BreakGlassLogEntry from a break-glass event.
// It populates fields based on the event type:
//   - breakglass.invoked: all mandatory fields, no closed fields
//   - breakglass.closed: includes closed_by and closed_reason
//   - breakglass.expired: includes status as expired, no closed_by/closed_reason
func NewBreakGlassLogEntry(event string, bg *breakglass.BreakGlassEvent) BreakGlassLogEntry <span class="cov10" title="8">{
        entry := BreakGlassLogEntry{
                Timestamp:     iso8601.Format(time.Now()),
                Event:         event,
                EventID:       bg.ID,
                RequestID:     bg.RequestID,
                Invoker:       bg.Invoker,
                Profile:       bg.Profile,
                ReasonCode:    string(bg.ReasonCode),
                Justification: bg.Justification,
                Status:        string(bg.Status),
                Duration:      int(bg.Duration.Seconds()),
                ExpiresAt:     iso8601.Format(bg.ExpiresAt),
        }

        // Populate closed fields only for closed/expired events
        switch event </span>{
        case BreakGlassEventClosed:<span class="cov1" title="1">
                entry.ClosedBy = bg.ClosedBy
                entry.ClosedReason = bg.ClosedReason</span>
        case BreakGlassEventExpired:<span class="cov1" title="1"></span>
                // Expired events don't have ClosedBy/ClosedReason (system expired)
                // Status is already set from bg.Status
        }

        <span class="cov10" title="8">return entry</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package logging

import (
        "time"

        "github.com/byteness/aws-vault/v7/iso8601"
        "github.com/byteness/aws-vault/v7/policy"
)

// DecisionLogEntry captures all context for an access decision.
type DecisionLogEntry struct {
        Timestamp         string `json:"timestamp"`                          // ISO8601 format
        User              string `json:"user"`                               // Username making the request
        Profile           string `json:"profile"`                            // AWS profile requested
        Effect            string `json:"effect"`                             // "allow" or "deny"
        Rule              string `json:"rule"`                               // Matched rule name (empty if default deny)
        RuleIndex         int    `json:"rule_index"`                         // Position of matched rule (-1 if no match)
        Reason            string `json:"reason"`                             // Rule's reason or "no matching rule"
        PolicyPath        string `json:"policy_path"`                        // SSM parameter path
        RequestID         string `json:"request_id,omitempty"`               // 8-char hex request identifier
        SourceIdentity    string `json:"source_identity,omitempty"`          // Full sentinel:user:request-id string
        RoleARN           string `json:"role_arn,omitempty"`                 // Target role ARN if applicable
        SessionDuration   int    `json:"session_duration_seconds,omitempty"` // Session duration in seconds
        ApprovedRequestID string `json:"approved_request_id,omitempty"`      // ID of approved request that overrode policy deny
        BreakGlassEventID string `json:"break_glass_event_id,omitempty"`     // ID of break-glass event that overrode policy deny
        DriftStatus       string `json:"drift_status,omitempty"`             // Sentinel enforcement drift status: "ok", "partial", "none", "unknown"
        DriftMessage      string `json:"drift_message,omitempty"`            // Human-readable explanation of drift status
}

// NewDecisionLogEntry creates a DecisionLogEntry from policy evaluation results.
func NewDecisionLogEntry(req *policy.Request, decision policy.Decision, policyPath string) DecisionLogEntry <span class="cov10" title="30">{
        return DecisionLogEntry{
                Timestamp:  iso8601.Format(time.Now()),
                User:       req.User,
                Profile:    req.Profile,
                Effect:     string(decision.Effect),
                Rule:       decision.MatchedRule,
                RuleIndex:  decision.RuleIndex,
                Reason:     decision.Reason,
                PolicyPath: policyPath,
        }
}</span>

// CredentialIssuanceFields contains fields populated when credentials are issued.
type CredentialIssuanceFields struct {
        RequestID         string
        SourceIdentity    string // Full sentinel:user:request-id string
        RoleARN           string
        SessionDuration   time.Duration
        ApprovedRequestID string // ID of approved request that overrode policy deny (empty if policy allowed)
        BreakGlassEventID string // ID of break-glass event that overrode policy deny (empty if not break-glass)
        DriftStatus       string // Drift check result: "ok", "partial", "none", "unknown"
        DriftMessage      string // Human-readable explanation of drift status
}

// NewEnhancedDecisionLogEntry creates a DecisionLogEntry with credential issuance details.
// Use this when credentials are being issued (allow decisions with credential context).
func NewEnhancedDecisionLogEntry(req *policy.Request, decision policy.Decision, policyPath string, creds *CredentialIssuanceFields) DecisionLogEntry <span class="cov8" title="17">{
        entry := NewDecisionLogEntry(req, decision, policyPath)

        if creds != nil </span><span class="cov7" title="14">{
                entry.RequestID = creds.RequestID
                entry.SourceIdentity = creds.SourceIdentity
                entry.RoleARN = creds.RoleARN
                if creds.SessionDuration &gt; 0 </span><span class="cov4" title="4">{
                        entry.SessionDuration = int(creds.SessionDuration.Seconds())
                }</span>
                <span class="cov7" title="14">entry.ApprovedRequestID = creds.ApprovedRequestID
                entry.BreakGlassEventID = creds.BreakGlassEventID
                entry.DriftStatus = creds.DriftStatus
                entry.DriftMessage = creds.DriftMessage</span>
        }

        <span class="cov8" title="17">return entry</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package logging provides structured logging for access decisions.
// It defines a Logger interface and implementations for JSON output
// and no-op logging.
package logging

import (
        "encoding/json"
        "io"
)

// Logger defines the interface for logging access decisions, approval events,
// and break-glass emergency access events.
type Logger interface {
        // LogDecision logs a decision entry.
        LogDecision(entry DecisionLogEntry)

        // LogApproval logs an approval workflow event.
        LogApproval(entry ApprovalLogEntry)

        // LogBreakGlass logs a break-glass emergency access event.
        LogBreakGlass(entry BreakGlassLogEntry)
}

// JSONLogger implements Logger with JSON Lines output.
// Each entry is written as a single line of JSON suitable for log aggregation.
type JSONLogger struct {
        writer io.Writer
}

// NewJSONLogger creates a new JSONLogger that writes to the given writer.
func NewJSONLogger(w io.Writer) *JSONLogger <span class="cov5" title="10">{
        return &amp;JSONLogger{writer: w}
}</span>

// LogDecision writes the entry as a single line of JSON.
func (l *JSONLogger) LogDecision(entry DecisionLogEntry) <span class="cov3" title="4">{
        data, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="4">l.writer.Write(data)
        l.writer.Write([]byte("\n"))</span>
}

// LogApproval writes the approval entry as a single line of JSON.
func (l *JSONLogger) LogApproval(entry ApprovalLogEntry) <span class="cov3" title="4">{
        data, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov3" title="4">l.writer.Write(data)
        l.writer.Write([]byte("\n"))</span>
}

// LogBreakGlass writes the break-glass entry as a single line of JSON.
func (l *JSONLogger) LogBreakGlass(entry BreakGlassLogEntry) <span class="cov4" title="5">{
        data, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov4" title="5">l.writer.Write(data)
        l.writer.Write([]byte("\n"))</span>
}

// NopLogger implements Logger but discards all entries.
// Useful for testing or when logging is disabled.
type NopLogger struct{}

// NewNopLogger creates a new NopLogger that discards all entries.
func NewNopLogger() *NopLogger <span class="cov4" title="6">{
        return &amp;NopLogger{}
}</span>

// LogDecision discards the entry.
func (l *NopLogger) LogDecision(entry DecisionLogEntry) {<span class="cov10" title="101">
        // Intentionally empty - discards all entries
}</span>

// LogApproval discards the approval entry.
func (l *NopLogger) LogApproval(entry ApprovalLogEntry) {<span class="cov10" title="101">
        // Intentionally empty - discards all entries
}</span>

// LogBreakGlass discards the break-glass entry.
func (l *NopLogger) LogBreakGlass(entry BreakGlassLogEntry) {<span class="cov10" title="101">
        // Intentionally empty - discards all entries
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package main

import (
        "os"

        "github.com/alecthomas/kingpin/v2"
        "github.com/byteness/aws-vault/v7/cli"
)

// Version is provided at compile time
var Version = "dev"

func main() <span class="cov0" title="0">{
        app := kingpin.New("aws-vault", "A vault for securely storing and accessing AWS credentials in development environments.")
        app.Version(Version)

        a := cli.ConfigureGlobals(app)
        cli.ConfigureAddCommand(app, a)
        cli.ConfigureRemoveCommand(app, a)
        cli.ConfigureListCommand(app, a)
        cli.ConfigureRotateCommand(app, a)
        cli.ConfigureExecCommand(app, a)
        cli.ConfigureExportCommand(app, a)
        cli.ConfigureClearCommand(app, a)
        cli.ConfigureLoginCommand(app, a)
        cli.ConfigureProxyCommand(app)

        kingpin.MustParse(app.Parse(os.Args[1:]))
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package notification

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sns"
        "github.com/aws/aws-sdk-go-v2/service/sns/types"
)

// BreakGlassNotifier defines the interface for break-glass notification delivery.
// Implementations send notifications to specific backends when break-glass events occur.
type BreakGlassNotifier interface {
        // NotifyBreakGlass sends a notification for the given break-glass event.
        // Returns an error if delivery fails.
        NotifyBreakGlass(ctx context.Context, event *BreakGlassEvent) error
}

// SNSBreakGlassNotifier publishes break-glass notification events to an AWS SNS topic.
// It implements the BreakGlassNotifier interface for AWS-native notification delivery.
//
// Messages are published as JSON with a MessageAttribute "event_type" for
// subscription filtering. Subscribers can filter by event type (e.g., only
// receive "breakglass.invoked" events).
type SNSBreakGlassNotifier struct {
        client   snsAPI
        topicARN string
}

// NewSNSBreakGlassNotifier creates a new SNSBreakGlassNotifier using the provided AWS configuration.
// The topicARN specifies the SNS topic to publish events to.
func NewSNSBreakGlassNotifier(cfg aws.Config, topicARN string) *SNSBreakGlassNotifier <span class="cov0" title="0">{
        return &amp;SNSBreakGlassNotifier{
                client:   sns.NewFromConfig(cfg),
                topicARN: topicARN,
        }
}</span>

// newSNSBreakGlassNotifierWithClient creates an SNSBreakGlassNotifier with a custom client.
// This is primarily used for testing with mock clients.
func newSNSBreakGlassNotifierWithClient(client snsAPI, topicARN string) *SNSBreakGlassNotifier <span class="cov3" title="2">{
        return &amp;SNSBreakGlassNotifier{
                client:   client,
                topicARN: topicARN,
        }
}</span>

// NotifyBreakGlass publishes the break-glass event to the configured SNS topic.
// The event is serialized as JSON and includes a "event_type" message attribute
// for subscription filtering.
func (n *SNSBreakGlassNotifier) NotifyBreakGlass(ctx context.Context, event *BreakGlassEvent) error <span class="cov3" title="2">{
        // Marshal event to JSON
        payload, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal event: %w", err)
        }</span>

        // Publish to SNS with event_type attribute for filtering
        <span class="cov3" title="2">_, err = n.client.Publish(ctx, &amp;sns.PublishInput{
                TopicArn: aws.String(n.topicARN),
                Message:  aws.String(string(payload)),
                MessageAttributes: map[string]types.MessageAttributeValue{
                        "event_type": {
                                DataType:    aws.String("String"),
                                StringValue: aws.String(event.Type.String()),
                        },
                },
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("sns publish: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// WebhookBreakGlassNotifier sends break-glass notifications to an HTTP webhook endpoint.
// It implements the BreakGlassNotifier interface.
type WebhookBreakGlassNotifier struct {
        url        string
        client     *http.Client
        maxRetries int
        retryDelay time.Duration
}

// NewWebhookBreakGlassNotifier creates a new WebhookBreakGlassNotifier with the given configuration.
// Returns an error if the URL is empty or invalid.
func NewWebhookBreakGlassNotifier(config WebhookConfig) (*WebhookBreakGlassNotifier, error) <span class="cov9" title="9">{
        if config.URL == "" </span><span class="cov1" title="1">{
                return nil, errors.New("webhook URL is required")
        }</span>

        // Validate URL format
        <span class="cov9" title="8">if _, err := url.ParseRequestURI(config.URL); err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("invalid webhook URL: %w", err)
        }</span>

        // Apply defaults for zero values
        <span class="cov8" title="6">timeout := config.TimeoutSeconds
        if timeout == 0 </span><span class="cov8" title="6">{
                timeout = 10
        }</span>

        <span class="cov8" title="6">maxRetries := config.MaxRetries
        if maxRetries == 0 </span><span class="cov3" title="2">{
                maxRetries = 3
        }</span>

        <span class="cov8" title="6">retryDelay := config.RetryDelaySeconds
        if retryDelay == 0 </span><span class="cov8" title="6">{
                retryDelay = 1
        }</span>

        <span class="cov8" title="6">return &amp;WebhookBreakGlassNotifier{
                url: config.URL,
                client: &amp;http.Client{
                        Timeout: time.Duration(timeout) * time.Second,
                },
                maxRetries: maxRetries,
                retryDelay: time.Duration(retryDelay) * time.Second,
        }, nil</span>
}

// NotifyBreakGlass sends the break-glass event to the configured webhook URL.
// It retries on 5xx errors or network errors with exponential backoff.
// Returns an error if all retries are exhausted.
func (w *WebhookBreakGlassNotifier) NotifyBreakGlass(ctx context.Context, event *BreakGlassEvent) error <span class="cov7" title="5">{
        body, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event: %w", err)
        }</span>

        <span class="cov7" title="5">var lastErr error
        for attempt := 0; attempt &lt;= w.maxRetries; attempt++ </span><span class="cov10" title="10">{
                // Check context before each attempt
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Wait before retry (skip on first attempt)
                <span class="cov10" title="10">if attempt &gt; 0 </span><span class="cov7" title="5">{
                        delay := w.retryDelay * (1 &lt;&lt; (attempt - 1)) // exponential backoff
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov6" title="4"></span>
                        }
                }

                // Create request
                <span class="cov9" title="9">req, err := http.NewRequestWithContext(ctx, http.MethodPost, w.url, bytes.NewReader(body))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create request: %w", err)
                }</span>

                <span class="cov9" title="9">req.Header.Set("Content-Type", "application/json")
                req.Header.Set("X-Sentinel-Event", string(event.Type))

                // Execute request
                resp, err := w.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("request failed: %w", err)
                        continue</span> // Retry on network errors
                }
                <span class="cov9" title="9">resp.Body.Close()

                // Success on 2xx
                if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300 </span><span class="cov3" title="2">{
                        return nil
                }</span>

                // Retry on 5xx server errors
                <span class="cov8" title="7">if resp.StatusCode &gt;= 500 </span><span class="cov8" title="6">{
                        lastErr = fmt.Errorf("server error: status %d", resp.StatusCode)
                        continue</span>
                }

                // Don't retry on 4xx client errors
                <span class="cov1" title="1">return fmt.Errorf("webhook request failed: status %d", resp.StatusCode)</span>
        }

        <span class="cov1" title="1">return fmt.Errorf("webhook delivery failed after %d retries: %w", w.maxRetries, lastErr)</span>
}

// MultiBreakGlassNotifier composes multiple break-glass notifiers and sends to all of them.
// It implements the BreakGlassNotifier interface for consistent usage.
type MultiBreakGlassNotifier struct {
        notifiers []BreakGlassNotifier
}

// NewMultiBreakGlassNotifier creates a new MultiBreakGlassNotifier with the given notifiers.
// Nil notifiers are filtered out for convenience.
func NewMultiBreakGlassNotifier(notifiers ...BreakGlassNotifier) *MultiBreakGlassNotifier <span class="cov6" title="4">{
        filtered := make([]BreakGlassNotifier, 0, len(notifiers))
        for _, n := range notifiers </span><span class="cov9" title="9">{
                if n != nil </span><span class="cov8" title="7">{
                        filtered = append(filtered, n)
                }</span>
        }
        <span class="cov6" title="4">return &amp;MultiBreakGlassNotifier{notifiers: filtered}</span>
}

// NotifyBreakGlass sends the break-glass event to all configured notifiers.
// Returns a joined error if any notifiers fail.
func (m *MultiBreakGlassNotifier) NotifyBreakGlass(ctx context.Context, event *BreakGlassEvent) error <span class="cov6" title="4">{
        var errs []error
        for _, n := range m.notifiers </span><span class="cov8" title="7">{
                if err := n.NotifyBreakGlass(ctx, event); err != nil </span><span class="cov5" title="3">{
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov6" title="4">return errors.Join(errs...)</span>
}

// NoopBreakGlassNotifier is a no-op break-glass notifier that does nothing.
// Useful for testing or when notifications are disabled.
type NoopBreakGlassNotifier struct{}

// NotifyBreakGlass does nothing and returns nil.
func (n *NoopBreakGlassNotifier) NotifyBreakGlass(_ context.Context, _ *BreakGlassEvent) error <span class="cov1" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package notification provides event types for Sentinel's notification system.
// This file contains break-glass notification event types for security alerts
// when emergency access is invoked, closed, or expires.

package notification

import (
        "time"

        "github.com/byteness/aws-vault/v7/breakglass"
)

// BreakGlassEventType represents the type of break-glass notification event.
// Events correspond to break-glass lifecycle state changes.
type BreakGlassEventType string

const (
        // EventBreakGlassInvoked is emitted when break-glass emergency access is invoked.
        EventBreakGlassInvoked BreakGlassEventType = "breakglass.invoked"
        // EventBreakGlassClosed is emitted when break-glass access is manually closed.
        EventBreakGlassClosed BreakGlassEventType = "breakglass.closed"
        // EventBreakGlassExpired is emitted when break-glass access expires due to TTL.
        EventBreakGlassExpired BreakGlassEventType = "breakglass.expired"
)

// IsValid returns true if the BreakGlassEventType is a known value.
func (t BreakGlassEventType) IsValid() bool <span class="cov7" title="7">{
        switch t </span>{
        case EventBreakGlassInvoked, EventBreakGlassClosed, EventBreakGlassExpired:<span class="cov4" title="3">
                return true</span>
        }
        <span class="cov5" title="4">return false</span>
}

// String returns the string representation of the BreakGlassEventType.
func (t BreakGlassEventType) String() string <span class="cov6" title="5">{
        return string(t)
}</span>

// BreakGlassEvent represents a notification event triggered by a break-glass state change.
// It contains the event type, the break-glass event that triggered it, when it occurred,
// and who triggered the event.
type BreakGlassEvent struct {
        // Type is the event type (invoked, closed, expired).
        Type BreakGlassEventType

        // BreakGlass is the break-glass event that triggered this notification.
        BreakGlass *breakglass.BreakGlassEvent

        // Timestamp is when the event occurred.
        Timestamp time.Time

        // Actor is who triggered the event:
        //   - invoker username for invoked
        //   - closer username for closed
        //   - "system" for expired
        Actor string
}

// NewBreakGlassEvent creates a new break-glass notification event.
// The timestamp is set to the current time.
func NewBreakGlassEvent(eventType BreakGlassEventType, bg *breakglass.BreakGlassEvent, actor string) *BreakGlassEvent <span class="cov10" title="16">{
        return &amp;BreakGlassEvent{
                Type:       eventType,
                BreakGlass: bg,
                Timestamp:  time.Now(),
                Actor:      actor,
        }
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package notification

import (
        "context"
        "errors"
)

// Notifier defines the interface for notification delivery.
// Implementations send notifications to specific backends (Slack, email, webhook, etc.).
type Notifier interface {
        // Notify sends a notification for the given event.
        // Returns an error if delivery fails.
        Notify(ctx context.Context, event *Event) error
}

// MultiNotifier composes multiple notifiers and sends to all of them.
// It implements the Notifier interface for consistent usage.
type MultiNotifier struct {
        notifiers []Notifier
}

// NewMultiNotifier creates a new MultiNotifier with the given notifiers.
// Nil notifiers are filtered out for convenience.
func NewMultiNotifier(notifiers ...Notifier) *MultiNotifier <span class="cov4" title="6">{
        filtered := make([]Notifier, 0, len(notifiers))
        for _, n := range notifiers </span><span class="cov5" title="10">{
                if n != nil </span><span class="cov5" title="8">{
                        filtered = append(filtered, n)
                }</span>
        }
        <span class="cov4" title="6">return &amp;MultiNotifier{notifiers: filtered}</span>
}

// Notify sends the event to all configured notifiers.
// Returns a joined error if any notifiers fail.
func (m *MultiNotifier) Notify(ctx context.Context, event *Event) error <span class="cov4" title="6">{
        var errs []error
        for _, n := range m.notifiers </span><span class="cov5" title="8">{
                if err := n.Notify(ctx, event); err != nil </span><span class="cov3" title="3">{
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov4" title="6">return errors.Join(errs...)</span>
}

// NoopNotifier is a no-op notifier that does nothing.
// Useful for testing or when notifications are disabled.
type NoopNotifier struct{}

// Notify does nothing and returns nil.
func (n *NoopNotifier) Notify(_ context.Context, _ *Event) error <span class="cov10" title="102">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package notification

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sns"
        "github.com/aws/aws-sdk-go-v2/service/sns/types"
)

// snsAPI defines the SNS operations used by SNSNotifier.
// This interface enables testing with mock implementations.
type snsAPI interface {
        Publish(ctx context.Context, params *sns.PublishInput, optFns ...func(*sns.Options)) (*sns.PublishOutput, error)
}

// SNSNotifier publishes notification events to an AWS SNS topic.
// It implements the Notifier interface for AWS-native notification delivery.
//
// Messages are published as JSON with a MessageAttribute "event_type" for
// subscription filtering. Subscribers can filter by event type (e.g., only
// receive "request.approved" events).
type SNSNotifier struct {
        client   snsAPI
        topicARN string
}

// NewSNSNotifier creates a new SNSNotifier using the provided AWS configuration.
// The topicARN specifies the SNS topic to publish events to.
func NewSNSNotifier(cfg aws.Config, topicARN string) *SNSNotifier <span class="cov0" title="0">{
        return &amp;SNSNotifier{
                client:   sns.NewFromConfig(cfg),
                topicARN: topicARN,
        }
}</span>

// newSNSNotifierWithClient creates an SNSNotifier with a custom client.
// This is primarily used for testing with mock clients.
func newSNSNotifierWithClient(client snsAPI, topicARN string) *SNSNotifier <span class="cov10" title="2">{
        return &amp;SNSNotifier{
                client:   client,
                topicARN: topicARN,
        }
}</span>

// Notify publishes the event to the configured SNS topic.
// The event is serialized as JSON and includes a "event_type" message attribute
// for subscription filtering.
func (n *SNSNotifier) Notify(ctx context.Context, event *Event) error <span class="cov10" title="2">{
        // Marshal event to JSON
        payload, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal event: %w", err)
        }</span>

        // Publish to SNS with event_type attribute for filtering
        <span class="cov10" title="2">_, err = n.client.Publish(ctx, &amp;sns.PublishInput{
                TopicArn: aws.String(n.topicARN),
                Message:  aws.String(string(payload)),
                MessageAttributes: map[string]types.MessageAttributeValue{
                        "event_type": {
                                DataType:    aws.String("String"),
                                StringValue: aws.String(event.Type.String()),
                        },
                },
        })
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("sns publish: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package notification

import (
        "context"
        "log"

        "github.com/byteness/aws-vault/v7/request"
)

// NotifyStore wraps a request.Store and fires notifications on state transitions.
// It implements the request.Store interface, delegating operations to the wrapped
// store and firing appropriate events after successful mutations.
type NotifyStore struct {
        store    request.Store
        notifier Notifier
}

// NewNotifyStore creates a new NotifyStore wrapping the given store.
// If notifier is nil, a NoopNotifier is used (no notifications fired).
func NewNotifyStore(store request.Store, notifier Notifier) *NotifyStore <span class="cov10" title="12">{
        if notifier == nil </span><span class="cov1" title="1">{
                notifier = &amp;NoopNotifier{}
        }</span>
        <span class="cov10" title="12">return &amp;NotifyStore{
                store:    store,
                notifier: notifier,
        }</span>
}

// Create stores a new request and fires EventRequestCreated on success.
// The actor for the event is the request's Requester.
func (s *NotifyStore) Create(ctx context.Context, req *request.Request) error <span class="cov6" title="4">{
        if err := s.store.Create(ctx, req); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Fire notification asynchronously
        <span class="cov4" title="3">go s.notify(ctx, EventRequestCreated, req, req.Requester)

        return nil</span>
}

// Get retrieves a request by ID. No notification is fired.
func (s *NotifyStore) Get(ctx context.Context, id string) (*request.Request, error) <span class="cov1" title="1">{
        return s.store.Get(ctx, id)
}</span>

// Update modifies an existing request and fires notifications on state transitions.
// It detects status changes and fires the appropriate event type:
//   - pending -&gt; approved: EventRequestApproved (actor: Approver)
//   - pending -&gt; denied: EventRequestDenied (actor: Approver)
//   - pending -&gt; cancelled: EventRequestCancelled (actor: Requester)
//   - pending -&gt; expired: EventRequestExpired (actor: "system")
func (s *NotifyStore) Update(ctx context.Context, req *request.Request) error <span class="cov7" title="6">{
        // Get current request to detect status transition
        oldReq, err := s.store.Get(ctx, req.ID)
        if err != nil </span><span class="cov0" title="0">{
                // If we can't get the old request, still try the update
                // but we won't be able to detect the transition
                return s.store.Update(ctx, req)
        }</span>

        // Perform the update
        <span class="cov7" title="6">if err := s.store.Update(ctx, req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check for status transition and fire notification
        <span class="cov7" title="6">if oldReq.Status == request.StatusPending &amp;&amp; req.Status != request.StatusPending </span><span class="cov6" title="4">{
                var eventType EventType
                var actor string

                switch req.Status </span>{
                case request.StatusApproved:<span class="cov1" title="1">
                        eventType = EventRequestApproved
                        actor = req.Approver</span>
                case request.StatusDenied:<span class="cov1" title="1">
                        eventType = EventRequestDenied
                        actor = req.Approver</span>
                case request.StatusCancelled:<span class="cov1" title="1">
                        eventType = EventRequestCancelled
                        actor = req.Requester</span>
                case request.StatusExpired:<span class="cov1" title="1">
                        eventType = EventRequestExpired
                        actor = "system"</span>
                }

                <span class="cov6" title="4">if eventType != "" </span><span class="cov6" title="4">{
                        go s.notify(ctx, eventType, req, actor)
                }</span>
        }

        <span class="cov7" title="6">return nil</span>
}

// Delete removes a request by ID. No notification is fired.
func (s *NotifyStore) Delete(ctx context.Context, id string) error <span class="cov1" title="1">{
        return s.store.Delete(ctx, id)
}</span>

// ListByRequester returns all requests from a specific user.
func (s *NotifyStore) ListByRequester(ctx context.Context, requester string, limit int) ([]*request.Request, error) <span class="cov0" title="0">{
        return s.store.ListByRequester(ctx, requester, limit)
}</span>

// ListByStatus returns all requests with a specific status.
func (s *NotifyStore) ListByStatus(ctx context.Context, status request.RequestStatus, limit int) ([]*request.Request, error) <span class="cov0" title="0">{
        return s.store.ListByStatus(ctx, status, limit)
}</span>

// ListByProfile returns all requests for a specific AWS profile.
func (s *NotifyStore) ListByProfile(ctx context.Context, profile string, limit int) ([]*request.Request, error) <span class="cov0" title="0">{
        return s.store.ListByProfile(ctx, profile, limit)
}</span>

// notify sends a notification asynchronously.
// Errors are logged but do not fail the operation.
func (s *NotifyStore) notify(ctx context.Context, eventType EventType, req *request.Request, actor string) <span class="cov8" title="7">{
        event := NewEvent(eventType, req, actor)
        if err := s.notifier.Notify(ctx, event); err != nil </span><span class="cov1" title="1">{
                log.Printf("notification error (%s): %v", eventType, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Package notification provides event types and interfaces for Sentinel's
// notification system. It enables pluggable notification delivery on request
// lifecycle events such as creation, approval, denial, expiration, and cancellation.
//
// # Event Types
//
// Events are emitted when request state changes:
//   - request.created: A new access request was submitted
//   - request.approved: A request was approved by an approver
//   - request.denied: A request was denied by an approver
//   - request.expired: A pending request timed out
//   - request.cancelled: A request was cancelled by the requester
//
// # Notification Delivery
//
// The Notifier interface allows pluggable notification backends (Slack, email,
// webhooks, etc.). MultiNotifier composes multiple backends for fanout delivery.
package notification

import (
        "time"

        "github.com/byteness/aws-vault/v7/request"
)

// EventType represents the type of notification event.
// Events correspond to request lifecycle state changes.
type EventType string

const (
        // EventRequestCreated is emitted when a new access request is submitted.
        EventRequestCreated EventType = "request.created"
        // EventRequestApproved is emitted when a request is approved by an approver.
        EventRequestApproved EventType = "request.approved"
        // EventRequestDenied is emitted when a request is denied by an approver.
        EventRequestDenied EventType = "request.denied"
        // EventRequestExpired is emitted when a pending request times out.
        EventRequestExpired EventType = "request.expired"
        // EventRequestCancelled is emitted when a request is cancelled by the requester.
        EventRequestCancelled EventType = "request.cancelled"
)

// IsValid returns true if the EventType is a known value.
func (t EventType) IsValid() bool <span class="cov4" title="8">{
        switch t </span>{
        case EventRequestCreated, EventRequestApproved, EventRequestDenied,
                EventRequestExpired, EventRequestCancelled:<span class="cov4" title="5">
                return true</span>
        }
        <span class="cov3" title="3">return false</span>
}

// String returns the string representation of the EventType.
func (t EventType) String() string <span class="cov4" title="8">{
        return string(t)
}</span>

// Event represents a notification event triggered by a request state change.
// It contains the event type, the request that triggered it, when it occurred,
// and who triggered the event.
type Event struct {
        // Type is the event type (created, approved, denied, expired, cancelled).
        Type EventType

        // Request is the request that triggered this event.
        Request *request.Request

        // Timestamp is when the event occurred.
        Timestamp time.Time

        // Actor is who triggered the event:
        //   - requester username for created/cancelled
        //   - approver username for approved/denied
        //   - "system" for expired
        Actor string
}

// NewEvent creates a new notification event.
// The timestamp is set to the current time.
func NewEvent(eventType EventType, req *request.Request, actor string) *Event <span class="cov10" title="117">{
        return &amp;Event{
                Type:      eventType,
                Request:   req,
                Timestamp: time.Now(),
                Actor:     actor,
        }
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package notification

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "time"
)

// WebhookConfig contains configuration for the webhook notifier.
type WebhookConfig struct {
        // URL is the webhook endpoint to POST events to.
        URL string

        // TimeoutSeconds is the HTTP client timeout. Default: 10.
        TimeoutSeconds int

        // MaxRetries is the maximum number of retry attempts. Default: 3.
        MaxRetries int

        // RetryDelaySeconds is the base delay between retries. Default: 1.
        // Uses exponential backoff: delay * 2^attempt.
        RetryDelaySeconds int
}

// WebhookNotifier sends notifications to an HTTP webhook endpoint.
// It implements the Notifier interface.
type WebhookNotifier struct {
        url        string
        client     *http.Client
        maxRetries int
        retryDelay time.Duration
}

// NewWebhookNotifier creates a new WebhookNotifier with the given configuration.
// Returns an error if the URL is empty or invalid.
func NewWebhookNotifier(config WebhookConfig) (*WebhookNotifier, error) <span class="cov9" title="9">{
        if config.URL == "" </span><span class="cov1" title="1">{
                return nil, errors.New("webhook URL is required")
        }</span>

        // Validate URL format
        <span class="cov9" title="8">if _, err := url.ParseRequestURI(config.URL); err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("invalid webhook URL: %w", err)
        }</span>

        // Apply defaults for zero values
        <span class="cov8" title="6">timeout := config.TimeoutSeconds
        if timeout == 0 </span><span class="cov8" title="6">{
                timeout = 10
        }</span>

        <span class="cov8" title="6">maxRetries := config.MaxRetries
        if maxRetries == 0 </span><span class="cov3" title="2">{
                maxRetries = 3
        }</span>

        <span class="cov8" title="6">retryDelay := config.RetryDelaySeconds
        if retryDelay == 0 </span><span class="cov8" title="6">{
                retryDelay = 1
        }</span>

        <span class="cov8" title="6">return &amp;WebhookNotifier{
                url: config.URL,
                client: &amp;http.Client{
                        Timeout: time.Duration(timeout) * time.Second,
                },
                maxRetries: maxRetries,
                retryDelay: time.Duration(retryDelay) * time.Second,
        }, nil</span>
}

// Notify sends the event to the configured webhook URL.
// It retries on 5xx errors or network errors with exponential backoff.
// Returns an error if all retries are exhausted.
func (w *WebhookNotifier) Notify(ctx context.Context, event *Event) error <span class="cov7" title="5">{
        body, err := json.Marshal(event)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event: %w", err)
        }</span>

        <span class="cov7" title="5">var lastErr error
        for attempt := 0; attempt &lt;= w.maxRetries; attempt++ </span><span class="cov10" title="10">{
                // Check context before each attempt
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Wait before retry (skip on first attempt)
                <span class="cov10" title="10">if attempt &gt; 0 </span><span class="cov7" title="5">{
                        delay := w.retryDelay * (1 &lt;&lt; (attempt - 1)) // exponential backoff
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov6" title="4"></span>
                        }
                }

                // Create request
                <span class="cov9" title="9">req, err := http.NewRequestWithContext(ctx, http.MethodPost, w.url, bytes.NewReader(body))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create request: %w", err)
                }</span>

                <span class="cov9" title="9">req.Header.Set("Content-Type", "application/json")
                req.Header.Set("X-Sentinel-Event", string(event.Type))

                // Execute request
                resp, err := w.client.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = fmt.Errorf("request failed: %w", err)
                        continue</span> // Retry on network errors
                }
                <span class="cov9" title="9">resp.Body.Close()

                // Success on 2xx
                if resp.StatusCode &gt;= 200 &amp;&amp; resp.StatusCode &lt; 300 </span><span class="cov3" title="2">{
                        return nil
                }</span>

                // Retry on 5xx server errors
                <span class="cov8" title="7">if resp.StatusCode &gt;= 500 </span><span class="cov8" title="6">{
                        lastErr = fmt.Errorf("server error: status %d", resp.StatusCode)
                        continue</span>
                }

                // Don't retry on 4xx client errors
                <span class="cov1" title="1">return fmt.Errorf("webhook request failed: status %d", resp.StatusCode)</span>
        }

        <span class="cov1" title="1">return fmt.Errorf("webhook delivery failed after %d retries: %w", w.maxRetries, lastErr)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Package policy defines Sentinel's access control policy schema.
//
// # Approval Workflow
//
// Access policy rules determine if a profile needs approval (effect: require_approval).
// Approval policy rules determine who can approve requests and auto-approve conditions.
//
// This separation allows:
//   - Access policy to be simple (allow/deny/require_approval)
//   - Approval routing to be complex (different approvers per profile, time-based auto-approve)
//
// When a request matches a rule with effect "require_approval":
//  1. Request is created with pending status
//  2. Approval policy is consulted to determine approvers
//  3. If auto-approve conditions match, request is automatically approved
//  4. Otherwise, designated approvers must explicitly approve
package policy

import (
        "fmt"
        "time"

        "github.com/byteness/aws-vault/v7/request"
)

// ApprovalPolicy defines approval routing and auto-approve rules.
// It contains a version identifier and a list of approval rules that determine
// who can approve requests for specific profiles.
type ApprovalPolicy struct {
        Version string         `yaml:"version" json:"version"`
        Rules   []ApprovalRule `yaml:"rules" json:"rules"`
}

// ApprovalRule defines who can approve requests for matching profiles.
// Rules are evaluated to find designated approvers and auto-approve conditions.
type ApprovalRule struct {
        // Name identifies this approval rule for logging and debugging.
        Name string `yaml:"name" json:"name"`

        // Profiles lists which AWS profiles this rule applies to.
        // If empty, the rule applies to all profiles requiring approval.
        Profiles []string `yaml:"profiles,omitempty" json:"profiles,omitempty"`

        // Approvers lists usernames who can approve requests matching this rule.
        Approvers []string `yaml:"approvers" json:"approvers"`

        // AutoApprove defines conditions for automatic approval.
        // If nil, requests require explicit approval from designated approvers.
        AutoApprove *AutoApproveCondition `yaml:"auto_approve,omitempty" json:"auto_approve,omitempty"`
}

// AutoApproveCondition defines when requests can be auto-approved.
// If conditions match, the request is automatically approved without
// requiring an explicit approver action.
type AutoApproveCondition struct {
        // Users who can self-approve (empty = no self-approval).
        // When a user in this list makes a request, it can be auto-approved
        // if other conditions (Time, MaxDuration) are also satisfied.
        Users []string `yaml:"users,omitempty" json:"users,omitempty"`

        // Time window when auto-approve is allowed (nil = any time).
        // Useful for allowing self-approval only during business hours.
        Time *TimeWindow `yaml:"time,omitempty" json:"time,omitempty"`

        // MaxDuration caps the duration for auto-approved requests.
        // Requests for longer durations require explicit approval.
        // Zero means no duration cap for auto-approval.
        MaxDuration time.Duration `yaml:"max_duration,omitempty" json:"max_duration,omitempty"`
}

// Validate checks if the ApprovalPolicy is semantically correct.
// It verifies at least one rule exists and all rules are valid.
func (p *ApprovalPolicy) Validate() error <span class="cov10" title="13">{
        if len(p.Rules) == 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("approval policy must have at least one rule")
        }</span>

        <span class="cov9" title="11">for i, rule := range p.Rules </span><span class="cov9" title="12">{
                if err := rule.validate(i); err != nil </span><span class="cov7" title="7">{
                        return err
                }</span>
        }

        <span class="cov5" title="4">return nil</span>
}

// validate checks if an ApprovalRule is semantically correct.
// It verifies name is present, at least one approver exists,
// and any auto-approve condition is valid.
func (r *ApprovalRule) validate(index int) error <span class="cov9" title="12">{
        if r.Name == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("approval rule at index %d missing name", index)
        }</span>

        <span class="cov9" title="11">if len(r.Approvers) == 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("approval rule '%s' must have at least one approver", r.Name)
        }</span>

        <span class="cov8" title="9">if r.AutoApprove != nil </span><span class="cov7" title="6">{
                if err := r.AutoApprove.validate(r.Name); err != nil </span><span class="cov5" title="4">{
                        return err
                }</span>
        }

        <span class="cov6" title="5">return nil</span>
}

// validate checks if an AutoApproveCondition is semantically correct.
// At least one condition must be set (users, time, or max_duration).
func (a *AutoApproveCondition) validate(ruleName string) error <span class="cov7" title="6">{
        hasCondition := len(a.Users) &gt; 0 || a.Time != nil || a.MaxDuration &gt; 0

        if !hasCondition </span><span class="cov1" title="1">{
                return fmt.Errorf("auto_approve in rule '%s' must have at least one condition (users, time, or max_duration)", ruleName)
        }</span>

        <span class="cov6" title="5">if a.Time != nil </span><span class="cov3" title="2">{
                if err := a.Time.validate(ruleName); err != nil </span><span class="cov3" title="2">{
                        return err
                }</span>
        }

        <span class="cov4" title="3">if a.MaxDuration &gt; 0 &amp;&amp; a.MaxDuration &gt; request.MaxDuration </span><span class="cov1" title="1">{
                return fmt.Errorf("auto_approve max_duration in rule '%s' exceeds maximum of %v", ruleName, request.MaxDuration)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// FindApprovalRule returns the first rule matching the given profile.
// An empty Profiles list in a rule acts as a wildcard and matches any profile.
// Returns nil if no rule matches or if policy is nil.
func FindApprovalRule(policy *ApprovalPolicy, profile string) *ApprovalRule <span class="cov9" title="11">{
        if policy == nil </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov8" title="9">for i := range policy.Rules </span><span class="cov9" title="11">{
                rule := &amp;policy.Rules[i]
                if containsOrEmpty(rule.Profiles, profile) </span><span class="cov7" title="7">{
                        return rule
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// CanApprove returns true if the given approver is authorized to approve
// requests matching this rule.
// Returns false if rule is nil or approver is not in the Approvers list.
func CanApprove(rule *ApprovalRule, approver string) bool <span class="cov6" title="5">{
        if rule == nil </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov5" title="4">for _, a := range rule.Approvers </span><span class="cov6" title="5">{
                if a == approver </span><span class="cov1" title="1">{
                        return true
                }</span>
        }
        <span class="cov4" title="3">return false</span>
}

// ShouldAutoApprove returns true if the request qualifies for automatic approval.
// All configured conditions must match:
//   - requester must be in AutoApprove.Users (or Users is empty = any user)
//   - requestTime must fall within AutoApprove.Time window (or Time is nil = any time)
//   - duration must be &lt;= AutoApprove.MaxDuration (or MaxDuration is 0 = no cap)
//
// Returns false if rule is nil or AutoApprove is nil.
func ShouldAutoApprove(rule *ApprovalRule, requester string, requestTime time.Time, duration time.Duration) bool <span class="cov9" title="12">{
        if rule == nil || rule.AutoApprove == nil </span><span class="cov3" title="2">{
                return false
        }</span>

        <span class="cov9" title="10">auto := rule.AutoApprove

        // Check user condition (empty list = any user can auto-approve)
        if len(auto.Users) &gt; 0 </span><span class="cov8" title="8">{
                found := false
                for _, u := range auto.Users </span><span class="cov8" title="9">{
                        if u == requester </span><span class="cov7" title="7">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="8">if !found </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check time condition (nil = any time)
        <span class="cov8" title="9">if auto.Time != nil </span><span class="cov4" title="3">{
                if !matchesTimeWindow(auto.Time, requestTime) </span><span class="cov3" title="2">{
                        return false
                }</span>
        }

        // Check duration condition (0 = no cap)
        <span class="cov7" title="7">if auto.MaxDuration &gt; 0 &amp;&amp; duration &gt; auto.MaxDuration </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov7" title="6">return true</span>
}

// GetApprovers returns the list of users who can approve requests for
// the given profile. Returns nil if no rule matches the profile.
func GetApprovers(policy *ApprovalPolicy, profile string) []string <span class="cov5" title="4">{
        rule := FindApprovalRule(policy, profile)
        if rule == nil </span><span class="cov3" title="2">{
                return nil
        }</span>
        <span class="cov3" title="2">return rule.Approvers</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package policy provides SSM-based policy loading for Sentinel.
// This file implements a caching layer around policy loaders to reduce
// SSM API calls and latency for repeated credential requests within
// short time windows.
package policy

import (
        "context"
        "sync"
        "time"
)

// PolicyLoader loads policies from a source.
type PolicyLoader interface {
        Load(ctx context.Context, parameterName string) (*Policy, error)
}

// cacheEntry holds a cached policy with its expiration time.
type cacheEntry struct {
        policy *Policy
        expiry time.Time
}

// CachedLoader wraps a PolicyLoader with in-memory TTL-based caching.
// It is safe for concurrent use.
type CachedLoader struct {
        loader PolicyLoader
        mu     sync.RWMutex
        cache  map[string]*cacheEntry
        ttl    time.Duration
}

// NewCachedLoader creates a new CachedLoader that wraps the given loader
// and caches results for the specified TTL duration.
func NewCachedLoader(loader PolicyLoader, ttl time.Duration) *CachedLoader <span class="cov6" title="4">{
        return &amp;CachedLoader{
                loader: loader,
                cache:  make(map[string]*cacheEntry),
                ttl:    ttl,
        }
}</span>

// Load fetches a policy by parameter name, using cached values when available.
// Cache misses and expired entries trigger a fresh load from the underlying loader.
// Errors are not cached.
func (c *CachedLoader) Load(ctx context.Context, parameterName string) (*Policy, error) <span class="cov10" title="9">{
        // Try read lock first for cache hit
        c.mu.RLock()
        if entry, ok := c.cache[parameterName]; ok &amp;&amp; time.Now().Before(entry.expiry) </span><span class="cov3" title="2">{
                c.mu.RUnlock()
                return entry.policy, nil
        }</span>
        <span class="cov8" title="7">c.mu.RUnlock()

        // Cache miss or expired, acquire write lock
        c.mu.Lock()
        defer c.mu.Unlock()

        // Double-check after acquiring write lock (another goroutine may have populated)
        if entry, ok := c.cache[parameterName]; ok &amp;&amp; time.Now().Before(entry.expiry) </span><span class="cov0" title="0">{
                return entry.policy, nil
        }</span>

        // Fetch from underlying loader
        <span class="cov8" title="7">policy, err := c.loader.Load(ctx, parameterName)
        if err != nil </span><span class="cov3" title="2">{
                // Don't cache errors
                return nil, err
        }</span>

        // Cache the result
        <span class="cov7" title="5">c.cache[parameterName] = &amp;cacheEntry{
                policy: policy,
                expiry: time.Now().Add(c.ttl),
        }
        return policy, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package policy

import (
        "fmt"
        "strconv"
        "strings"
        "time"
)

// Request represents a credential request to be evaluated.
type Request struct {
        User    string
        Profile string
        Time    time.Time
}

// Decision represents the outcome of policy evaluation.
type Decision struct {
        Effect      Effect
        MatchedRule string
        Reason      string
        RuleIndex   int        // Position of matched rule in policy (0-based, -1 if no match)
        Conditions  *Condition // Copy of matched rule's conditions for logging (nil for default deny)
        EvaluatedAt time.Time  // Timestamp when evaluation occurred
}

// String returns a human-readable representation of the decision.
func (d Decision) String() string <span class="cov4" title="5">{
        if d.MatchedRule == "" </span><span class="cov2" title="2">{
                return "DENY (no matching rule)"
        }</span>
        <span class="cov3" title="3">return fmt.Sprintf("%s by rule '%s' (index %d)", strings.ToUpper(string(d.Effect)), d.MatchedRule, d.RuleIndex)</span>
}

// defaultDeny returns the default deny decision when no rules match.
func defaultDeny(evaluatedAt time.Time) Decision <span class="cov7" title="21">{
        return Decision{
                Effect:      EffectDeny,
                MatchedRule: "",
                Reason:      "no matching rule",
                RuleIndex:   -1,
                Conditions:  nil,
                EvaluatedAt: evaluatedAt,
        }
}</span>

// Evaluate evaluates a credential request against a policy.
// It returns the decision for the first matching rule, or default deny if no rules match.
func Evaluate(policy *Policy, req *Request) Decision <span class="cov8" title="41">{
        evaluatedAt := time.Now()

        if policy == nil || req == nil </span><span class="cov4" title="5">{
                return defaultDeny(evaluatedAt)
        }</span>

        <span class="cov8" title="36">for i, rule := range policy.Rules </span><span class="cov8" title="33">{
                if matchesConditions(&amp;rule.Conditions, req) </span><span class="cov7" title="20">{
                        // Copy conditions to avoid reference to original
                        conditionsCopy := rule.Conditions
                        return Decision{
                                Effect:      rule.Effect,
                                MatchedRule: rule.Name,
                                Reason:      rule.Reason,
                                RuleIndex:   i,
                                Conditions:  &amp;conditionsCopy,
                                EvaluatedAt: evaluatedAt,
                        }
                }</span>
        }

        <span class="cov6" title="16">return defaultDeny(evaluatedAt)</span>
}

// matchesConditions checks if all conditions in a rule match the request.
// All specified conditions must match for the rule to apply.
// Empty or nil conditions are considered to match any request.
func matchesConditions(c *Condition, req *Request) bool <span class="cov8" title="33">{
        if !matchesProfiles(c.Profiles, req.Profile) </span><span class="cov4" title="5">{
                return false
        }</span>
        <span class="cov8" title="28">if !matchesUsers(c.Users, req.User) </span><span class="cov2" title="2">{
                return false
        }</span>
        <span class="cov7" title="26">if !matchesTimeWindow(c.Time, req.Time) </span><span class="cov4" title="6">{
                return false
        }</span>
        <span class="cov7" title="20">return true</span>
}

// matchesProfiles checks if the request profile matches the condition.
// An empty profiles list matches any profile.
func matchesProfiles(profiles []string, profile string) bool <span class="cov8" title="33">{
        return containsOrEmpty(profiles, profile)
}</span>

// matchesUsers checks if the request user matches the condition.
// An empty users list matches any user.
func matchesUsers(users []string, user string) bool <span class="cov8" title="28">{
        return containsOrEmpty(users, user)
}</span>

// containsOrEmpty returns true if the list is empty or contains the value.
// An empty list matches any value (acts as wildcard).
func containsOrEmpty(list []string, value string) bool <span class="cov10" title="72">{
        if len(list) == 0 </span><span class="cov8" title="39">{
                return true
        }</span>
        <span class="cov8" title="33">for _, item := range list </span><span class="cov8" title="35">{
                if item == value </span><span class="cov7" title="22">{
                        return true
                }</span>
        }
        <span class="cov6" title="11">return false</span>
}

// matchesTimeWindow checks if the request time falls within the time window.
// A nil time window matches any time.
func matchesTimeWindow(tw *TimeWindow, t time.Time) bool <span class="cov8" title="29">{
        if tw == nil </span><span class="cov6" title="11">{
                return true
        }</span>

        // Convert time to the rule's timezone if specified
        <span class="cov7" title="18">evalTime := t
        if tw.Timezone != "" </span><span class="cov4" title="6">{
                loc, err := time.LoadLocation(tw.Timezone)
                if err == nil </span><span class="cov4" title="6">{
                        evalTime = t.In(loc)
                }</span>
        }

        // Check day of week constraint
        <span class="cov7" title="18">if !matchesDays(tw.Days, evalTime) </span><span class="cov3" title="3">{
                return false
        }</span>

        // Check hour range constraint
        <span class="cov6" title="15">if !matchesHours(tw.Hours, evalTime) </span><span class="cov4" title="5">{
                return false
        }</span>

        <span class="cov5" title="10">return true</span>
}

// matchesDays checks if the time falls on one of the specified days.
// An empty days list matches any day.
func matchesDays(days []Weekday, t time.Time) bool <span class="cov7" title="18">{
        if len(days) == 0 </span><span class="cov5" title="7">{
                return true
        }</span>

        // Convert Go's time.Weekday to our Weekday type
        <span class="cov6" title="11">goDay := t.Weekday()
        requestDay := goWeekdayToWeekday(goDay)

        for _, d := range days </span><span class="cov7" title="23">{
                if d == requestDay </span><span class="cov5" title="8">{
                        return true
                }</span>
        }
        <span class="cov3" title="3">return false</span>
}

// goWeekdayToWeekday converts Go's time.Weekday to our Weekday type.
func goWeekdayToWeekday(d time.Weekday) Weekday <span class="cov6" title="11">{
        switch d </span>{
        case time.Monday:<span class="cov2" title="2">
                return Monday</span>
        case time.Tuesday:<span class="cov4" title="5">
                return Tuesday</span>
        case time.Wednesday:<span class="cov0" title="0">
                return Wednesday</span>
        case time.Thursday:<span class="cov0" title="0">
                return Thursday</span>
        case time.Friday:<span class="cov0" title="0">
                return Friday</span>
        case time.Saturday:<span class="cov3" title="4">
                return Saturday</span>
        case time.Sunday:<span class="cov0" title="0">
                return Sunday</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// matchesHours checks if the time falls within the hour range.
// A nil hour range matches any time of day.
// The range is inclusive of start and exclusive of end: [start, end).
func matchesHours(hr *HourRange, t time.Time) bool <span class="cov6" title="15">{
        if hr == nil </span><span class="cov3" title="3">{
                return true
        }</span>

        <span class="cov6" title="12">startHour, startMin := parseHourMinute(hr.Start)
        endHour, endMin := parseHourMinute(hr.End)

        reqHour := t.Hour()
        reqMin := t.Minute()

        // Convert to minutes since midnight for easier comparison
        reqMinutes := reqHour*60 + reqMin
        startMinutes := startHour*60 + startMin
        endMinutes := endHour*60 + endMin

        // Check if request time is in range [start, end)
        return reqMinutes &gt;= startMinutes &amp;&amp; reqMinutes &lt; endMinutes</span>
}

// parseHourMinute parses a HH:MM string and returns hour and minute.
// Assumes the format has already been validated by hourFormatRegex.
func parseHourMinute(s string) (hour, minute int) <span class="cov7" title="24">{
        parts := strings.Split(s, ":")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return 0, 0
        }</span>
        <span class="cov7" title="24">hour, _ = strconv.Atoi(parts[0])
        minute, _ = strconv.Atoi(parts[1])
        return hour, minute</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package policy provides SSM-based policy loading for Sentinel.
// Policies are stored in AWS Systems Manager Parameter Store and
// fetched on demand using the Loader type.
package policy

import (
        "context"
        "errors"
        "fmt"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/ssm"
        "github.com/aws/aws-sdk-go-v2/service/ssm/types"
)

// ErrPolicyNotFound is returned when the requested policy parameter
// does not exist in SSM Parameter Store.
var ErrPolicyNotFound = errors.New("policy not found")

// Loader fetches policies from AWS SSM Parameter Store.
type Loader struct {
        client *ssm.Client
}

// NewLoader creates a new Loader using the provided AWS configuration.
// The caller is responsible for providing a properly configured aws.Config
// (typically via config.LoadDefaultConfig).
func NewLoader(cfg aws.Config) *Loader <span class="cov8" title="1">{
        return &amp;Loader{
                client: ssm.NewFromConfig(cfg),
        }
}</span>

// Load fetches a policy from SSM Parameter Store by parameter name.
// It returns ErrPolicyNotFound (wrapped) if the parameter does not exist.
// The parameter is fetched with decryption enabled to support SecureString parameters.
func (l *Loader) Load(ctx context.Context, parameterName string) (*Policy, error) <span class="cov0" title="0">{
        output, err := l.client.GetParameter(ctx, &amp;ssm.GetParameterInput{
                Name:           aws.String(parameterName),
                WithDecryption: aws.Bool(true),
        })
        if err != nil </span><span class="cov0" title="0">{
                var notFound *types.ParameterNotFound
                if errors.As(err, &amp;notFound) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%s: %w", parameterName, ErrPolicyNotFound)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("ssm GetParameter: %w", err)</span>
        }

        <span class="cov0" title="0">return ParsePolicy([]byte(*output.Parameter.Value))</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package policy

import (
        "bytes"
        "fmt"
        "io"

        "gopkg.in/yaml.v3"
)

// ParsePolicy parses a YAML byte slice into a Policy struct.
// It returns an error if the input is empty, contains invalid YAML syntax,
// or is missing required fields like version.
func ParsePolicy(data []byte) (*Policy, error) <span class="cov10" title="7">{
        // Check for empty input
        if len(bytes.TrimSpace(data)) == 0 </span><span class="cov4" title="2">{
                return nil, fmt.Errorf("empty policy")
        }</span>

        <span class="cov8" title="5">var policy Policy
        if err := yaml.Unmarshal(data, &amp;policy); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("yaml: %w", err)
        }</span>

        // Check for required version field
        <span class="cov7" title="4">if policy.Version == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("missing version field")
        }</span>

        <span class="cov6" title="3">return &amp;policy, nil</span>
}

// ParsePolicyFromReader parses a Policy from an io.Reader.
// It reads the entire contents and delegates to ParsePolicy.
func ParsePolicyFromReader(r io.Reader) (*Policy, error) <span class="cov1" title="1">{
        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read policy: %w", err)
        }</span>
        <span class="cov1" title="1">return ParsePolicy(data)</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package policy defines Sentinel's access control policy schema.
// Policies contain rules that determine whether credential requests
// should be allowed or denied based on conditions like user, profile,
// and time constraints.
package policy

// Policy is the top-level container for access rules.
// It contains a version identifier and a list of rules that are
// evaluated in order to determine access decisions.
type Policy struct {
        Version string `yaml:"version" json:"version"`
        Rules   []Rule `yaml:"rules" json:"rules"`
}

// Rule defines a single access control rule.
// Rules are evaluated in order, and the first matching rule determines
// the access decision. Each rule specifies an effect (allow/deny),
// conditions that must match, and an optional reason for logging.
type Rule struct {
        Name       string    `yaml:"name" json:"name"`
        Effect     Effect    `yaml:"effect" json:"effect"`
        Conditions Condition `yaml:"conditions" json:"conditions"`
        Reason     string    `yaml:"reason,omitempty" json:"reason,omitempty"`
}

// Effect is the outcome of a matched rule.
// It can be either "allow" (grant access) or "deny" (reject access).
type Effect string

const (
        // EffectAllow grants access when a rule matches.
        EffectAllow Effect = "allow"
        // EffectDeny rejects access when a rule matches.
        EffectDeny Effect = "deny"
        // EffectRequireApproval triggers approval workflow when a rule matches.
        // Instead of direct credential issuance, the request needs approval.
        EffectRequireApproval Effect = "require_approval"
)

// Condition defines matching criteria for a rule.
// All specified conditions must match for the rule to apply.
// Empty or nil conditions are considered to match any request.
type Condition struct {
        Profiles []string    `yaml:"profiles,omitempty" json:"profiles,omitempty"`
        Users    []string    `yaml:"users,omitempty" json:"users,omitempty"`
        Time     *TimeWindow `yaml:"time,omitempty" json:"time,omitempty"`
}

// TimeWindow restricts when a rule applies.
// It allows limiting access to specific days of the week,
// hours of the day, and timezones.
type TimeWindow struct {
        Days     []Weekday  `yaml:"days,omitempty" json:"days,omitempty"`
        Hours    *HourRange `yaml:"hours,omitempty" json:"hours,omitempty"`
        Timezone string     `yaml:"timezone,omitempty" json:"timezone,omitempty"`
}

// Weekday represents a day of the week.
// Days are specified as lowercase strings (monday, tuesday, etc.).
type Weekday string

const (
        // Monday represents Monday.
        Monday Weekday = "monday"
        // Tuesday represents Tuesday.
        Tuesday Weekday = "tuesday"
        // Wednesday represents Wednesday.
        Wednesday Weekday = "wednesday"
        // Thursday represents Thursday.
        Thursday Weekday = "thursday"
        // Friday represents Friday.
        Friday Weekday = "friday"
        // Saturday represents Saturday.
        Saturday Weekday = "saturday"
        // Sunday represents Sunday.
        Sunday Weekday = "sunday"
)

// HourRange defines a daily time window.
// Start and End times are specified in 24-hour format (HH:MM).
type HourRange struct {
        Start string `yaml:"start" json:"start"` // Format: "HH:MM" (24-hour)
        End   string `yaml:"end" json:"end"`     // Format: "HH:MM" (24-hour)
}

// IsValid returns true if the Effect is a known value.
func (e Effect) IsValid() bool <span class="cov8" title="10">{
        return e == EffectAllow || e == EffectDeny || e == EffectRequireApproval
}</span>

// String returns the string representation of the Effect.
func (e Effect) String() string <span class="cov3" title="2">{
        return string(e)
}</span>

// IsValid returns true if the Weekday is a known value.
func (w Weekday) IsValid() bool <span class="cov10" title="17">{
        switch w </span>{
        case Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday:<span class="cov9" title="14">
                return true</span>
        }
        <span class="cov4" title="3">return false</span>
}

// String returns the string representation of the Weekday.
func (w Weekday) String() string <span class="cov4" title="3">{
        return string(w)
}</span>

// AllWeekdays returns all valid weekday values.
func AllWeekdays() []Weekday <span class="cov0" title="0">{
        return []Weekday{Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package policy

import (
        "fmt"
        "regexp"
        "time"
)

// hourFormatRegex matches HH:MM format (24-hour, two digits each)
var hourFormatRegex = regexp.MustCompile(`^([01][0-9]|2[0-3]):([0-5][0-9])$`)

// Validate checks if the Policy is semantically correct.
// It verifies version is present, at least one rule exists,
// and all rules are valid.
func (p *Policy) Validate() error <span class="cov8" title="11">{
        if len(p.Rules) == 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("policy must have at least one rule")
        }</span>

        <span class="cov7" title="9">for i, rule := range p.Rules </span><span class="cov7" title="9">{
                if err := rule.validate(i); err != nil </span><span class="cov7" title="7">{
                        return err
                }</span>
        }

        <span class="cov3" title="2">return nil</span>
}

// validate checks if a Rule is semantically correct.
// It verifies name is present, effect is valid, and conditions exist.
func (r *Rule) validate(index int) error <span class="cov8" title="12">{
        if r.Name == "" </span><span class="cov3" title="2">{
                return fmt.Errorf("rule at index %d missing name", index)
        }</span>

        <span class="cov8" title="10">if !r.Effect.IsValid() </span><span class="cov3" title="2">{
                return fmt.Errorf("invalid effect '%s' in rule '%s'", r.Effect, r.Name)
        }</span>

        <span class="cov7" title="8">if err := r.Conditions.validate(r.Name); err != nil </span><span class="cov6" title="5">{
                return err
        }</span>

        <span class="cov4" title="3">return nil</span>
}

// validate checks if a Condition has at least one matcher and validates nested structs.
func (c *Condition) validate(ruleName string) error <span class="cov7" title="8">{
        hasCondition := len(c.Profiles) &gt; 0 || len(c.Users) &gt; 0 || c.Time != nil

        if !hasCondition </span><span class="cov1" title="1">{
                return fmt.Errorf("rule '%s' has no conditions", ruleName)
        }</span>

        <span class="cov7" title="7">if c.Time != nil </span><span class="cov6" title="5">{
                if err := c.Time.validate(ruleName); err != nil </span><span class="cov5" title="4">{
                        return err
                }</span>
        }

        <span class="cov4" title="3">return nil</span>
}

// validate checks if a TimeWindow is semantically correct.
// It validates weekdays, timezone, and hour ranges.
func (t *TimeWindow) validate(ruleName string) error <span class="cov8" title="11">{
        for _, day := range t.Days </span><span class="cov10" title="17">{
                if !day.IsValid() </span><span class="cov4" title="3">{
                        return fmt.Errorf("invalid weekday '%s' in rule '%s'", day, ruleName)
                }</span>
        }

        <span class="cov7" title="8">if t.Timezone != "" </span><span class="cov6" title="5">{
                if _, err := time.LoadLocation(t.Timezone); err != nil </span><span class="cov4" title="3">{
                        return fmt.Errorf("invalid timezone '%s'", t.Timezone)
                }</span>
        }

        <span class="cov6" title="5">if t.Hours != nil </span><span class="cov5" title="4">{
                if err := t.Hours.Validate(); err != nil </span><span class="cov3" title="2">{
                        return err
                }</span>
        }

        <span class="cov4" title="3">return nil</span>
}

// Validate checks if an HourRange has valid HH:MM format times.
// Both start and end must be in 24-hour format with two digits each.
func (h *HourRange) Validate() error <span class="cov8" title="11">{
        if err := validateHourFormat(h.Start); err != nil </span><span class="cov6" title="6">{
                return err
        }</span>
        <span class="cov6" title="5">if err := validateHourFormat(h.End); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov5" title="4">return nil</span>
}

// validateHourFormat checks if a time string is in valid HH:MM 24-hour format.
// The regex already validates hour (00-23) and minute (00-59) ranges.
func validateHourFormat(timeStr string) error <span class="cov9" title="16">{
        if !hourFormatRegex.MatchString(timeStr) </span><span class="cov7" title="7">{
                return fmt.Errorf("invalid hour format '%s'", timeStr)
        }</span>
        <span class="cov7" title="9">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package prompt

import (
        "os/exec"
        "strings"
)

func KDialogMfaPrompt(mfaSerial string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("kdialog", "--inputbox", mfaPromptMessage(mfaSerial), "--title", "aws-vault")

        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(out)), nil</span>
}

func init() <span class="cov0" title="0">{
        if _, err := exec.LookPath("kdialog"); err == nil </span><span class="cov0" title="0">{
                Methods["kdialog"] = KDialogMfaPrompt
        }</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package prompt

import (
        "fmt"
        "os/exec"
        "strings"
)

func OSAScriptMfaPrompt(mfaSerial string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("osascript", "-e", fmt.Sprintf(`
                display dialog %q default answer "" buttons {"OK", "Cancel"} default button 1
        text returned of the result
        return result`,
                mfaPromptMessage(mfaSerial)))

        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(out)), nil</span>
}

func init() <span class="cov0" title="0">{
        if _, err := exec.LookPath("osascript"); err == nil </span><span class="cov0" title="0">{
                Methods["osascript"] = OSAScriptMfaPrompt
        }</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package prompt

import (
        "fmt"
        "sort"
)

type Func func(string) (string, error)

var Methods = map[string]Func{}

func Available() []string <span class="cov0" title="0">{
        methods := []string{}
        for k := range Methods </span><span class="cov0" title="0">{
                methods = append(methods, k)
        }</span>
        <span class="cov0" title="0">sort.Strings(methods)
        return methods</span>
}

func Method(s string) Func <span class="cov0" title="0">{
        m, ok := Methods[s]
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Prompt method %q doesn't exist", s))</span>
        }
        <span class="cov0" title="0">return m</span>
}

func mfaPromptMessage(mfaSerial string) string <span class="cov0" title="0">{
        return fmt.Sprintf("Enter MFA code for %s: ", mfaSerial)
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package prompt

import (
        "fmt"
        "strings"

        "github.com/mattn/go-tty"
)

func TerminalPrompt(message string) (string, error) <span class="cov0" title="0">{
        tty, err := tty.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer tty.Close()

        fmt.Fprint(tty.Output(), message)

        text, err := tty.ReadString()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(text), nil</span>
}

func TerminalSecretPrompt(message string) (string, error) <span class="cov0" title="0">{
        tty, err := tty.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer tty.Close()

        fmt.Fprint(tty.Output(), message)

        text, err := tty.ReadPassword()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(text), nil</span>
}

func TerminalMfaPrompt(mfaSerial string) (string, error) <span class="cov0" title="0">{
        return TerminalPrompt(mfaPromptMessage(mfaSerial))
}</span>

func init() <span class="cov0" title="0">{
        Methods["terminal"] = TerminalMfaPrompt
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package prompt

import (
        "fmt"
        "log"
        "os"
        "os/exec"
        "strings"
)

// YkmanProvider runs ykman to generate a OATH-TOTP token from the Yubikey device
// To set up ykman, first run `ykman oath accounts add`
func YkmanMfaProvider(mfaSerial string) (string, error) <span class="cov0" title="0">{
        args := []string{}

        yubikeyOathCredName := os.Getenv("YKMAN_OATH_CREDENTIAL_NAME")
        if yubikeyOathCredName == "" </span><span class="cov0" title="0">{
                yubikeyOathCredName = mfaSerial
        }</span>

        // Get the serial number of the yubikey device to use.
        <span class="cov0" title="0">yubikeyDeviceSerial := os.Getenv("YKMAN_OATH_DEVICE_SERIAL")
        if yubikeyDeviceSerial != "" </span><span class="cov0" title="0">{
                // If the env var was set, extend args to support passing the serial.
                args = append(args, "--device", yubikeyDeviceSerial)
        }</span>

        // default to v4 and above
        <span class="cov0" title="0">switch os.Getenv("AWS_VAULT_YKMAN_VERSION") </span>{
        case "1", "2", "3":<span class="cov0" title="0">
                args = append(args, "oath", "code", "--single", yubikeyOathCredName)</span>
        default:<span class="cov0" title="0">
                args = append(args, "oath", "accounts", "code", "--single", yubikeyOathCredName)</span>
        }

        <span class="cov0" title="0">log.Printf("Fetching MFA code using `ykman %s`", strings.Join(args, " "))
        cmd := exec.Command("ykman", args...)
        cmd.Stderr = os.Stderr

        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("ykman: %w", err)
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(out)), nil</span>
}

func init() <span class="cov0" title="0">{
        if _, err := exec.LookPath("ykman"); err == nil </span><span class="cov0" title="0">{
                Methods["ykman"] = YkmanMfaProvider
        }</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package prompt

import (
        "os/exec"
        "strings"
)

func ZenityMfaPrompt(mfaSerial string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("zenity", "--entry", "--title", "aws-vault", "--text", mfaPromptMessage(mfaSerial))

        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(out)), nil</span>
}

func init() <span class="cov0" title="0">{
        if _, err := exec.LookPath("zenity"); err == nil </span><span class="cov0" title="0">{
                Methods["zenity"] = ZenityMfaPrompt
        }</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package request

import (
        "context"
        "time"
)

// FindApprovedRequest searches for a valid approved request for a specific user and profile.
// It queries the store for all requests by the requester, then filters for:
//   - Status == StatusApproved
//   - Profile matches the requested profile
//   - Request is not expired (ExpiresAt &gt; now)
//   - Access window is still open (now &lt; CreatedAt + Duration)
//
// Returns the first matching request if found, or nil if no valid approved request exists.
// Returns error only for store errors, not for "no approved request found".
func FindApprovedRequest(ctx context.Context, store Store, requester string, profile string) (*Request, error) <span class="cov10" title="11">{
        requests, err := store.ListByRequester(ctx, requester, MaxQueryLimit)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov9" title="10">for _, req := range requests </span><span class="cov10" title="11">{
                if req.Status == StatusApproved &amp;&amp; req.Profile == profile &amp;&amp; isRequestValid(req) </span><span class="cov3" title="2">{
                        return req, nil
                }</span>
        }

        <span class="cov8" title="8">return nil, nil</span>
}

// isRequestValid checks if an approved request is still valid for credential issuance.
// A request is valid if:
//   - ExpiresAt &gt; now (request hasn't expired)
//   - now &lt; CreatedAt + Duration (access window is still open)
func isRequestValid(req *Request) bool <span class="cov7" title="5">{
        now := time.Now()

        // Check request hasn't expired
        if now.After(req.ExpiresAt) </span><span class="cov3" title="2">{
                return false
        }</span>

        // Check access window is still open
        <span class="cov5" title="3">accessWindowEnd := req.CreatedAt.Add(req.Duration)
        if now.After(accessWindowEnd) </span><span class="cov1" title="1">{
                return false
        }</span>

        <span class="cov3" title="2">return true</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package request

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// GSI name constants for DynamoDB Global Secondary Indexes.
// These indexes are created externally via Terraform/CloudFormation.
const (
        // GSIRequester indexes requests by requester with created_at sort key.
        GSIRequester = "gsi-requester"
        // GSIStatus indexes requests by status with created_at sort key.
        GSIStatus = "gsi-status"
        // GSIProfile indexes requests by profile with created_at sort key.
        GSIProfile = "gsi-profile"
)

// dynamoDBAPI defines the DynamoDB operations used by DynamoDBStore.
// This interface enables testing with mock implementations.
type dynamoDBAPI interface {
        PutItem(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error)
        GetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)
        DeleteItem(ctx context.Context, params *dynamodb.DeleteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error)
        Query(ctx context.Context, params *dynamodb.QueryInput, optFns ...func(*dynamodb.Options)) (*dynamodb.QueryOutput, error)
}

// DynamoDBStore implements Store using AWS DynamoDB.
// It provides CRUD operations for approval requests with optimistic locking.
//
// Table schema assumptions (created externally via Terraform/CloudFormation):
//   - Partition key: id (String)
//   - TTL attribute: ttl (Number, Unix timestamp)
//   - All Request fields stored as attributes
type DynamoDBStore struct {
        client    dynamoDBAPI
        tableName string
}

// NewDynamoDBStore creates a new DynamoDBStore using the provided AWS configuration.
// The tableName specifies the DynamoDB table for storing requests.
func NewDynamoDBStore(cfg aws.Config, tableName string) *DynamoDBStore <span class="cov0" title="0">{
        return &amp;DynamoDBStore{
                client:    dynamodb.NewFromConfig(cfg),
                tableName: tableName,
        }
}</span>

// newDynamoDBStoreWithClient creates a DynamoDBStore with a custom client.
// This is primarily used for testing with mock clients.
func newDynamoDBStoreWithClient(client dynamoDBAPI, tableName string) *DynamoDBStore <span class="cov10" title="22">{
        return &amp;DynamoDBStore{
                client:    client,
                tableName: tableName,
        }
}</span>

// dynamoItem represents the DynamoDB item structure for a Request.
// It uses explicit field mapping for proper serialization of Go types.
type dynamoItem struct {
        ID              string `dynamodbav:"id"`
        Requester       string `dynamodbav:"requester"`
        Profile         string `dynamodbav:"profile"`
        Justification   string `dynamodbav:"justification"`
        Duration        int64  `dynamodbav:"duration"`         // nanoseconds
        Status          string `dynamodbav:"status"`           // RequestStatus as string
        CreatedAt       string `dynamodbav:"created_at"`       // RFC3339
        UpdatedAt       string `dynamodbav:"updated_at"`       // RFC3339
        ExpiresAt       string `dynamodbav:"expires_at"`       // RFC3339
        TTL             int64  `dynamodbav:"ttl"`              // Unix timestamp for DynamoDB TTL
        Approver        string `dynamodbav:"approver"`         // may be empty
        ApproverComment string `dynamodbav:"approver_comment"` // may be empty
}

// requestToItem converts a Request to a DynamoDB item structure.
func requestToItem(req *Request) *dynamoItem <span class="cov8" title="15">{
        return &amp;dynamoItem{
                ID:              req.ID,
                Requester:       req.Requester,
                Profile:         req.Profile,
                Justification:   req.Justification,
                Duration:        int64(req.Duration),
                Status:          string(req.Status),
                CreatedAt:       req.CreatedAt.Format(time.RFC3339Nano),
                UpdatedAt:       req.UpdatedAt.Format(time.RFC3339Nano),
                ExpiresAt:       req.ExpiresAt.Format(time.RFC3339Nano),
                TTL:             req.ExpiresAt.Unix(),
                Approver:        req.Approver,
                ApproverComment: req.ApproverComment,
        }
}</span>

// itemToRequest converts a DynamoDB item structure back to a Request.
func itemToRequest(item *dynamoItem) (*Request, error) <span class="cov6" title="7">{
        createdAt, err := time.Parse(time.RFC3339Nano, item.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse created_at: %w", err)
        }</span>
        <span class="cov6" title="7">updatedAt, err := time.Parse(time.RFC3339Nano, item.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse updated_at: %w", err)
        }</span>
        <span class="cov6" title="7">expiresAt, err := time.Parse(time.RFC3339Nano, item.ExpiresAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse expires_at: %w", err)
        }</span>

        <span class="cov6" title="7">return &amp;Request{
                ID:              item.ID,
                Requester:       item.Requester,
                Profile:         item.Profile,
                Justification:   item.Justification,
                Duration:        time.Duration(item.Duration),
                Status:          RequestStatus(item.Status),
                CreatedAt:       createdAt,
                UpdatedAt:       updatedAt,
                ExpiresAt:       expiresAt,
                Approver:        item.Approver,
                ApproverComment: item.ApproverComment,
        }, nil</span>
}

// Create stores a new request. Returns ErrRequestExists if ID already exists.
func (s *DynamoDBStore) Create(ctx context.Context, req *Request) error <span class="cov4" title="3">{
        item := requestToItem(req)
        av, err := attributevalue.MarshalMap(item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal request: %w", err)
        }</span>

        <span class="cov4" title="3">_, err = s.client.PutItem(ctx, &amp;dynamodb.PutItemInput{
                TableName:           aws.String(s.tableName),
                Item:                av,
                ConditionExpression: aws.String("attribute_not_exists(id)"),
        })
        if err != nil </span><span class="cov3" title="2">{
                var ccf *types.ConditionalCheckFailedException
                if errors.As(err, &amp;ccf) </span><span class="cov1" title="1">{
                        return fmt.Errorf("%s: %w", req.ID, ErrRequestExists)
                }</span>
                <span class="cov1" title="1">return fmt.Errorf("dynamodb PutItem: %w", err)</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// Get retrieves a request by ID. Returns ErrRequestNotFound if not exists.
func (s *DynamoDBStore) Get(ctx context.Context, id string) (*Request, error) <span class="cov4" title="3">{
        output, err := s.client.GetItem(ctx, &amp;dynamodb.GetItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "id": &amp;types.AttributeValueMemberS{Value: id},
                },
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("dynamodb GetItem: %w", err)
        }</span>

        <span class="cov3" title="2">if output.Item == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("%s: %w", id, ErrRequestNotFound)
        }</span>

        <span class="cov1" title="1">var item dynamoItem
        if err := attributevalue.UnmarshalMap(output.Item, &amp;item); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unmarshal request: %w", err)
        }</span>

        <span class="cov1" title="1">return itemToRequest(&amp;item)</span>
}

// Update modifies an existing request using optimistic locking.
// Returns ErrRequestNotFound if request doesn't exist.
// Returns ErrConcurrentModification if request was modified since last read.
func (s *DynamoDBStore) Update(ctx context.Context, req *Request) error <span class="cov4" title="3">{
        item := requestToItem(req)
        av, err := attributevalue.MarshalMap(item)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal request: %w", err)
        }</span>

        // Build condition: item must exist AND updated_at must match
        // This implements optimistic locking - if someone else updated the item,
        // the condition will fail.
        <span class="cov4" title="3">_, err = s.client.PutItem(ctx, &amp;dynamodb.PutItemInput{
                TableName:           aws.String(s.tableName),
                Item:                av,
                ConditionExpression: aws.String("attribute_exists(id) AND updated_at = :old_updated_at"),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":old_updated_at": &amp;types.AttributeValueMemberS{Value: req.UpdatedAt.Format(time.RFC3339Nano)},
                },
        })
        if err != nil </span><span class="cov3" title="2">{
                var ccf *types.ConditionalCheckFailedException
                if errors.As(err, &amp;ccf) </span><span class="cov3" title="2">{
                        // Could be either not found or concurrent modification
                        // Check if item exists to differentiate
                        exists, checkErr := s.exists(ctx, req.ID)
                        if checkErr != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("dynamodb PutItem condition failed, check exists: %w", checkErr)
                        }</span>
                        <span class="cov3" title="2">if !exists </span><span class="cov1" title="1">{
                                return fmt.Errorf("%s: %w", req.ID, ErrRequestNotFound)
                        }</span>
                        <span class="cov1" title="1">return fmt.Errorf("%s: %w", req.ID, ErrConcurrentModification)</span>
                }
                <span class="cov0" title="0">return fmt.Errorf("dynamodb PutItem: %w", err)</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// Delete removes a request by ID. No-op if not exists (idempotent).
func (s *DynamoDBStore) Delete(ctx context.Context, id string) error <span class="cov3" title="2">{
        _, err := s.client.DeleteItem(ctx, &amp;dynamodb.DeleteItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "id": &amp;types.AttributeValueMemberS{Value: id},
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dynamodb DeleteItem: %w", err)
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// exists checks if a request with the given ID exists in the store.
func (s *DynamoDBStore) exists(ctx context.Context, id string) (bool, error) <span class="cov3" title="2">{
        output, err := s.client.GetItem(ctx, &amp;dynamodb.GetItemInput{
                TableName: aws.String(s.tableName),
                Key: map[string]types.AttributeValue{
                        "id": &amp;types.AttributeValueMemberS{Value: id},
                },
                ProjectionExpression: aws.String("id"),
        })
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("dynamodb GetItem: %w", err)
        }</span>

        <span class="cov3" title="2">return output.Item != nil, nil</span>
}

// parseDynamoDBTime parses a time string that may be in RFC3339Nano format
// or as a Unix timestamp (for backward compatibility).
func parseDynamoDBTime(s string) (time.Time, error) <span class="cov0" title="0">{
        // Try RFC3339Nano first
        if t, err := time.Parse(time.RFC3339Nano, s); err == nil </span><span class="cov0" title="0">{
                return t, nil
        }</span>
        // Try RFC3339 (without nanos)
        <span class="cov0" title="0">if t, err := time.Parse(time.RFC3339, s); err == nil </span><span class="cov0" title="0">{
                return t, nil
        }</span>
        // Try Unix timestamp
        <span class="cov0" title="0">if unix, err := strconv.ParseInt(s, 10, 64); err == nil </span><span class="cov0" title="0">{
                return time.Unix(unix, 0), nil
        }</span>
        <span class="cov0" title="0">return time.Time{}, fmt.Errorf("cannot parse time: %q", s)</span>
}

// ListByRequester returns all requests from a specific user, ordered by created_at desc.
// Returns empty slice if no requests found.
func (s *DynamoDBStore) ListByRequester(ctx context.Context, requester string, limit int) ([]*Request, error) <span class="cov6" title="7">{
        return s.queryByIndex(ctx, GSIRequester, "requester", requester, limit)
}</span>

// ListByStatus returns all requests with a specific status, ordered by created_at desc.
// Commonly used to list pending requests for approvers.
func (s *DynamoDBStore) ListByStatus(ctx context.Context, status RequestStatus, limit int) ([]*Request, error) <span class="cov3" title="2">{
        return s.queryByIndex(ctx, GSIStatus, "status", string(status), limit)
}</span>

// ListByProfile returns all requests for a specific AWS profile, ordered by created_at desc.
// Useful for viewing request history for a profile.
func (s *DynamoDBStore) ListByProfile(ctx context.Context, profile string, limit int) ([]*Request, error) <span class="cov3" title="2">{
        return s.queryByIndex(ctx, GSIProfile, "profile", profile, limit)
}</span>

// queryByIndex executes a query against a GSI with the given partition key.
// Results are ordered by created_at descending (newest first).
func (s *DynamoDBStore) queryByIndex(ctx context.Context, indexName, keyAttr, keyValue string, limit int) ([]*Request, error) <span class="cov7" title="11">{
        // Apply limit defaults and cap
        effectiveLimit := limit
        if effectiveLimit &lt;= 0 </span><span class="cov3" title="2">{
                effectiveLimit = DefaultQueryLimit
        }</span>
        <span class="cov7" title="11">if effectiveLimit &gt; MaxQueryLimit </span><span class="cov1" title="1">{
                effectiveLimit = MaxQueryLimit
        }</span>

        <span class="cov7" title="11">output, err := s.client.Query(ctx, &amp;dynamodb.QueryInput{
                TableName:              aws.String(s.tableName),
                IndexName:              aws.String(indexName),
                KeyConditionExpression: aws.String(fmt.Sprintf("%s = :v", keyAttr)),
                ExpressionAttributeValues: map[string]types.AttributeValue{
                        ":v": &amp;types.AttributeValueMemberS{Value: keyValue},
                },
                ScanIndexForward: aws.Bool(false), // Descending order (newest first)
                Limit:            aws.Int32(int32(effectiveLimit)),
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("dynamodb Query %s: %w", indexName, err)
        }</span>

        // Convert items to requests
        <span class="cov7" title="10">requests := make([]*Request, 0, len(output.Items))
        for _, av := range output.Items </span><span class="cov5" title="4">{
                var item dynamoItem
                if err := attributevalue.UnmarshalMap(av, &amp;item); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unmarshal request: %w", err)
                }</span>
                <span class="cov5" title="4">req, err := itemToRequest(&amp;item)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov5" title="4">requests = append(requests, req)</span>
        }

        <span class="cov7" title="10">return requests, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Package request defines Sentinel's approval request schema.
// Requests represent user submissions for access to AWS profiles that require
// approval before credentials can be issued. Each request flows through a
// state machine from pending to terminal states (approved, denied, expired, cancelled).
//
// # Request State Machine
//
// Valid state transitions:
//   - pending -&gt; approved (by approver)
//   - pending -&gt; denied (by approver)
//   - pending -&gt; expired (by TTL)
//   - pending -&gt; cancelled (by requester)
//
// Terminal states (approved, denied, expired, cancelled) cannot transition.
//
// # Request ID Format
//
// Request IDs are 16-character lowercase hexadecimal strings (64 bits of entropy),
// providing uniqueness and correlation across approval workflow operations.
package request

import (
        "crypto/rand"
        "encoding/hex"
        "regexp"
        "time"
)

const (
        // DefaultRequestTTL is how long pending requests remain valid before expiring.
        DefaultRequestTTL = 24 * time.Hour

        // MaxJustificationLength is the maximum length for justification text.
        MaxJustificationLength = 500

        // MinJustificationLength is the minimum length for justification text.
        MinJustificationLength = 10

        // RequestIDLength is the exact length for request IDs (16 hex chars).
        RequestIDLength = 16

        // MaxDuration is the maximum access duration that can be requested.
        MaxDuration = 8 * time.Hour
)

// RequestStatus represents the current state of an approval request.
// It can be pending, approved, denied, expired, or cancelled.
type RequestStatus string

const (
        // StatusPending indicates the request is awaiting approval.
        StatusPending RequestStatus = "pending"
        // StatusApproved indicates the request was approved by an approver.
        StatusApproved RequestStatus = "approved"
        // StatusDenied indicates the request was denied by an approver.
        StatusDenied RequestStatus = "denied"
        // StatusExpired indicates the request expired before being actioned.
        StatusExpired RequestStatus = "expired"
        // StatusCancelled indicates the request was cancelled by the requester.
        StatusCancelled RequestStatus = "cancelled"
)

// IsValid returns true if the RequestStatus is a known value.
func (s RequestStatus) IsValid() bool <span class="cov5" title="32">{
        switch s </span>{
        case StatusPending, StatusApproved, StatusDenied, StatusExpired, StatusCancelled:<span class="cov5" title="26">
                return true</span>
        }
        <span class="cov3" title="6">return false</span>
}

// String returns the string representation of the RequestStatus.
func (s RequestStatus) String() string <span class="cov3" title="6">{
        return string(s)
}</span>

// IsTerminal returns true if the status is a terminal state that cannot transition.
func (s RequestStatus) IsTerminal() bool <span class="cov5" title="35">{
        switch s </span>{
        case StatusApproved, StatusDenied, StatusExpired, StatusCancelled:<span class="cov5" title="24">
                return true</span>
        }
        <span class="cov4" title="11">return false</span>
}

// Request represents an approval request for AWS profile access.
// It contains the requester's information, what they're requesting,
// why they need it, and the current state of the approval workflow.
type Request struct {
        // ID is the unique request identifier (16 lowercase hex chars).
        ID string `yaml:"id" json:"id"`

        // Requester is the username requesting access.
        Requester string `yaml:"requester" json:"requester"`

        // Profile is the AWS profile being requested.
        Profile string `yaml:"profile" json:"profile"`

        // Justification explains why access is needed.
        Justification string `yaml:"justification" json:"justification"`

        // Duration is how long access is requested for.
        Duration time.Duration `yaml:"duration" json:"duration"`

        // Status is the current state of the request (pending, approved, etc.).
        Status RequestStatus `yaml:"status" json:"status"`

        // CreatedAt is when the request was submitted.
        CreatedAt time.Time `yaml:"created_at" json:"created_at"`

        // UpdatedAt is when the request was last modified.
        UpdatedAt time.Time `yaml:"updated_at" json:"updated_at"`

        // ExpiresAt is when the pending request times out.
        ExpiresAt time.Time `yaml:"expires_at" json:"expires_at"`

        // Approver is who approved/denied the request (empty until actioned).
        Approver string `yaml:"approver,omitempty" json:"approver,omitempty"`

        // ApproverComment is an optional comment from the approver.
        ApproverComment string `yaml:"approver_comment,omitempty" json:"approver_comment,omitempty"`
}

// requestIDRegex matches valid request IDs (16 lowercase hex chars).
var requestIDRegex = regexp.MustCompile(`^[0-9a-f]{16}$`)

// NewRequestID generates a new 16-character lowercase hex request ID.
// It uses crypto/rand for cryptographic randomness.
//
// The request ID provides:
//   - Uniqueness per approval request
//   - Correlation across approval workflow operations
//   - No PII or sensitive data (just random identifier)
func NewRequestID() string <span class="cov10" title="1011">{
        // Generate 8 random bytes (64 bits of entropy)
        bytes := make([]byte, 8)
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                // This should never happen with crypto/rand
                // Fall back to zeros rather than panic
                return "0000000000000000"
        }</span>

        // Encode as 16-character lowercase hex string
        <span class="cov10" title="1011">return hex.EncodeToString(bytes)</span>
}

// ValidateRequestID checks if the given string is a valid request ID.
// A valid request ID is exactly 16 lowercase hexadecimal characters.
func ValidateRequestID(id string) bool <span class="cov6" title="50">{
        return requestIDRegex.MatchString(id)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package request

import (
        "fmt"
)

// Validate checks if the Request is semantically correct.
// It verifies all required fields are present and valid.
func (r *Request) Validate() error <span class="cov9" title="25">{
        // Validate ID
        if !ValidateRequestID(r.ID) </span><span class="cov5" title="6">{
                return fmt.Errorf("invalid request ID: must be %d lowercase hex characters", RequestIDLength)
        }</span>

        // Validate requester
        <span class="cov8" title="19">if r.Requester == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("requester cannot be empty")
        }</span>

        // Validate profile
        <span class="cov8" title="18">if r.Profile == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("profile cannot be empty")
        }</span>

        // Validate justification
        <span class="cov8" title="17">if len(r.Justification) &lt; MinJustificationLength </span><span class="cov2" title="2">{
                return fmt.Errorf("justification too short: minimum %d characters", MinJustificationLength)
        }</span>
        <span class="cov8" title="15">if len(r.Justification) &gt; MaxJustificationLength </span><span class="cov2" title="2">{
                return fmt.Errorf("justification too long: maximum %d characters", MaxJustificationLength)
        }</span>

        // Validate status
        <span class="cov7" title="13">if !r.Status.IsValid() </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid status: %q", r.Status)
        }</span>

        // Validate duration
        <span class="cov7" title="12">if r.Duration &lt;= 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("duration must be positive")
        }</span>
        <span class="cov7" title="10">if r.Duration &gt; MaxDuration </span><span class="cov2" title="2">{
                return fmt.Errorf("duration exceeds maximum of %v", MaxDuration)
        }</span>

        // Validate timestamps
        <span class="cov6" title="8">if r.CreatedAt.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("created_at cannot be zero")
        }</span>
        <span class="cov6" title="7">if r.UpdatedAt.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("updated_at cannot be zero")
        }</span>
        <span class="cov5" title="6">if r.ExpiresAt.IsZero() </span><span class="cov1" title="1">{
                return fmt.Errorf("expires_at cannot be zero")
        }</span>

        <span class="cov5" title="5">return nil</span>
}

// CanTransitionTo checks if the request can transition to the given status.
// Only pending requests can transition; terminal states cannot change.
//
// Valid transitions:
//   - pending -&gt; approved
//   - pending -&gt; denied
//   - pending -&gt; expired
//   - pending -&gt; cancelled
func (r *Request) CanTransitionTo(newStatus RequestStatus) bool <span class="cov10" title="30">{
        // Terminal states cannot transition
        if r.Status.IsTerminal() </span><span class="cov8" title="20">{
                return false
        }</span>

        // Only pending can transition
        <span class="cov7" title="10">if r.Status != StatusPending </span><span class="cov0" title="0">{
                return false
        }</span>

        // New status must be valid and terminal (transitions from pending always go to terminal)
        <span class="cov7" title="10">return newStatus.IsValid() &amp;&amp; newStatus != StatusPending</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Package sentinel provides Sentinel's credential issuance with SourceIdentity stamping.
// It wraps AWS STS AssumeRole to ensure all Sentinel-issued credentials carry a
// SourceIdentity stamp for visibility and enforceability inside AWS.
package sentinel

import (
        "context"
        "errors"
        "fmt"
        "log"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sts"
        "github.com/byteness/aws-vault/v7/identity"
        "github.com/byteness/aws-vault/v7/vault"
)

// Sentinel-specific errors for input validation.
var (
        // ErrMissingRoleARN indicates the RoleARN field is empty.
        ErrMissingRoleARN = errors.New("RoleARN is required")

        // ErrMissingSourceIdentity indicates the SourceIdentity field is nil.
        ErrMissingSourceIdentity = errors.New("SourceIdentity is required")

        // ErrMissingCredsProvider indicates the CredsProvider field is nil.
        ErrMissingCredsProvider = errors.New("CredsProvider is required")

        // ErrInvalidSourceIdentity indicates the SourceIdentity is not valid.
        ErrInvalidSourceIdentity = errors.New("SourceIdentity is invalid")
)

// Default values for SentinelAssumeRole.
const (
        // DefaultDuration is the default session duration (1 hour, matching aws-vault).
        DefaultDuration = time.Hour
)

// SentinelAssumeRoleInput contains the parameters for SentinelAssumeRole.
type SentinelAssumeRoleInput struct {
        // CredsProvider provides the base credentials (from aws-vault).
        // Required.
        CredsProvider aws.CredentialsProvider

        // RoleARN is the ARN of the role to assume.
        // Required.
        RoleARN string

        // RoleSessionName is the name for the assumed role session.
        // Optional - defaults to "sentinel-{timestamp}".
        RoleSessionName string

        // Duration is the session duration.
        // Optional - defaults to 1 hour.
        Duration time.Duration

        // SourceIdentity is the Sentinel identity stamp to apply.
        // Required.
        SourceIdentity *identity.SourceIdentity

        // Region is the AWS region for the STS endpoint.
        Region string

        // STSRegionalEndpoints controls regional vs global endpoints.
        // Optional - "legacy" or "regional".
        STSRegionalEndpoints string

        // EndpointURL is a custom STS endpoint URL.
        // Optional.
        EndpointURL string

        // ExternalID is used for cross-account role assumption.
        // Optional.
        ExternalID string
}

// SentinelAssumeRoleOutput contains the result of SentinelAssumeRole.
type SentinelAssumeRoleOutput struct {
        // Credentials are the temporary AWS credentials.
        Credentials aws.Credentials

        // SourceIdentity is the stamped SourceIdentity value.
        SourceIdentity string

        // AssumedRoleArn is the ARN of the assumed role.
        AssumedRoleArn string

        // AssumedRoleId is the unique identifier for the assumed role session.
        AssumedRoleId string
}

// SentinelAssumeRole assumes an AWS role with SourceIdentity stamping.
// It validates input, creates an STS client, and calls AssumeRole with
// the SourceIdentity from the input.
//
// This is the core mechanism for Sentinel Fingerprint - all credentials
// issued by Sentinel carry a SourceIdentity stamp that identifies the
// Sentinel user and request for correlation with CloudTrail.
func SentinelAssumeRole(ctx context.Context, input *SentinelAssumeRoleInput) (*SentinelAssumeRoleOutput, error) <span class="cov7" title="5">{
        // Validate input
        if err := validateInput(input); err != nil </span><span class="cov6" title="4">{
                return nil, err
        }</span>

        // Apply defaults
        <span class="cov1" title="1">applyDefaults(input)

        // Create STS client using vault pattern
        cfg := vault.NewAwsConfigWithCredsProvider(
                input.CredsProvider,
                input.Region,
                input.STSRegionalEndpoints,
                input.EndpointURL,
        )
        stsClient := sts.NewFromConfig(cfg)

        // Build AssumeRole input with SourceIdentity
        assumeRoleInput := &amp;sts.AssumeRoleInput{
                RoleArn:         aws.String(input.RoleARN),
                RoleSessionName: aws.String(input.RoleSessionName),
                DurationSeconds: aws.Int32(int32(input.Duration.Seconds())),
                SourceIdentity:  aws.String(input.SourceIdentity.Format()),
        }

        // Add ExternalID if provided
        if input.ExternalID != "" </span><span class="cov0" title="0">{
                assumeRoleInput.ExternalId = aws.String(input.ExternalID)
        }</span>

        // Call STS AssumeRole
        <span class="cov1" title="1">resp, err := stsClient.AssumeRole(ctx, assumeRoleInput)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to assume role %s: %w", input.RoleARN, err)
        }</span>

        // Log the assumption
        <span class="cov0" title="0">log.Printf("Assumed role %s with SourceIdentity %s, expires in %s",
                input.RoleARN,
                input.SourceIdentity.Format(),
                time.Until(*resp.Credentials.Expiration).String(),
        )

        return &amp;SentinelAssumeRoleOutput{
                Credentials: aws.Credentials{
                        AccessKeyID:     *resp.Credentials.AccessKeyId,
                        SecretAccessKey: *resp.Credentials.SecretAccessKey,
                        SessionToken:    *resp.Credentials.SessionToken,
                        CanExpire:       true,
                        Expires:         *resp.Credentials.Expiration,
                },
                SourceIdentity: input.SourceIdentity.Format(),
                AssumedRoleArn: *resp.AssumedRoleUser.Arn,
                AssumedRoleId:  *resp.AssumedRoleUser.AssumedRoleId,
        }, nil</span>
}

// validateInput checks that all required fields are present and valid.
func validateInput(input *SentinelAssumeRoleInput) error <span class="cov10" title="11">{
        if input.CredsProvider == nil </span><span class="cov3" title="2">{
                return ErrMissingCredsProvider
        }</span>
        <span class="cov9" title="9">if input.RoleARN == "" </span><span class="cov3" title="2">{
                return ErrMissingRoleARN
        }</span>
        <span class="cov8" title="7">if input.SourceIdentity == nil </span><span class="cov3" title="2">{
                return ErrMissingSourceIdentity
        }</span>
        <span class="cov7" title="5">if !input.SourceIdentity.IsValid() </span><span class="cov3" title="2">{
                return ErrInvalidSourceIdentity
        }</span>
        <span class="cov5" title="3">return nil</span>
}

// applyDefaults sets default values for optional fields.
func applyDefaults(input *SentinelAssumeRoleInput) <span class="cov7" title="6">{
        if input.RoleSessionName == "" </span><span class="cov6" title="4">{
                input.RoleSessionName = fmt.Sprintf("sentinel-%d", time.Now().UTC().UnixNano())
        }</span>
        <span class="cov7" title="6">if input.Duration == 0 </span><span class="cov5" title="3">{
                input.Duration = DefaultDuration
        }</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// Package sentinel provides Sentinel's credential issuance with SourceIdentity stamping.
// This file implements the TwoHopCredentialProvider which chains aws-vault base
// credentials through SentinelAssumeRole to stamp SourceIdentity on all credentials.
package sentinel

import (
        "context"
        "errors"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/byteness/aws-vault/v7/identity"
)

// TwoHopCredentialProvider validation errors.
var (
        // ErrMissingBaseCredsProvider indicates the BaseCredsProvider field is nil.
        ErrMissingBaseCredsProvider = errors.New("BaseCredsProvider is required")

        // ErrMissingUser indicates the User field is empty.
        ErrMissingUser = errors.New("User is required for SourceIdentity")
)

// TwoHopCredentialProviderInput contains the parameters for creating a TwoHopCredentialProvider.
type TwoHopCredentialProviderInput struct {
        // BaseCredsProvider provides the base credentials from aws-vault
        // (session tokens, SSO, stored creds, etc.).
        // Required.
        BaseCredsProvider aws.CredentialsProvider

        // RoleARN is the ARN of the target role to assume.
        // Required.
        RoleARN string

        // User is the username for SourceIdentity stamping.
        // This will be sanitized for AWS SourceIdentity constraints.
        // Required.
        User string

        // Region is the AWS region for the STS endpoint.
        // Optional.
        Region string

        // STSRegionalEndpoints controls regional vs global endpoints.
        // Optional - "legacy" or "regional".
        STSRegionalEndpoints string

        // EndpointURL is a custom STS endpoint URL.
        // Optional.
        EndpointURL string

        // ExternalID is used for cross-account role assumption.
        // Optional.
        ExternalID string

        // SessionDuration is the session duration for the assumed role.
        // Optional - defaults to 1 hour.
        SessionDuration time.Duration

        // RequestID is an optional pre-generated request-id for correlation.
        // If empty, a new request-id will be generated during Retrieve().
        // Optional.
        RequestID string
}

// TwoHopCredentialProvider implements aws.CredentialsProvider by chaining
// aws-vault base credentials through SentinelAssumeRole.
//
// This provider implements the core credential flow for Sentinel Fingerprint:
// 1. Get base credentials from aws-vault (session tokens, SSO, stored creds)
// 2. Generate unique SourceIdentity (sentinel:&lt;user&gt;:&lt;request-id&gt;)
// 3. Assume target role with SourceIdentity stamped
//
// Each Retrieve() call generates a fresh request-id (unless pre-generated),
// ensuring all credentials can be correlated with their Sentinel issuance.
type TwoHopCredentialProvider struct {
        Input TwoHopCredentialProviderInput

        // LastSourceIdentity is set after Retrieve() completes successfully.
        // It contains the SourceIdentity used for the most recent credential request.
        // Callers can use this to retrieve the actual SourceIdentity for logging/correlation.
        LastSourceIdentity *identity.SourceIdentity
}

// NewTwoHopCredentialProvider creates a new TwoHopCredentialProvider with the given input.
// It validates required fields before returning.
func NewTwoHopCredentialProvider(input TwoHopCredentialProviderInput) (*TwoHopCredentialProvider, error) <span class="cov9" title="22">{
        if err := validateProviderInput(&amp;input); err != nil </span><span class="cov5" title="6">{
                return nil, err
        }</span>

        <span class="cov8" title="16">return &amp;TwoHopCredentialProvider{
                Input: input,
        }, nil</span>
}

// NewTwoHopProvider is a convenience constructor for the common use case.
// It creates a TwoHopCredentialProvider with minimal required inputs.
func NewTwoHopProvider(baseProvider aws.CredentialsProvider, roleARN, user, region string) (*TwoHopCredentialProvider, error) <span class="cov5" title="5">{
        return NewTwoHopCredentialProvider(TwoHopCredentialProviderInput{
                BaseCredsProvider: baseProvider,
                RoleARN:           roleARN,
                User:              user,
                Region:            region,
        })
}</span>

// Retrieve generates new credentials by assuming the target role with SourceIdentity.
// If Input.RequestID is provided, it uses that; otherwise generates a new request-id.
// After successful completion, LastSourceIdentity is populated for caller retrieval.
//
// Implements aws.CredentialsProvider interface.
func (p *TwoHopCredentialProvider) Retrieve(ctx context.Context) (aws.Credentials, error) <span class="cov1" title="1">{
        // Use pre-generated request-id if provided, otherwise generate new one
        requestID := p.Input.RequestID
        if requestID == "" </span><span class="cov1" title="1">{
                requestID = identity.NewRequestID()
        }</span>

        // Sanitize username for SourceIdentity constraints
        <span class="cov1" title="1">sanitizedUser, err := identity.SanitizeUser(p.Input.User)
        if err != nil </span><span class="cov0" title="0">{
                return aws.Credentials{}, err
        }</span>

        // Create SourceIdentity with sanitized user and request-id
        <span class="cov1" title="1">sourceIdentity, err := identity.New(sanitizedUser, requestID)
        if err != nil </span><span class="cov0" title="0">{
                return aws.Credentials{}, err
        }</span>

        // Store the SourceIdentity for caller retrieval
        <span class="cov1" title="1">p.LastSourceIdentity = sourceIdentity

        // Determine session duration (use default if not specified)
        duration := p.Input.SessionDuration
        if duration == 0 </span><span class="cov1" title="1">{
                duration = DefaultDuration
        }</span>

        // Build SentinelAssumeRole input
        <span class="cov1" title="1">assumeRoleInput := &amp;SentinelAssumeRoleInput{
                CredsProvider:        p.Input.BaseCredsProvider,
                RoleARN:              p.Input.RoleARN,
                SourceIdentity:       sourceIdentity,
                Region:               p.Input.Region,
                STSRegionalEndpoints: p.Input.STSRegionalEndpoints,
                EndpointURL:          p.Input.EndpointURL,
                ExternalID:           p.Input.ExternalID,
                Duration:             duration,
        }

        // Call SentinelAssumeRole to get credentials with SourceIdentity stamp
        result, err := SentinelAssumeRole(ctx, assumeRoleInput)
        if err != nil </span><span class="cov1" title="1">{
                return aws.Credentials{}, err
        }</span>

        <span class="cov0" title="0">return result.Credentials, nil</span>
}

// validateProviderInput checks that all required fields are present.
func validateProviderInput(input *TwoHopCredentialProviderInput) error <span class="cov10" title="27">{
        if input.BaseCredsProvider == nil </span><span class="cov4" title="3">{
                return ErrMissingBaseCredsProvider
        }</span>
        <span class="cov9" title="24">if input.RoleARN == "" </span><span class="cov4" title="3">{
                return ErrMissingRoleARN
        }</span>
        <span class="cov9" title="21">if input.User == "" </span><span class="cov4" title="3">{
                return ErrMissingUser
        }</span>
        <span class="cov8" title="18">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">//go:build darwin || freebsd || openbsd
// +build darwin freebsd openbsd

package server

import "os/exec"

func installEc2EndpointNetworkAlias() ([]byte, error) <span class="cov0" title="0">{
        return exec.Command("ifconfig", "lo0", "alias", "169.254.169.254").CombinedOutput()
}</span>

func removeEc2EndpointNetworkAlias() ([]byte, error) <span class="cov0" title="0">{
        return exec.Command("ifconfig", "lo0", "-alias", "169.254.169.254").CombinedOutput()
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package server

import (
        "fmt"
        "log"
        "net"
        "net/http"
        "net/http/httputil"
        "net/url"
        "os"
        "strings"
        "time"
)

const (
        ec2MetadataEndpointIP   = "169.254.169.254"
        ec2MetadataEndpointAddr = "169.254.169.254:80"
)

// StartProxy starts a http proxy server that listens on the standard EC2 Instance Metadata endpoint http://169.254.169.254:80/
// and forwards requests through to the running `aws-vault exec` command
func StartProxy() error <span class="cov0" title="0">{
        var localServerURL, err = url.Parse(fmt.Sprintf("http://%s/", ec2CredentialsServerAddr))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if output, err := installEc2EndpointNetworkAlias(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %s", strings.TrimSpace(string(output)), err.Error())
        }</span>

        <span class="cov0" title="0">l, err := net.Listen("tcp", ec2MetadataEndpointAddr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">handler := http.NewServeMux()
        handler.HandleFunc("/stop", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                go Shutdown()
        }</span>)
        <span class="cov0" title="0">handler.Handle("/", httputil.NewSingleHostReverseProxy(localServerURL))

        log.Printf("EC2 Instance Metadata endpoint proxy server running on %s", l.Addr())
        return http.Serve(l, handler)</span>
}

func IsProxyRunning() bool <span class="cov0" title="0">{
        _, err := net.DialTimeout("tcp", ec2MetadataEndpointAddr, time.Millisecond*10)
        return err == nil
}</span>

func Shutdown() <span class="cov0" title="0">{
        _, err := removeEc2EndpointNetworkAlias()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalln(err)
        }</span>
        <span class="cov0" title="0">os.Exit(0)</span>
}

// StopProxy stops the http proxy server on the standard EC2 Instance Metadata endpoint
func StopProxy() <span class="cov0" title="0">{
        _, _ = http.Get(fmt.Sprintf("http://%s/stop", ec2MetadataEndpointAddr)) //nolint
}</span>

func awsVaultExecutable() string <span class="cov0" title="0">{
        awsVaultPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return awsVaultPath
        }</span>

        <span class="cov0" title="0">return os.Args[0]</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">//go:build darwin || freebsd || openbsd || linux
// +build darwin freebsd openbsd linux

package server

import (
        "log"
        "os"
        "os/exec"
)

// StartEc2EndpointProxyServerProcess starts a `aws-vault proxy` process
func StartEc2EndpointProxyServerProcess() error <span class="cov0" title="0">{
        log.Println("Starting `aws-vault proxy` as root in the background")
        cmd := exec.Command("sudo", "-b", awsVaultExecutable(), "proxy")
        cmd.Stdin = os.Stdin
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package server

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "net"
        "net/http"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/byteness/aws-vault/v7/iso8601"
)

const ec2CredentialsServerAddr = "127.0.0.1:9099"

// StartEc2CredentialsServer starts a EC2 Instance Metadata server and endpoint proxy
func StartEc2CredentialsServer(ctx context.Context, credsProvider aws.CredentialsProvider, region string) error <span class="cov0" title="0">{
        credsCache := aws.NewCredentialsCache(credsProvider)

        // pre-fetch credentials so that we can respond quickly to the first request
        // SDKs seem to very aggressively timeout
        _, _ = credsCache.Retrieve(ctx)

        go startEc2CredentialsServer(credsCache, region)

        return nil
}</span>

func startEc2CredentialsServer(credsProvider aws.CredentialsProvider, region string) <span class="cov0" title="0">{
        log.Printf("Starting EC2 Instance Metadata server on %s", ec2CredentialsServerAddr)
        router := http.NewServeMux()

        router.HandleFunc("/latest/meta-data/iam/security-credentials/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "local-credentials")
        }</span>)

        // The AWS Go SDK checks the instance-id endpoint to validate the existence of EC2 Metadata
        <span class="cov0" title="0">router.HandleFunc("/latest/meta-data/instance-id/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "aws-vault")
        }</span>)

        // The AWS .NET SDK checks this endpoint during obtaining credentials/refreshing them
        <span class="cov0" title="0">router.HandleFunc("/latest/meta-data/iam/info/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                fmt.Fprintf(w, `{"Code" : "Success"}`)
        }</span>)

        // used by AWS SDK to determine region
        <span class="cov0" title="0">router.HandleFunc("/latest/dynamic/instance-identity/document", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                fmt.Fprintf(w, `{"region": "%s"}`, region)
        }</span>)

        <span class="cov0" title="0">router.HandleFunc("/latest/meta-data/iam/security-credentials/local-credentials", credsHandler(credsProvider))

        log.Fatalln(http.ListenAndServe(ec2CredentialsServerAddr, withLogging(withSecurityChecks(router))))</span>
}

// withSecurityChecks is middleware to protect the server from attack vectors
func withSecurityChecks(next *http.ServeMux) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Check the remote ip is from the loopback, otherwise clients on the same network segment could
                // potentially route traffic via 169.254.169.254:80
                // See https://developer.apple.com/library/content/qa/qa1357/_index.html
                ip, _, err := net.SplitHostPort(r.RemoteAddr)
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>
                <span class="cov0" title="0">if !net.ParseIP(ip).IsLoopback() </span><span class="cov0" title="0">{
                        http.Error(w, "Access denied from non-localhost address", http.StatusUnauthorized)
                        return
                }</span>

                // Check that the request is to 169.254.169.254
                // Without this it's possible for an attacker to mount a DNS rebinding attack
                // See https://github.com/byteness/aws-vault/issues/578
                <span class="cov0" title="0">if r.Host != ec2MetadataEndpointIP &amp;&amp; r.Host != ec2MetadataEndpointAddr </span><span class="cov0" title="0">{
                        http.Error(w, fmt.Sprintf("Access denied for host '%s'", r.Host), http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        }
}

func credsHandler(credsProvider aws.CredentialsProvider) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                creds, err := credsProvider.Retrieve(r.Context())
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusGatewayTimeout)
                        return
                }</span>

                <span class="cov0" title="0">log.Printf("Serving credentials via http ****************%s, expiration of %s (%s)",
                        creds.AccessKeyID[len(creds.AccessKeyID)-4:],
                        creds.Expires.Format(time.RFC3339),
                        time.Until(creds.Expires).String())

                err = json.NewEncoder(w).Encode(map[string]interface{}{
                        "Code":            "Success",
                        "LastUpdated":     iso8601.Format(time.Now()),
                        "Type":            "AWS-HMAC",
                        "AccessKeyId":     creds.AccessKeyID,
                        "SecretAccessKey": creds.SecretAccessKey,
                        "Token":           creds.SessionToken,
                        "Expiration":      iso8601.Format(creds.Expires),
                })
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package server

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "log"
        "net"
        "net/http"
        "strings"
        "sync"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sts"
        "github.com/byteness/aws-vault/v7/iso8601"
        "github.com/byteness/aws-vault/v7/vault"
)

func writeErrorMessage(w http.ResponseWriter, msg string, statusCode int) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(statusCode)
        if err := json.NewEncoder(w).Encode(map[string]string{"Message": msg}); err != nil </span><span class="cov0" title="0">{
                log.Println(err.Error())
        }</span>
}

func withAuthorizationCheck(authToken string, next http.HandlerFunc) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Header.Get("Authorization") != authToken </span><span class="cov0" title="0">{
                        writeErrorMessage(w, "invalid Authorization token", http.StatusForbidden)
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        }
}

func writeCredsToResponse(creds aws.Credentials, w http.ResponseWriter) <span class="cov0" title="0">{
        err := json.NewEncoder(w).Encode(map[string]string{
                "AccessKeyId":     creds.AccessKeyID,
                "SecretAccessKey": creds.SecretAccessKey,
                "Token":           creds.SessionToken,
                "Expiration":      iso8601.Format(creds.Expires),
        })
        if err != nil </span><span class="cov0" title="0">{
                writeErrorMessage(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
}

func generateRandomString() string <span class="cov0" title="0">{
        b := make([]byte, 30)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return base64.RawURLEncoding.EncodeToString(b)</span>
}

type EcsServer struct {
        listener          net.Listener
        authToken         string
        server            http.Server
        cache             sync.Map
        baseCredsProvider aws.CredentialsProvider
        config            *vault.ProfileConfig
}

func NewEcsServer(ctx context.Context, baseCredsProvider aws.CredentialsProvider, config *vault.ProfileConfig, authToken string, port int, lazyLoadBaseCreds bool) (*EcsServer, error) <span class="cov0" title="0">{
        listener, err := net.Listen("tcp", fmt.Sprintf("127.0.0.1:%d", port))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if authToken == "" </span><span class="cov0" title="0">{
                authToken = generateRandomString()
        }</span>

        <span class="cov0" title="0">credsCache := aws.NewCredentialsCache(baseCredsProvider)
        if !lazyLoadBaseCreds </span><span class="cov0" title="0">{
                _, err := credsCache.Retrieve(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Retrieving creds: %w", err)
                }</span>
        }

        <span class="cov0" title="0">e := &amp;EcsServer{
                listener:          listener,
                authToken:         authToken,
                baseCredsProvider: credsCache,
                config:            config,
        }

        router := http.NewServeMux()
        router.HandleFunc("/", e.DefaultRoute)
        router.HandleFunc("/role-arn/", e.AssumeRoleArnRoute)
        e.server.Handler = withLogging(withAuthorizationCheck(e.authToken, router.ServeHTTP))

        return e, nil</span>
}

func (e *EcsServer) BaseURL() string <span class="cov0" title="0">{
        return fmt.Sprintf("http://%s", e.listener.Addr().String())
}</span>
func (e *EcsServer) AuthToken() string <span class="cov0" title="0">{
        return e.authToken
}</span>

func (e *EcsServer) Serve() error <span class="cov0" title="0">{
        return e.server.Serve(e.listener)
}</span>

func (e *EcsServer) DefaultRoute(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        creds, err := e.baseCredsProvider.Retrieve(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                writeErrorMessage(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">writeCredsToResponse(creds, w)</span>
}

func (e *EcsServer) getRoleProvider(roleArn string) aws.CredentialsProvider <span class="cov0" title="0">{
        var roleProviderCache *aws.CredentialsCache

        v, ok := e.cache.Load(roleArn)
        if ok </span><span class="cov0" title="0">{
                roleProviderCache = v.(*aws.CredentialsCache)
        }</span> else<span class="cov0" title="0"> {
                cfg := vault.NewAwsConfigWithCredsProvider(e.baseCredsProvider, e.config.Region, e.config.STSRegionalEndpoints, e.config.EndpointURL)
                roleProvider := &amp;vault.AssumeRoleProvider{
                        StsClient: sts.NewFromConfig(cfg),
                        RoleARN:   roleArn,
                        Duration:  e.config.AssumeRoleDuration,
                }
                roleProviderCache = aws.NewCredentialsCache(roleProvider)
                e.cache.Store(roleArn, roleProviderCache)
        }</span>
        <span class="cov0" title="0">return roleProviderCache</span>
}

func (e *EcsServer) AssumeRoleArnRoute(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        roleArn := strings.TrimPrefix(r.URL.Path, "/role-arn/")
        roleProvider := e.getRoleProvider(roleArn)
        creds, err := roleProvider.Retrieve(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                writeErrorMessage(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">writeCredsToResponse(creds, w)</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package server

import (
        "log"
        "net/http"
        "time"
)

type loggingMiddlewareResponseWriter struct {
        http.ResponseWriter
        Code int
}

func (w *loggingMiddlewareResponseWriter) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.Code = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

func withLogging(handler http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                requestStart := time.Now()
                w2 := &amp;loggingMiddlewareResponseWriter{w, http.StatusOK}
                handler.ServeHTTP(w2, r)
                log.Printf("http: %s: %d %s %s (%s)", r.RemoteAddr, w2.Code, r.Method, r.URL, time.Since(requestStart))
        }</span>)
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package testutil

import (
        "context"
        "errors"
        "sync"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/cloudtrail"
        "github.com/aws/aws-sdk-go-v2/service/dynamodb"
        "github.com/aws/aws-sdk-go-v2/service/iam"
        "github.com/aws/aws-sdk-go-v2/service/sns"
        "github.com/aws/aws-sdk-go-v2/service/ssm"
        "github.com/aws/aws-sdk-go-v2/service/sts"
)

// ============================================================================
// MockSSMClient - SSM Parameter Store operations
// ============================================================================

// MockSSMClient implements SSM client operations for testing.
// Supports GetParameter, GetParametersByPath, and PutParameter operations.
type MockSSMClient struct {
        mu sync.Mutex

        // Configurable behavior functions
        GetParameterFunc        func(ctx context.Context, params *ssm.GetParameterInput, optFns ...func(*ssm.Options)) (*ssm.GetParameterOutput, error)
        GetParametersByPathFunc func(ctx context.Context, params *ssm.GetParametersByPathInput, optFns ...func(*ssm.Options)) (*ssm.GetParametersByPathOutput, error)
        PutParameterFunc        func(ctx context.Context, params *ssm.PutParameterInput, optFns ...func(*ssm.Options)) (*ssm.PutParameterOutput, error)

        // Call tracking
        GetParameterCalls        []*ssm.GetParameterInput
        GetParametersByPathCalls []*ssm.GetParametersByPathInput
        PutParameterCalls        []*ssm.PutParameterInput
}

// GetParameter implements SSM GetParameter operation.
func (m *MockSSMClient) GetParameter(ctx context.Context, params *ssm.GetParameterInput, optFns ...func(*ssm.Options)) (*ssm.GetParameterOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.GetParameterCalls = append(m.GetParameterCalls, params)
        m.mu.Unlock()

        if m.GetParameterFunc != nil </span><span class="cov0" title="0">{
                return m.GetParameterFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return nil, errors.New("GetParameter not implemented")</span>
}

// GetParametersByPath implements SSM GetParametersByPath operation.
func (m *MockSSMClient) GetParametersByPath(ctx context.Context, params *ssm.GetParametersByPathInput, optFns ...func(*ssm.Options)) (*ssm.GetParametersByPathOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.GetParametersByPathCalls = append(m.GetParametersByPathCalls, params)
        m.mu.Unlock()

        if m.GetParametersByPathFunc != nil </span><span class="cov0" title="0">{
                return m.GetParametersByPathFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return &amp;ssm.GetParametersByPathOutput{}, nil</span>
}

// PutParameter implements SSM PutParameter operation.
func (m *MockSSMClient) PutParameter(ctx context.Context, params *ssm.PutParameterInput, optFns ...func(*ssm.Options)) (*ssm.PutParameterOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.PutParameterCalls = append(m.PutParameterCalls, params)
        m.mu.Unlock()

        if m.PutParameterFunc != nil </span><span class="cov0" title="0">{
                return m.PutParameterFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return &amp;ssm.PutParameterOutput{Version: 1}, nil</span>
}

// Reset clears all call tracking data.
func (m *MockSSMClient) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.GetParameterCalls = nil
        m.GetParametersByPathCalls = nil
        m.PutParameterCalls = nil
}</span>

// ============================================================================
// MockDynamoDBClient - DynamoDB operations
// ============================================================================

// MockDynamoDBClient implements DynamoDB client operations for testing.
// Supports PutItem, GetItem, DeleteItem, Query, and UpdateItem operations.
type MockDynamoDBClient struct {
        mu sync.Mutex

        // Configurable behavior functions
        PutItemFunc    func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error)
        GetItemFunc    func(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)
        DeleteItemFunc func(ctx context.Context, params *dynamodb.DeleteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error)
        QueryFunc      func(ctx context.Context, params *dynamodb.QueryInput, optFns ...func(*dynamodb.Options)) (*dynamodb.QueryOutput, error)
        UpdateItemFunc func(ctx context.Context, params *dynamodb.UpdateItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.UpdateItemOutput, error)

        // Call tracking
        PutItemCalls    []*dynamodb.PutItemInput
        GetItemCalls    []*dynamodb.GetItemInput
        DeleteItemCalls []*dynamodb.DeleteItemInput
        QueryCalls      []*dynamodb.QueryInput
        UpdateItemCalls []*dynamodb.UpdateItemInput
}

// PutItem implements DynamoDB PutItem operation.
func (m *MockDynamoDBClient) PutItem(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.PutItemCalls = append(m.PutItemCalls, params)
        m.mu.Unlock()

        if m.PutItemFunc != nil </span><span class="cov0" title="0">{
                return m.PutItemFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return &amp;dynamodb.PutItemOutput{}, nil</span>
}

// GetItem implements DynamoDB GetItem operation.
func (m *MockDynamoDBClient) GetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.GetItemCalls = append(m.GetItemCalls, params)
        m.mu.Unlock()

        if m.GetItemFunc != nil </span><span class="cov0" title="0">{
                return m.GetItemFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return &amp;dynamodb.GetItemOutput{}, nil</span>
}

// DeleteItem implements DynamoDB DeleteItem operation.
func (m *MockDynamoDBClient) DeleteItem(ctx context.Context, params *dynamodb.DeleteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.DeleteItemCalls = append(m.DeleteItemCalls, params)
        m.mu.Unlock()

        if m.DeleteItemFunc != nil </span><span class="cov0" title="0">{
                return m.DeleteItemFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return &amp;dynamodb.DeleteItemOutput{}, nil</span>
}

// Query implements DynamoDB Query operation.
func (m *MockDynamoDBClient) Query(ctx context.Context, params *dynamodb.QueryInput, optFns ...func(*dynamodb.Options)) (*dynamodb.QueryOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.QueryCalls = append(m.QueryCalls, params)
        m.mu.Unlock()

        if m.QueryFunc != nil </span><span class="cov0" title="0">{
                return m.QueryFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return &amp;dynamodb.QueryOutput{}, nil</span>
}

// UpdateItem implements DynamoDB UpdateItem operation.
func (m *MockDynamoDBClient) UpdateItem(ctx context.Context, params *dynamodb.UpdateItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.UpdateItemOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.UpdateItemCalls = append(m.UpdateItemCalls, params)
        m.mu.Unlock()

        if m.UpdateItemFunc != nil </span><span class="cov0" title="0">{
                return m.UpdateItemFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return &amp;dynamodb.UpdateItemOutput{}, nil</span>
}

// Reset clears all call tracking data.
func (m *MockDynamoDBClient) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.PutItemCalls = nil
        m.GetItemCalls = nil
        m.DeleteItemCalls = nil
        m.QueryCalls = nil
        m.UpdateItemCalls = nil
}</span>

// ============================================================================
// MockSNSClient - SNS notifications
// ============================================================================

// MockSNSClient implements SNS client operations for testing.
// Tracks published messages for assertions.
type MockSNSClient struct {
        mu sync.Mutex

        // Configurable behavior functions
        PublishFunc func(ctx context.Context, params *sns.PublishInput, optFns ...func(*sns.Options)) (*sns.PublishOutput, error)

        // Call tracking
        PublishCalls []*sns.PublishInput

        // Auto-increment message ID counter
        messageIDCounter int
}

// Publish implements SNS Publish operation.
func (m *MockSNSClient) Publish(ctx context.Context, params *sns.PublishInput, optFns ...func(*sns.Options)) (*sns.PublishOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.PublishCalls = append(m.PublishCalls, params)
        m.messageIDCounter++
        msgID := m.messageIDCounter
        m.mu.Unlock()

        if m.PublishFunc != nil </span><span class="cov0" title="0">{
                return m.PublishFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return &amp;sns.PublishOutput{
                MessageId: aws.String(stringf("mock-message-%d", msgID)),
        }, nil</span>
}

// Reset clears all call tracking data and resets counters.
func (m *MockSNSClient) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.PublishCalls = nil
        m.messageIDCounter = 0
}</span>

// PublishCallCount returns the number of Publish calls made.
func (m *MockSNSClient) PublishCallCount() int <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return len(m.PublishCalls)
}</span>

// LastPublishedMessage returns the last published message input, or nil if none.
func (m *MockSNSClient) LastPublishedMessage() *sns.PublishInput <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        if len(m.PublishCalls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return m.PublishCalls[len(m.PublishCalls)-1]</span>
}

// ============================================================================
// MockSTSClient - STS operations
// ============================================================================

// MockSTSClient implements STS client operations for testing.
// Supports AssumeRole and GetCallerIdentity operations.
type MockSTSClient struct {
        mu sync.Mutex

        // Configurable behavior functions
        AssumeRoleFunc        func(ctx context.Context, params *sts.AssumeRoleInput, optFns ...func(*sts.Options)) (*sts.AssumeRoleOutput, error)
        GetCallerIdentityFunc func(ctx context.Context, params *sts.GetCallerIdentityInput, optFns ...func(*sts.Options)) (*sts.GetCallerIdentityOutput, error)

        // Call tracking
        AssumeRoleCalls        []*sts.AssumeRoleInput
        GetCallerIdentityCalls []*sts.GetCallerIdentityInput
}

// AssumeRole implements STS AssumeRole operation.
func (m *MockSTSClient) AssumeRole(ctx context.Context, params *sts.AssumeRoleInput, optFns ...func(*sts.Options)) (*sts.AssumeRoleOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.AssumeRoleCalls = append(m.AssumeRoleCalls, params)
        m.mu.Unlock()

        if m.AssumeRoleFunc != nil </span><span class="cov0" title="0">{
                return m.AssumeRoleFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return nil, errors.New("AssumeRole not implemented")</span>
}

// GetCallerIdentity implements STS GetCallerIdentity operation.
func (m *MockSTSClient) GetCallerIdentity(ctx context.Context, params *sts.GetCallerIdentityInput, optFns ...func(*sts.Options)) (*sts.GetCallerIdentityOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.GetCallerIdentityCalls = append(m.GetCallerIdentityCalls, params)
        m.mu.Unlock()

        if m.GetCallerIdentityFunc != nil </span><span class="cov0" title="0">{
                return m.GetCallerIdentityFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return &amp;sts.GetCallerIdentityOutput{
                Account: aws.String("123456789012"),
                Arn:     aws.String("arn:aws:sts::123456789012:assumed-role/MockRole/session"),
                UserId:  aws.String("AIDAMOCKUSERID"),
        }, nil</span>
}

// Reset clears all call tracking data.
func (m *MockSTSClient) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.AssumeRoleCalls = nil
        m.GetCallerIdentityCalls = nil
}</span>

// ============================================================================
// MockIAMClient - IAM operations
// ============================================================================

// MockIAMClient implements IAM client operations for testing.
// Supports GetRole operation.
type MockIAMClient struct {
        mu sync.Mutex

        // Configurable behavior functions
        GetRoleFunc func(ctx context.Context, params *iam.GetRoleInput, optFns ...func(*iam.Options)) (*iam.GetRoleOutput, error)

        // Call tracking
        GetRoleCalls []*iam.GetRoleInput
}

// GetRole implements IAM GetRole operation.
func (m *MockIAMClient) GetRole(ctx context.Context, params *iam.GetRoleInput, optFns ...func(*iam.Options)) (*iam.GetRoleOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.GetRoleCalls = append(m.GetRoleCalls, params)
        m.mu.Unlock()

        if m.GetRoleFunc != nil </span><span class="cov0" title="0">{
                return m.GetRoleFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return nil, errors.New("GetRole not implemented")</span>
}

// Reset clears all call tracking data.
func (m *MockIAMClient) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.GetRoleCalls = nil
}</span>

// ============================================================================
// MockCloudTrailClient - CloudTrail queries
// ============================================================================

// MockCloudTrailClient implements CloudTrail client operations for testing.
// Supports LookupEvents operation.
type MockCloudTrailClient struct {
        mu sync.Mutex

        // Configurable behavior functions
        LookupEventsFunc func(ctx context.Context, params *cloudtrail.LookupEventsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.LookupEventsOutput, error)

        // Call tracking
        LookupEventsCalls []*cloudtrail.LookupEventsInput
}

// LookupEvents implements CloudTrail LookupEvents operation.
func (m *MockCloudTrailClient) LookupEvents(ctx context.Context, params *cloudtrail.LookupEventsInput, optFns ...func(*cloudtrail.Options)) (*cloudtrail.LookupEventsOutput, error) <span class="cov0" title="0">{
        m.mu.Lock()
        m.LookupEventsCalls = append(m.LookupEventsCalls, params)
        m.mu.Unlock()

        if m.LookupEventsFunc != nil </span><span class="cov0" title="0">{
                return m.LookupEventsFunc(ctx, params, optFns...)
        }</span>
        <span class="cov0" title="0">return &amp;cloudtrail.LookupEventsOutput{}, nil</span>
}

// Reset clears all call tracking data.
func (m *MockCloudTrailClient) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.LookupEventsCalls = nil
}</span>

// ============================================================================
// Helper functions
// ============================================================================

// stringf is a simple helper to format strings (avoiding fmt import in mock file).
func stringf(format string, args ...interface{}) string <span class="cov0" title="0">{
        // Simple replacement for common case: %d
        if len(args) == 1 </span><span class="cov0" title="0">{
                if v, ok := args[0].(int); ok </span><span class="cov0" title="0">{
                        return format[:len(format)-2] + itoa(v)
                }</span>
        }
        <span class="cov0" title="0">return format</span>
}

// itoa converts an int to string without using strconv.
func itoa(i int) string <span class="cov0" title="0">{
        if i == 0 </span><span class="cov0" title="0">{
                return "0"
        }</span>
        <span class="cov0" title="0">neg := i &lt; 0
        if neg </span><span class="cov0" title="0">{
                i = -i
        }</span>
        <span class="cov0" title="0">var buf [20]byte
        pos := len(buf)
        for i &gt; 0 </span><span class="cov0" title="0">{
                pos--
                buf[pos] = byte('0' + i%10)
                i /= 10
        }</span>
        <span class="cov0" title="0">if neg </span><span class="cov0" title="0">{
                pos--
                buf[pos] = '-'
        }</span>
        <span class="cov0" title="0">return string(buf[pos:])</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package vault

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sts"
        ststypes "github.com/aws/aws-sdk-go-v2/service/sts/types"
)

// AssumeRoleProvider retrieves temporary credentials from STS using AssumeRole
type AssumeRoleProvider struct {
        StsClient         *sts.Client
        RoleARN           string
        RoleSessionName   string
        ExternalID        string
        Duration          time.Duration
        Tags              map[string]string
        TransitiveTagKeys []string
        SourceIdentity    string
        Mfa
}

// Retrieve generates a new set of temporary credentials using STS AssumeRole
func (p *AssumeRoleProvider) Retrieve(ctx context.Context) (aws.Credentials, error) <span class="cov0" title="0">{
        role, err := p.RetrieveStsCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return aws.Credentials{}, err
        }</span>

        <span class="cov0" title="0">return aws.Credentials{
                AccessKeyID:     *role.AccessKeyId,
                SecretAccessKey: *role.SecretAccessKey,
                SessionToken:    *role.SessionToken,
                CanExpire:       true,
                Expires:         *role.Expiration,
        }, nil</span>
}

func (p *AssumeRoleProvider) roleSessionName() string <span class="cov0" title="0">{
        if p.RoleSessionName == "" </span><span class="cov0" title="0">{
                // Try to work out a role name that will hopefully end up unique.
                return fmt.Sprintf("%d", time.Now().UTC().UnixNano())
        }</span>

        <span class="cov0" title="0">return p.RoleSessionName</span>
}

func (p *AssumeRoleProvider) RetrieveStsCredentials(ctx context.Context) (*ststypes.Credentials, error) <span class="cov0" title="0">{
        var err error

        input := &amp;sts.AssumeRoleInput{
                RoleArn:         aws.String(p.RoleARN),
                RoleSessionName: aws.String(p.roleSessionName()),
                DurationSeconds: aws.Int32(int32(p.Duration.Seconds())),
        }

        if p.ExternalID != "" </span><span class="cov0" title="0">{
                input.ExternalId = aws.String(p.ExternalID)
        }</span>

        <span class="cov0" title="0">if p.MfaSerial != "" </span><span class="cov0" title="0">{
                input.SerialNumber = aws.String(p.MfaSerial)
                input.TokenCode, err = p.GetMfaToken()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if len(p.Tags) &gt; 0 </span><span class="cov0" title="0">{
                input.Tags = make([]ststypes.Tag, 0)
                for key, value := range p.Tags </span><span class="cov0" title="0">{
                        tag := ststypes.Tag{
                                Key:   aws.String(key),
                                Value: aws.String(value),
                        }
                        input.Tags = append(input.Tags, tag)
                }</span>
        }

        <span class="cov0" title="0">if len(p.TransitiveTagKeys) &gt; 0 </span><span class="cov0" title="0">{
                input.TransitiveTagKeys = p.TransitiveTagKeys
        }</span>

        <span class="cov0" title="0">if p.SourceIdentity != "" </span><span class="cov0" title="0">{
                input.SourceIdentity = aws.String(p.SourceIdentity)
        }</span>

        <span class="cov0" title="0">resp, err := p.StsClient.AssumeRole(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Printf("Generated credentials %s using AssumeRole, expires in %s", FormatKeyForDisplay(*resp.Credentials.AccessKeyId), time.Until(*resp.Credentials.Expiration).String())

        return resp.Credentials, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package vault

import (
        "context"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sts"
        ststypes "github.com/aws/aws-sdk-go-v2/service/sts/types"
)

// AssumeRoleWithWebIdentityProvider retrieves temporary credentials from STS using AssumeRoleWithWebIdentity
type AssumeRoleWithWebIdentityProvider struct {
        StsClient               *sts.Client
        RoleARN                 string
        RoleSessionName         string
        WebIdentityTokenFile    string
        WebIdentityTokenProcess string
        ExternalID              string
        Duration                time.Duration
}

// Retrieve generates a new set of temporary credentials using STS AssumeRoleWithWebIdentity
func (p *AssumeRoleWithWebIdentityProvider) Retrieve(ctx context.Context) (aws.Credentials, error) <span class="cov0" title="0">{
        creds, err := p.RetrieveStsCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return aws.Credentials{}, err
        }</span>

        <span class="cov0" title="0">return aws.Credentials{
                AccessKeyID:     aws.ToString(creds.AccessKeyId),
                SecretAccessKey: aws.ToString(creds.SecretAccessKey),
                SessionToken:    aws.ToString(creds.SessionToken),
                CanExpire:       true,
                Expires:         aws.ToTime(creds.Expiration),
        }, nil</span>
}

func (p *AssumeRoleWithWebIdentityProvider) roleSessionName() string <span class="cov0" title="0">{
        if p.RoleSessionName == "" </span><span class="cov0" title="0">{
                // Try to work out a role name that will hopefully end up unique.
                return fmt.Sprintf("%d", time.Now().UTC().UnixNano())
        }</span>

        <span class="cov0" title="0">return p.RoleSessionName</span>
}

func (p *AssumeRoleWithWebIdentityProvider) RetrieveStsCredentials(ctx context.Context) (*ststypes.Credentials, error) <span class="cov0" title="0">{
        var err error

        webIdentityToken, err := p.webIdentityToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := p.StsClient.AssumeRoleWithWebIdentity(ctx, &amp;sts.AssumeRoleWithWebIdentityInput{
                RoleArn:          aws.String(p.RoleARN),
                RoleSessionName:  aws.String(p.roleSessionName()),
                DurationSeconds:  aws.Int32(int32(p.Duration.Seconds())),
                WebIdentityToken: aws.String(webIdentityToken),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Printf("Generated credentials %s using AssumeRoleWithWebIdentity, expires in %s", FormatKeyForDisplay(*resp.Credentials.AccessKeyId), time.Until(*resp.Credentials.Expiration).String())

        return resp.Credentials, nil</span>
}

func (p *AssumeRoleWithWebIdentityProvider) webIdentityToken() (string, error) <span class="cov0" title="0">{
        // Read OpenID Connect token from WebIdentityTokenFile
        if p.WebIdentityTokenFile != "" </span><span class="cov0" title="0">{
                b, err := os.ReadFile(p.WebIdentityTokenFile)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("unable to read file at %s: %v", p.WebIdentityTokenFile, err)
                }</span>

                <span class="cov0" title="0">return string(b), nil</span>
        }

        // Exec WebIdentityTokenProcess to retrieve OpenID Connect token
        <span class="cov0" title="0">return executeProcess(p.WebIdentityTokenProcess)</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package vault

import (
        "context"
        "log"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        ststypes "github.com/aws/aws-sdk-go-v2/service/sts/types"
)

type StsSessionProvider interface {
        aws.CredentialsProvider
        RetrieveStsCredentials(ctx context.Context) (*ststypes.Credentials, error)
}

// CachedSessionProvider retrieves cached credentials from the keyring, or if no credentials are cached
// retrieves temporary credentials using the CredentialsFunc
type CachedSessionProvider struct {
        SessionKey      SessionMetadata
        SessionProvider StsSessionProvider
        Keyring         *SessionKeyring
        ExpiryWindow    time.Duration
}

func (p *CachedSessionProvider) RetrieveStsCredentials(ctx context.Context) (*ststypes.Credentials, error) <span class="cov0" title="0">{
        creds, err := p.Keyring.Get(p.SessionKey)

        if err != nil || time.Until(*creds.Expiration) &lt; p.ExpiryWindow </span><span class="cov0" title="0">{
                // lookup missed, we need to create a new one.
                creds, err = p.SessionProvider.RetrieveStsCredentials(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">err = p.Keyring.Set(p.SessionKey, creds)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("Re-using cached credentials %s from %s, expires in %s", FormatKeyForDisplay(*creds.AccessKeyId), p.SessionKey.Type, time.Until(*creds.Expiration).String())
        }</span>

        <span class="cov0" title="0">return creds, nil</span>
}

// Retrieve returns cached credentials from the keyring, or if no credentials are cached
// generates a new set of temporary credentials using the CredentialsFunc
func (p *CachedSessionProvider) Retrieve(ctx context.Context) (aws.Credentials, error) <span class="cov0" title="0">{
        creds, err := p.RetrieveStsCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return aws.Credentials{}, err
        }</span>

        <span class="cov0" title="0">return aws.Credentials{
                AccessKeyID:     aws.ToString(creds.AccessKeyId),
                SecretAccessKey: aws.ToString(creds.SecretAccessKey),
                SessionToken:    aws.ToString(creds.SessionToken),
                CanExpire:       true,
                Expires:         aws.ToTime(creds.Expiration),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package vault

import (
        "errors"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "strings"
        "time"

        ini "gopkg.in/ini.v1"
)

const (
        // DefaultSessionDuration is the default duration for GetSessionToken or AssumeRole sessions
        DefaultSessionDuration = time.Hour * 1

        // DefaultChainedSessionDuration is the default duration for GetSessionToken sessions when chaining
        DefaultChainedSessionDuration = time.Hour * 8

        defaultSectionName          = "default"
        roleChainingMaximumDuration = 1 * time.Hour
)

func init() <span class="cov1" title="1">{
        ini.PrettyFormat = false
}</span>

// ConfigFile is an abstraction over what is in ~/.aws/config
type ConfigFile struct {
        Path    string
        iniFile *ini.File
}

// configPath returns either $AWS_CONFIG_FILE or ~/.aws/config
func configPath() (string, error) <span class="cov0" title="0">{
        file := os.Getenv("AWS_CONFIG_FILE")
        if file == "" </span><span class="cov0" title="0">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">file = filepath.Join(home, "/.aws/config")</span>
        } else<span class="cov0" title="0"> {
                log.Printf("Using AWS_CONFIG_FILE value: %s", file)
        }</span>
        <span class="cov0" title="0">return file, nil</span>
}

// createConfigFilesIfMissing will create the config directory and file if they do not exist
func createConfigFilesIfMissing() error <span class="cov0" title="0">{
        file, err := configPath()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">dir := filepath.Dir(file)
        if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                err = os.Mkdir(dir, 0700)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">log.Printf("Config directory %s created", dir)</span>
        }
        <span class="cov0" title="0">if _, err := os.Stat(file); os.IsNotExist(err) </span><span class="cov0" title="0">{
                newFile, err := os.Create(file)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Config file %s not created", file)
                        return err
                }</span>
                <span class="cov0" title="0">newFile.Close()
                log.Printf("Config file %s created", file)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// LoadConfig loads and parses a config file. No error is returned if the file doesn't exist
func LoadConfig(path string) (*ConfigFile, error) <span class="cov7" title="18">{
        config := &amp;ConfigFile{
                Path: path,
        }
        if _, err := os.Stat(path); err == nil </span><span class="cov7" title="18">{
                if parseErr := config.parseFile(); parseErr != nil </span><span class="cov0" title="0">{
                        return nil, parseErr
                }</span>
        } else<span class="cov0" title="0"> {
                log.Printf("Config file %s doesn't exist so lets create it", path)
                err := createConfigFilesIfMissing()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if parseErr := config.parseFile(); parseErr != nil </span><span class="cov0" title="0">{
                        return nil, parseErr
                }</span>
        }
        <span class="cov7" title="18">return config, nil</span>
}

// LoadConfigFromEnv finds the config file from the environment
func LoadConfigFromEnv() (*ConfigFile, error) <span class="cov0" title="0">{
        file, err := configPath()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Printf("Loading config file %s", file)
        return LoadConfig(file)</span>
}

func (c *ConfigFile) parseFile() error <span class="cov7" title="18">{
        log.Printf("Parsing config file %s", c.Path)

        f, err := ini.LoadSources(ini.LoadOptions{
                AllowNestedValues:   true,
                InsensitiveSections: false,
                InsensitiveKeys:     true,
        }, c.Path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error parsing config file %s: %w", c.Path, err)
        }</span>
        <span class="cov7" title="18">c.iniFile = f
        return nil</span>
}

// ProfileSection is a profile section of the config file
type ProfileSection struct {
        Name                    string `ini:"-"`
        MfaSerial               string `ini:"mfa_serial,omitempty"`
        RoleARN                 string `ini:"role_arn,omitempty"`
        ExternalID              string `ini:"external_id,omitempty"`
        Region                  string `ini:"region,omitempty"`
        RoleSessionName         string `ini:"role_session_name,omitempty"`
        DurationSeconds         uint   `ini:"duration_seconds,omitempty"`
        SourceProfile           string `ini:"source_profile,omitempty"`
        IncludeProfile          string `ini:"include_profile,omitempty"`
        SSOSession              string `ini:"sso_session,omitempty"`
        SSOStartURL             string `ini:"sso_start_url,omitempty"`
        SSORegion               string `ini:"sso_region,omitempty"`
        SSOAccountID            string `ini:"sso_account_id,omitempty"`
        SSORoleName             string `ini:"sso_role_name,omitempty"`
        WebIdentityTokenFile    string `ini:"web_identity_token_file,omitempty"`
        WebIdentityTokenProcess string `ini:"web_identity_token_process,omitempty"`
        STSRegionalEndpoints    string `ini:"sts_regional_endpoints,omitempty"`
        EndpointURL             string `ini:"endpoint_url,omitempty"`
        SessionTags             string `ini:"session_tags,omitempty"`
        TransitiveSessionTags   string `ini:"transitive_session_tags,omitempty"`
        SourceIdentity          string `ini:"source_identity,omitempty"`
        CredentialProcess       string `ini:"credential_process,omitempty"`
        MfaProcess              string `ini:"mfa_process,omitempty"`
}

// SSOSessionSection is a [sso-session] section of the config file
type SSOSessionSection struct {
        Name                  string `ini:"-"`
        SSOStartURL           string `ini:"sso_start_url,omitempty"`
        SSORegion             string `ini:"sso_region,omitempty"`
        SSORegistrationScopes string `ini:"sso_registration_scopes,omitempty"`
}

func (s ProfileSection) IsEmpty() bool <span class="cov4" title="4">{
        s.Name = ""
        return s == ProfileSection{}
}</span>

// ProfileSections returns all the profile sections in the config
func (c *ConfigFile) ProfileSections() []ProfileSection <span class="cov3" title="3">{
        result := []ProfileSection{}

        if c.iniFile == nil </span><span class="cov0" title="0">{
                return result
        }</span>
        <span class="cov3" title="3">for _, section := range c.iniFile.SectionStrings() </span><span class="cov7" title="23">{
                if section == defaultSectionName || strings.HasPrefix(section, "profile ") </span><span class="cov7" title="18">{
                        profile, _ := c.ProfileSection(strings.TrimPrefix(section, "profile "))

                        // ignore the default profile if it's empty
                        if section == defaultSectionName &amp;&amp; profile.IsEmpty() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov7" title="18">result = append(result, profile)</span>
                } else<span class="cov4" title="5"> if strings.HasPrefix(section, "sso-session ") </span><span class="cov2" title="2">{
                        // Not a profile
                        continue</span>
                } else<span class="cov3" title="3"> {
                        log.Printf("Unrecognised ini file section: %s", section)
                        continue</span>
                }
        }

        <span class="cov3" title="3">return result</span>
}

// ProfileSection returns the profile section with the matching name. If there isn't any,
// an empty profile with the provided name is returned, along with false.
func (c *ConfigFile) ProfileSection(name string) (ProfileSection, bool) <span class="cov10" title="57">{
        profile := ProfileSection{
                Name: name,
        }
        if c.iniFile == nil </span><span class="cov0" title="0">{
                return profile, false
        }</span>
        // default profile name has a slightly different section format
        <span class="cov10" title="57">sectionName := "profile " + name
        if name == defaultSectionName </span><span class="cov7" title="18">{
                sectionName = defaultSectionName
        }</span>
        <span class="cov10" title="57">section, err := c.iniFile.GetSection(sectionName)
        if err != nil </span><span class="cov6" title="11">{
                return profile, false
        }</span>
        <span class="cov9" title="46">if err = section.MapTo(&amp;profile); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov9" title="46">return profile, true</span>
}

// SSOSessionSection returns the [sso-session] section with the matching name. If there isn't any,
// an empty sso-session with the provided name is returned, along with false.
func (c *ConfigFile) SSOSessionSection(name string) (SSOSessionSection, bool) <span class="cov3" title="3">{
        ssoSession := SSOSessionSection{
                Name: name,
        }
        if c.iniFile == nil </span><span class="cov0" title="0">{
                return ssoSession, false
        }</span>
        <span class="cov3" title="3">sectionName := "sso-session " + name
        section, err := c.iniFile.GetSection(sectionName)
        if err != nil </span><span class="cov0" title="0">{
                return ssoSession, false
        }</span>
        <span class="cov3" title="3">if err = section.MapTo(&amp;ssoSession); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov3" title="3">return ssoSession, true</span>
}

func (c *ConfigFile) Save() error <span class="cov3" title="3">{
        return c.iniFile.SaveTo(c.Path)
}</span>

// Add the profile to the configuration file
func (c *ConfigFile) Add(profile ProfileSection) error <span class="cov2" title="2">{
        if c.iniFile == nil </span><span class="cov0" title="0">{
                return errors.New("No iniFile to add to")
        }</span>
        // default profile name has a slightly different section format
        <span class="cov2" title="2">sectionName := "profile " + profile.Name
        if profile.Name == defaultSectionName </span><span class="cov0" title="0">{
                sectionName = defaultSectionName
        }</span>
        <span class="cov2" title="2">section, err := c.iniFile.NewSection(sectionName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error creating section %q: %v", profile.Name, err)
        }</span>
        <span class="cov2" title="2">if err = section.ReflectFrom(&amp;profile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error mapping profile to ini file: %v", err)
        }</span>
        <span class="cov2" title="2">return c.Save()</span>
}

// ProfileNames returns a slice of profile names from the AWS config
func (c *ConfigFile) ProfileNames() []string <span class="cov0" title="0">{
        profileNames := []string{}
        for _, profile := range c.ProfileSections() </span><span class="cov0" title="0">{
                profileNames = append(profileNames, profile.Name)
        }</span>
        <span class="cov0" title="0">return profileNames</span>
}

// ConfigLoader loads config from configfile and environment variables
type ConfigLoader struct {
        BaseConfig    ProfileConfig
        File          *ConfigFile
        ActiveProfile string

        visitedProfiles []string
}

func NewConfigLoader(baseConfig ProfileConfig, file *ConfigFile, activeProfile string) *ConfigLoader <span class="cov0" title="0">{
        return &amp;ConfigLoader{
                BaseConfig:    baseConfig,
                File:          file,
                ActiveProfile: activeProfile,
        }
}</span>

func (cl *ConfigLoader) visitProfile(name string) bool <span class="cov8" title="30">{
        for _, p := range cl.visitedProfiles </span><span class="cov7" title="18">{
                if p == name </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="30">cl.visitedProfiles = append(cl.visitedProfiles, name)
        return true</span>
}

func (cl *ConfigLoader) resetLoopDetection() <span class="cov6" title="14">{
        cl.visitedProfiles = []string{}
}</span>

func (cl *ConfigLoader) populateFromDefaults(config *ProfileConfig) <span class="cov6" title="14">{
        if config.AssumeRoleDuration == 0 </span><span class="cov6" title="14">{
                config.AssumeRoleDuration = DefaultSessionDuration
        }</span>
        <span class="cov6" title="14">if config.GetFederationTokenDuration == 0 </span><span class="cov6" title="14">{
                config.GetFederationTokenDuration = DefaultSessionDuration
        }</span>
        <span class="cov6" title="14">if config.NonChainedGetSessionTokenDuration == 0 </span><span class="cov6" title="14">{
                config.NonChainedGetSessionTokenDuration = DefaultSessionDuration
        }</span>
        <span class="cov6" title="14">if config.ChainedGetSessionTokenDuration == 0 </span><span class="cov6" title="14">{
                config.ChainedGetSessionTokenDuration = DefaultChainedSessionDuration
        }</span>
}

func (cl *ConfigLoader) populateFromConfigFile(config *ProfileConfig, profileName string) error <span class="cov8" title="30">{
        if !cl.visitProfile(profileName) </span><span class="cov0" title="0">{
                return fmt.Errorf("Loop detected in config file for profile '%s'", profileName)
        }</span>

        <span class="cov8" title="30">psection, ok := cl.File.ProfileSection(profileName)
        if !ok </span><span class="cov6" title="10">{
                // ignore missing profiles
                log.Printf("Profile '%s' missing in config file", profileName)
        }</span>

        <span class="cov8" title="30">if config.MfaSerial == "" </span><span class="cov8" title="29">{
                config.MfaSerial = psection.MfaSerial
        }</span>
        <span class="cov8" title="30">if config.RoleARN == "" </span><span class="cov8" title="29">{
                config.RoleARN = psection.RoleARN
        }</span>
        <span class="cov8" title="30">if config.ExternalID == "" </span><span class="cov8" title="30">{
                config.ExternalID = psection.ExternalID
        }</span>
        <span class="cov8" title="30">if config.Region == "" </span><span class="cov8" title="25">{
                config.Region = psection.Region
        }</span>
        <span class="cov8" title="30">if config.RoleSessionName == "" </span><span class="cov8" title="30">{
                config.RoleSessionName = psection.RoleSessionName
        }</span>
        <span class="cov8" title="30">if config.AssumeRoleDuration == 0 </span><span class="cov8" title="30">{
                config.AssumeRoleDuration = time.Duration(psection.DurationSeconds) * time.Second
        }</span>
        <span class="cov8" title="30">if config.SourceProfileName == "" </span><span class="cov8" title="24">{
                config.SourceProfileName = psection.SourceProfile
        }</span>
        <span class="cov8" title="30">if config.SSOSession == "" </span><span class="cov8" title="28">{
                config.SSOSession = psection.SSOSession
                if psection.SSOSession != "" </span><span class="cov3" title="3">{
                        // Populate profile with values from [sso-session].
                        ssoSection, ok := cl.File.SSOSessionSection(psection.SSOSession)
                        if ok </span><span class="cov3" title="3">{
                                config.SSOStartURL = ssoSection.SSOStartURL
                                config.SSORegion = ssoSection.SSORegion
                                config.SSORegistrationScopes = ssoSection.SSORegistrationScopes
                        }</span> else<span class="cov0" title="0"> {
                                // ignore missing profiles
                                log.Printf("[sso-session] '%s' missing in config file", psection.SSOSession)
                        }</span>
                }
        }
        <span class="cov8" title="30">if config.SSOStartURL == "" </span><span class="cov8" title="25">{
                config.SSOStartURL = psection.SSOStartURL
        }</span>
        <span class="cov8" title="30">if config.SSORegion == "" </span><span class="cov8" title="25">{
                config.SSORegion = psection.SSORegion
        }</span>
        <span class="cov8" title="30">if config.SSOAccountID == "" </span><span class="cov8" title="28">{
                config.SSOAccountID = psection.SSOAccountID
        }</span>
        <span class="cov8" title="30">if config.SSORoleName == "" </span><span class="cov8" title="29">{
                config.SSORoleName = psection.SSORoleName
        }</span>
        <span class="cov8" title="30">if config.WebIdentityTokenFile == "" </span><span class="cov8" title="30">{
                config.WebIdentityTokenFile = psection.WebIdentityTokenFile
        }</span>
        <span class="cov8" title="30">if config.WebIdentityTokenProcess == "" </span><span class="cov8" title="29">{
                config.WebIdentityTokenProcess = psection.WebIdentityTokenProcess
        }</span>
        <span class="cov8" title="30">if config.STSRegionalEndpoints == "" </span><span class="cov8" title="30">{
                config.STSRegionalEndpoints = psection.STSRegionalEndpoints
        }</span>
        <span class="cov8" title="30">if config.EndpointURL == "" </span><span class="cov8" title="30">{
                config.EndpointURL = psection.EndpointURL
        }</span>
        <span class="cov8" title="30">if config.SourceIdentity == "" </span><span class="cov8" title="30">{
                config.SourceIdentity = psection.SourceIdentity
        }</span>
        <span class="cov8" title="30">if config.CredentialProcess == "" </span><span class="cov8" title="29">{
                config.CredentialProcess = psection.CredentialProcess
        }</span>
        <span class="cov8" title="30">if config.MfaProcess == "" </span><span class="cov8" title="30">{
                config.MfaProcess = psection.MfaProcess
        }</span>
        <span class="cov8" title="30">if sessionTags := psection.SessionTags; sessionTags != "" &amp;&amp; config.SessionTags == nil </span><span class="cov2" title="2">{
                err := config.SetSessionTags(sessionTags)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Failed to parse session_tags profile setting: %s", err)
                }</span>
        }
        <span class="cov8" title="30">if transitiveSessionTags := psection.TransitiveSessionTags; transitiveSessionTags != "" &amp;&amp; config.TransitiveSessionTags == nil </span><span class="cov2" title="2">{
                config.SetTransitiveSessionTags(transitiveSessionTags)
        }</span>

        <span class="cov8" title="30">if psection.IncludeProfile != "" </span><span class="cov2" title="2">{
                err := cl.populateFromConfigFile(config, psection.IncludeProfile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="28"> if profileName != defaultSectionName </span><span class="cov6" title="14">{
                err := cl.populateFromConfigFile(config, defaultSectionName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Ignore source_profile if it recursively refers to the profile
        <span class="cov8" title="30">if config.SourceProfileName == config.ProfileName </span><span class="cov1" title="1">{
                config.SourceProfileName = ""
        }</span>

        <span class="cov8" title="30">return nil</span>
}

func (cl *ConfigLoader) populateFromEnv(profile *ProfileConfig) <span class="cov6" title="14">{
        if region := os.Getenv("AWS_REGION"); region != "" &amp;&amp; profile.Region == "" </span><span class="cov0" title="0">{
                log.Printf("Using region %q from AWS_REGION", region)
                profile.Region = region
        }</span>

        <span class="cov6" title="14">if region := os.Getenv("AWS_DEFAULT_REGION"); region != "" &amp;&amp; profile.Region == "" </span><span class="cov0" title="0">{
                log.Printf("Using region %q from AWS_DEFAULT_REGION", region)
                profile.Region = region
        }</span>

        <span class="cov6" title="14">if stsRegionalEndpoints := os.Getenv("AWS_STS_REGIONAL_ENDPOINTS"); stsRegionalEndpoints != "" &amp;&amp; profile.STSRegionalEndpoints == "" </span><span class="cov0" title="0">{
                log.Printf("Using %q from AWS_STS_REGIONAL_ENDPOINTS", stsRegionalEndpoints)
                profile.STSRegionalEndpoints = stsRegionalEndpoints
        }</span>

        <span class="cov6" title="14">if endpointURL := os.Getenv("AWS_ENDPOINT_URL"); endpointURL != "" &amp;&amp; profile.EndpointURL == "" </span><span class="cov0" title="0">{
                log.Printf("Using %q from AWS_ENDPOINT_URL", endpointURL)
                profile.EndpointURL = endpointURL
        }</span>

        <span class="cov6" title="14">if mfaSerial := os.Getenv("AWS_MFA_SERIAL"); mfaSerial != "" &amp;&amp; profile.MfaSerial == "" </span><span class="cov0" title="0">{
                log.Printf("Using mfa_serial %q from AWS_MFA_SERIAL", mfaSerial)
                profile.MfaSerial = mfaSerial
        }</span>

        <span class="cov6" title="14">var err error
        if assumeRoleTTL := os.Getenv("AWS_ASSUME_ROLE_TTL"); assumeRoleTTL != "" &amp;&amp; profile.AssumeRoleDuration == 0 </span><span class="cov0" title="0">{
                profile.AssumeRoleDuration, err = time.ParseDuration(assumeRoleTTL)
                if err == nil </span><span class="cov0" title="0">{
                        log.Printf("Using duration_seconds %q from AWS_ASSUME_ROLE_TTL", profile.AssumeRoleDuration)
                }</span>
        }

        <span class="cov6" title="14">if sessionTTL := os.Getenv("AWS_SESSION_TOKEN_TTL"); sessionTTL != "" &amp;&amp; profile.NonChainedGetSessionTokenDuration == 0 </span><span class="cov0" title="0">{
                profile.NonChainedGetSessionTokenDuration, err = time.ParseDuration(sessionTTL)
                if err == nil </span><span class="cov0" title="0">{
                        log.Printf("Using a session duration of %q from AWS_SESSION_TOKEN_TTL", profile.NonChainedGetSessionTokenDuration)
                }</span>
        }

        <span class="cov6" title="14">if sessionTTL := os.Getenv("AWS_CHAINED_SESSION_TOKEN_TTL"); sessionTTL != "" &amp;&amp; profile.ChainedGetSessionTokenDuration == 0 </span><span class="cov0" title="0">{
                profile.ChainedGetSessionTokenDuration, err = time.ParseDuration(sessionTTL)
                if err == nil </span><span class="cov0" title="0">{
                        log.Printf("Using a cached MFA session duration of %q from AWS_CACHED_SESSION_TOKEN_TTL", profile.ChainedGetSessionTokenDuration)
                }</span>
        }

        <span class="cov6" title="14">if federationTokenTTL := os.Getenv("AWS_FEDERATION_TOKEN_TTL"); federationTokenTTL != "" &amp;&amp; profile.GetFederationTokenDuration == 0 </span><span class="cov0" title="0">{
                profile.GetFederationTokenDuration, err = time.ParseDuration(federationTokenTTL)
                if err == nil </span><span class="cov0" title="0">{
                        log.Printf("Using a session duration of %q from AWS_FEDERATION_TOKEN_TTL", profile.GetFederationTokenDuration)
                }</span>
        }

        // AWS_ROLE_ARN, AWS_ROLE_SESSION_NAME, AWS_SESSION_TAGS, AWS_TRANSITIVE_TAGS and AWS_SOURCE_IDENTITY only apply to the target profile
        <span class="cov6" title="14">if profile.ProfileName == cl.ActiveProfile </span><span class="cov4" title="6">{
                if roleARN := os.Getenv("AWS_ROLE_ARN"); roleARN != "" &amp;&amp; profile.RoleARN == "" </span><span class="cov0" title="0">{
                        log.Printf("Using role_arn %q from AWS_ROLE_ARN", roleARN)
                        profile.RoleARN = roleARN
                }</span>

                <span class="cov4" title="6">if roleSessionName := os.Getenv("AWS_ROLE_SESSION_NAME"); roleSessionName != "" &amp;&amp; profile.RoleSessionName == "" </span><span class="cov0" title="0">{
                        log.Printf("Using role_session_name %q from AWS_ROLE_SESSION_NAME", roleSessionName)
                        profile.RoleSessionName = roleSessionName
                }</span>

                <span class="cov4" title="6">if sessionTags := os.Getenv("AWS_SESSION_TAGS"); sessionTags != "" &amp;&amp; profile.SessionTags == nil </span><span class="cov2" title="2">{
                        err := profile.SetSessionTags(sessionTags)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("Failed to parse AWS_SESSION_TAGS environment variable: %s", err)
                        }</span>
                        <span class="cov2" title="2">log.Printf("Using session_tags %v from AWS_SESSION_TAGS", profile.SessionTags)</span>
                }

                <span class="cov4" title="6">if transitiveSessionTags := os.Getenv("AWS_TRANSITIVE_TAGS"); transitiveSessionTags != "" &amp;&amp; profile.TransitiveSessionTags == nil </span><span class="cov2" title="2">{
                        profile.SetTransitiveSessionTags(transitiveSessionTags)
                        log.Printf("Using transitive_session_tags %v from AWS_TRANSITIVE_TAGS", profile.TransitiveSessionTags)
                }</span>

                <span class="cov4" title="6">if sourceIdentity := os.Getenv("AWS_SOURCE_IDENTITY"); sourceIdentity != "" &amp;&amp; profile.SourceIdentity == "" </span><span class="cov0" title="0">{
                        profile.SourceIdentity = sourceIdentity
                        log.Printf("Using source_identity %v from AWS_SOURCE_IDENTITY", profile.SourceIdentity)
                }</span>
        }
}

func (cl *ConfigLoader) hydrateSourceConfig(config *ProfileConfig) error <span class="cov6" title="14">{
        if config.SourceProfileName != "" </span><span class="cov4" title="4">{
                sc, err := cl.GetProfileConfig(config.SourceProfileName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov4" title="4">sc.ChainedFromProfile = config
                config.SourceProfile = sc</span>
        }
        <span class="cov6" title="14">return nil</span>
}

// GetProfileConfig loads the profile from the config file and environment variables into config
func (cl *ConfigLoader) GetProfileConfig(profileName string) (*ProfileConfig, error) <span class="cov6" title="14">{
        config := cl.BaseConfig
        config.ProfileName = profileName
        cl.populateFromEnv(&amp;config)

        cl.resetLoopDetection()
        err := cl.populateFromConfigFile(&amp;config, profileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="14">cl.populateFromDefaults(&amp;config)

        err = cl.hydrateSourceConfig(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="14">return &amp;config, nil</span>
}

// ProfileConfig is a collection of configuration options for creating temporary credentials
type ProfileConfig struct {
        // ProfileName specifies the name of the profile config
        ProfileName string

        // SourceProfile is the profile where credentials come from
        SourceProfileName string

        // SourceProfile is the profile where credentials come from
        SourceProfile *ProfileConfig

        // ChainedFromProfile is the profile that used this profile as its source profile
        ChainedFromProfile *ProfileConfig

        // Region is the AWS region
        Region string

        // STSRegionalEndpoints sets STS endpoint resolution logic, must be "regional" or "legacy"
        STSRegionalEndpoints string

        // EndpointURL specifies custom endpoint URL
        EndpointURL string

        // Mfa config
        MfaSerial       string
        MfaToken        string
        MfaPromptMethod string

        // MfaProcess specifies external command to run to get an MFA token
        MfaProcess string

        // AssumeRole config
        RoleARN         string
        RoleSessionName string
        ExternalID      string

        // AssumeRoleWithWebIdentity config
        WebIdentityTokenFile    string
        WebIdentityTokenProcess string

        // GetSessionTokenDuration specifies the wanted duration for credentials generated with AssumeRole
        AssumeRoleDuration time.Duration

        // NonChainedGetSessionTokenDuration specifies the wanted duration for credentials generated with GetSessionToken
        NonChainedGetSessionTokenDuration time.Duration

        // ChainedGetSessionTokenDuration specifies the wanted duration for credentials generated with GetSessionToken when chaining
        ChainedGetSessionTokenDuration time.Duration

        // GetFederationTokenDuration specifies the wanted duration for credentials generated with GetFederationToken
        GetFederationTokenDuration time.Duration

        // SSOSession specifies the [sso-session] section name.
        SSOSession string

        // SSOStartURL specifies the URL for the AWS IAM Identity Center user portal, legacy option.
        SSOStartURL string

        // SSORegion specifies the region for the AWS IAM Identity Center user portal, legacy option.
        SSORegion string

        // SSORegistrationScopes specifies registration scopes for the AWS IAM Identity Center user portal.
        SSORegistrationScopes string

        // SSOAccountID specifies the AWS account ID for the profile.
        SSOAccountID string

        // SSORoleName specifies the AWS IAM Role name to target.
        SSORoleName string

        // SSOUseStdout specifies that the system browser should not be automatically opened
        SSOUseStdout bool

        // SessionTags specifies assumed role Session Tags
        SessionTags map[string]string

        // TransitiveSessionTags specifies assumed role Transitive Session Tags keys
        TransitiveSessionTags []string

        // SourceIdentity specifies assumed role Source Identity
        SourceIdentity string

        // CredentialProcess specifies external command to run to get an AWS credential
        CredentialProcess string
}

// SetSessionTags parses a comma separated key=vaue string and sets Config.SessionTags map
func (c *ProfileConfig) SetSessionTags(s string) error <span class="cov6" title="12">{
        c.SessionTags = make(map[string]string)
        for _, tag := range strings.Split(s, ",") </span><span class="cov7" title="23">{
                kvPair := strings.SplitN(tag, "=", 2)
                if len(kvPair) != 2 </span><span class="cov4" title="5">{
                        return errors.New("session tags string must be &lt;key1&gt;=&lt;value1&gt;,[&lt;key2&gt;=&lt;value2&gt;[,...]]")
                }</span>
                <span class="cov7" title="18">c.SessionTags[strings.TrimSpace(kvPair[0])] = strings.TrimSpace(kvPair[1])</span>
        }

        <span class="cov5" title="7">return nil</span>
}

// SetTransitiveSessionTags parses a comma separated string and sets Config.TransitiveSessionTags
func (c *ProfileConfig) SetTransitiveSessionTags(s string) <span class="cov6" title="11">{
        for _, tag := range strings.Split(s, ",") </span><span class="cov7" title="21">{
                if tag = strings.TrimSpace(tag); tag != "" </span><span class="cov7" title="16">{
                        c.TransitiveSessionTags = append(c.TransitiveSessionTags, tag)
                }</span>
        }
}

func (c *ProfileConfig) IsChained() bool <span class="cov0" title="0">{
        return c.ChainedFromProfile != nil
}</span>

func (c *ProfileConfig) HasSourceProfile() bool <span class="cov4" title="5">{
        return c.SourceProfile != nil
}</span>

func (c *ProfileConfig) HasMfaSerial() bool <span class="cov0" title="0">{
        return c.MfaSerial != ""
}</span>

func (c *ProfileConfig) HasRole() bool <span class="cov2" title="2">{
        return c.RoleARN != ""
}</span>

func (c *ProfileConfig) HasSSOSession() bool <span class="cov0" title="0">{
        return c.SSOSession != ""
}</span>

func (c *ProfileConfig) HasSSOStartURL() bool <span class="cov3" title="3">{
        return c.SSOStartURL != ""
}</span>

func (c *ProfileConfig) HasWebIdentity() bool <span class="cov2" title="2">{
        return c.WebIdentityTokenFile != "" || c.WebIdentityTokenProcess != ""
}</span>

func (c *ProfileConfig) HasCredentialProcess() bool <span class="cov1" title="1">{
        return c.CredentialProcess != ""
}</span>

func (c *ProfileConfig) GetSessionTokenDuration() time.Duration <span class="cov0" title="0">{
        if c.IsChained() </span><span class="cov0" title="0">{
                return c.ChainedGetSessionTokenDuration
        }</span>
        <span class="cov0" title="0">return c.NonChainedGetSessionTokenDuration</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package vault

import (
        "encoding/json"
        "fmt"

        "github.com/byteness/keyring"
        "github.com/aws/aws-sdk-go-v2/aws"
)

type CredentialKeyring struct {
        Keyring keyring.Keyring
}

func (ck *CredentialKeyring) Keys() (credentialsNames []string, err error) <span class="cov0" title="0">{
        allKeys, err := ck.Keyring.Keys()
        if err != nil </span><span class="cov0" title="0">{
                return credentialsNames, err
        }</span>
        <span class="cov0" title="0">for _, keyName := range allKeys </span><span class="cov0" title="0">{
                if !IsSessionKey(keyName) &amp;&amp; !IsOIDCTokenKey(keyName) </span><span class="cov0" title="0">{
                        credentialsNames = append(credentialsNames, keyName)
                }</span>
        }
        <span class="cov0" title="0">return credentialsNames, nil</span>
}

func (ck *CredentialKeyring) Has(credentialsName string) (bool, error) <span class="cov10" title="4">{
        allKeys, err := ck.Keyring.Keys()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov10" title="4">for _, keyName := range allKeys </span><span class="cov0" title="0">{
                if keyName == credentialsName </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }
        <span class="cov10" title="4">return false, nil</span>
}

func (ck *CredentialKeyring) Get(credentialsName string) (creds aws.Credentials, err error) <span class="cov0" title="0">{
        item, err := ck.Keyring.Get(credentialsName)
        if err != nil </span><span class="cov0" title="0">{
                return creds, err
        }</span>
        <span class="cov0" title="0">if err = json.Unmarshal(item.Data, &amp;creds); err != nil </span><span class="cov0" title="0">{
                return creds, fmt.Errorf("Invalid data in keyring: %v", err)
        }</span>
        <span class="cov0" title="0">return creds, err</span>
}

func (ck *CredentialKeyring) Set(credentialsName string, creds aws.Credentials) error <span class="cov0" title="0">{
        bytes, err := json.Marshal(creds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return ck.Keyring.Set(keyring.Item{
                Key:   credentialsName,
                Label: fmt.Sprintf("aws-vault (%s)", credentialsName),
                Data:  bytes,

                // specific Keychain settings
                KeychainNotTrustApplication: true,
        })</span>
}

func (ck *CredentialKeyring) Remove(credentialsName string) error <span class="cov0" title="0">{
        return ck.Keyring.Remove(credentialsName)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package vault

import (
        "context"
        "encoding/json"
        "fmt"
        "reflect"

        "github.com/aws/aws-sdk-go-v2/aws"
        ststypes "github.com/aws/aws-sdk-go-v2/service/sts/types"
)

var credentialProcessRequiredFields = []string{"AccessKeyId", "Expiration", "SecretAccessKey", "SessionToken"}

// CredentialProcessProvider implements interface aws.CredentialsProvider to retrieve credentials from an external executable
// as described in https://docs.aws.amazon.com/cli/latest/topic/config-vars.html#sourcing-credentials-from-external-processes
type CredentialProcessProvider struct {
        CredentialProcess string
}

func (p *CredentialProcessProvider) validateJSONCredential(cred *ststypes.Credentials) error <span class="cov4" title="2">{
        var missing []string

        h := reflect.ValueOf(cred).Elem()
        for _, requiredField := range credentialProcessRequiredFields </span><span class="cov10" title="8">{
                if h.FieldByName(requiredField).IsNil() </span><span class="cov7" title="4">{
                        missing = append(missing, requiredField)
                }</span>
        }

        <span class="cov4" title="2">if len(missing) &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("JSON credential from command %q missing the following fields: %v", p.CredentialProcess, missing)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Retrieve obtains a new set of temporary credentials using an external process, required to satisfy interface aws.CredentialsProvider
func (p *CredentialProcessProvider) Retrieve(ctx context.Context) (aws.Credentials, error) <span class="cov0" title="0">{
        return p.retrieveWith(ctx, executeProcess)
}</span>

func (p *CredentialProcessProvider) retrieveWith(ctx context.Context, fn func(string) (string, error)) (aws.Credentials, error) <span class="cov7" title="4">{
        creds, err := p.callCredentialProcessWith(ctx, fn)
        if err != nil </span><span class="cov5" title="3">{
                return aws.Credentials{}, err
        }</span>

        <span class="cov1" title="1">return aws.Credentials{
                AccessKeyID:     aws.ToString(creds.AccessKeyId),
                SecretAccessKey: aws.ToString(creds.SecretAccessKey),
                SessionToken:    aws.ToString(creds.SessionToken),
                CanExpire:       true,
                Expires:         aws.ToTime(creds.Expiration),
        }, nil</span>
}

func (p *CredentialProcessProvider) RetrieveStsCredentials(ctx context.Context) (*ststypes.Credentials, error) <span class="cov0" title="0">{
        return p.callCredentialProcessWith(ctx, executeProcess)
}</span>

func (p *CredentialProcessProvider) callCredentialProcessWith(_ context.Context, fn func(string) (string, error)) (*ststypes.Credentials, error) <span class="cov7" title="4">{
        // Exec CredentialProcess to retrieve AWS creds in JSON format as described in
        // https://docs.aws.amazon.com/cli/latest/topic/config-vars.html#sourcing-credentials-from-external-processes
        output, err := fn(p.CredentialProcess)

        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Unmarshal the JSON into a ststypes.Credentials object
        <span class="cov5" title="3">var value ststypes.Credentials
        if err := json.Unmarshal([]byte(output), &amp;value); err != nil </span><span class="cov1" title="1">{
                return &amp;ststypes.Credentials{}, fmt.Errorf("invalid JSON format from command %q: %v", p.CredentialProcess, err)
        }</span>

        // Validate that all required fields were present in JSON before returning
        <span class="cov4" title="2">return &amp;value, p.validateJSONCredential(&amp;value)</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package vault

import (
        "fmt"
        "os"
        "os/exec"
        "runtime"
)

func executeProcess(process string) (string, error) <span class="cov0" title="0">{
        var cmdArgs []string
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                cmdArgs = []string{"cmd.exe", "/C", process}
        }</span> else<span class="cov0" title="0"> {
                cmdArgs = []string{"/bin/sh", "-c", process}
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(cmdArgs[0], cmdArgs[1:]...)
        cmd.Env = os.Environ()
        cmd.Stdin = os.Stdin
        cmd.Stderr = os.Stderr

        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("running command %q: %v", process, err)
        }</span>
        <span class="cov0" title="0">return string(output), nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package vault

import (
        "context"
        "log"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sts"
)

const allowAllIAMPolicy = `{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Action":"*","Resource":"*"}]}`

// FederationTokenProvider retrieves temporary credentials from STS using GetFederationToken
type FederationTokenProvider struct {
        StsClient *sts.Client
        Name      string
        Duration  time.Duration
}

func (f *FederationTokenProvider) name() string <span class="cov0" title="0">{
        // truncate the username if it's longer than 32 characters or else GetFederationToken will fail. see: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetFederationToken.html
        if len(f.Name) &gt; 32 </span><span class="cov0" title="0">{
                return f.Name[0:32]
        }</span>
        <span class="cov0" title="0">return f.Name</span>
}

// Retrieve generates a new set of temporary credentials using STS GetFederationToken
func (f *FederationTokenProvider) Retrieve(ctx context.Context) (creds aws.Credentials, err error) <span class="cov0" title="0">{
        resp, err := f.StsClient.GetFederationToken(ctx, &amp;sts.GetFederationTokenInput{
                Name:            aws.String(f.name()),
                DurationSeconds: aws.Int32(int32(f.Duration.Seconds())),
                Policy:          aws.String(allowAllIAMPolicy),
        })
        if err != nil </span><span class="cov0" title="0">{
                return creds, err
        }</span>

        <span class="cov0" title="0">log.Printf("Generated credentials %s using GetFederationToken, expires in %s", FormatKeyForDisplay(*resp.Credentials.AccessKeyId), time.Until(*resp.Credentials.Expiration).String())

        return aws.Credentials{
                AccessKeyID:     aws.ToString(resp.Credentials.AccessKeyId),
                SecretAccessKey: aws.ToString(resp.Credentials.SecretAccessKey),
                SessionToken:    aws.ToString(resp.Credentials.SessionToken),
                CanExpire:       true,
                Expires:         aws.ToTime(resp.Credentials.Expiration),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package vault

import (
        "context"
        "fmt"
        "regexp"
        "strings"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/iam"
)

var getUserErrorRegexp = regexp.MustCompile(`^AccessDenied: User: arn:aws:iam::(\d+):user/(.+) is not`)

// GetUsernameFromSession returns the IAM username (or root) associated with the current aws session
func GetUsernameFromSession(ctx context.Context, cfg aws.Config) (string, error) <span class="cov0" title="0">{
        iamClient := iam.NewFromConfig(cfg)
        resp, err := iamClient.GetUser(ctx, &amp;iam.GetUserInput{})
        if err != nil </span><span class="cov0" title="0">{
                // Even if GetUser fails, the current user is included in the error. This happens when you have o IAM permissions
                // on the master credentials, but have permission to use assumeRole later
                matches := getUserErrorRegexp.FindStringSubmatch(err.Error())
                if len(matches) &gt; 0 </span><span class="cov0" title="0">{
                        pathParts := strings.Split(matches[2], "/")
                        return pathParts[len(pathParts)-1], nil
                }</span>

                <span class="cov0" title="0">return "", err</span>
        }

        <span class="cov0" title="0">if resp.User.UserName != nil </span><span class="cov0" title="0">{
                return *resp.User.UserName, nil
        }</span>

        <span class="cov0" title="0">if resp.User.Arn != nil </span><span class="cov0" title="0">{
                arnParts := strings.Split(*resp.User.Arn, ":")
                return arnParts[len(arnParts)-1], nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("Couldn't determine current username")</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package vault

import (
        "context"
        "log"

        "github.com/aws/aws-sdk-go-v2/aws"
)

// KeyringProvider stores and retrieves master credentials
type KeyringProvider struct {
        Keyring         *CredentialKeyring
        CredentialsName string
}

func (p *KeyringProvider) Retrieve(_ context.Context) (aws.Credentials, error) <span class="cov0" title="0">{
        log.Printf("Looking up keyring for '%s'", p.CredentialsName)
        return p.Keyring.Get(p.CredentialsName)
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package vault

import (
        "errors"
        "log"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/byteness/aws-vault/v7/prompt"
)

// Mfa contains options for an MFA device
type Mfa struct {
        MfaSerial     string
        mfaPromptFunc prompt.Func
}

// GetMfaToken returns the MFA token
func (m Mfa) GetMfaToken() (*string, error) <span class="cov0" title="0">{
        if m.mfaPromptFunc != nil </span><span class="cov0" title="0">{
                token, err := m.mfaPromptFunc(m.MfaSerial)
                return aws.String(token), err
        }</span>

        <span class="cov0" title="0">return nil, errors.New("No prompt found")</span>
}

func NewMfa(config *ProfileConfig) Mfa <span class="cov0" title="0">{
        m := Mfa{
                MfaSerial: config.MfaSerial,
        }
        if config.MfaToken != "" </span><span class="cov0" title="0">{
                m.mfaPromptFunc = func(_ string) (string, error) </span><span class="cov0" title="0">{ return config.MfaToken, nil }</span>
        } else<span class="cov0" title="0"> if config.MfaProcess != "" </span><span class="cov0" title="0">{
                m.mfaPromptFunc = func(_ string) (string, error) </span><span class="cov0" title="0">{
                        log.Println("Executing mfa_process")
                        return ProcessMfaProvider(config.MfaProcess)
                }</span>
        } else<span class="cov0" title="0"> {
                m.mfaPromptFunc = prompt.Method(config.MfaPromptMethod)
        }</span>

        <span class="cov0" title="0">return m</span>
}

func ProcessMfaProvider(processCmd string) (string, error) <span class="cov0" title="0">{
        return executeMFACommand(processCmd)
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">//go:build linux || darwin || freebsd || openbsd
// +build linux darwin freebsd openbsd

package vault

import (
        "fmt"
        "os"
        "os/exec"
        "strings"
)

func executeMFACommand(processCmd string) (string, error) <span class="cov0" title="0">{
        cmd := exec.Command("/bin/sh", "-c", processCmd)
        cmd.Stderr = os.Stderr

        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("process provider: %w", err)
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(out)), nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package vault

import (
        "encoding/json"
        "fmt"
        "log"
        "strings"
        "time"

        "github.com/byteness/keyring"
        "github.com/aws/aws-sdk-go-v2/service/ssooidc"
)

type OIDCTokenKeyring struct {
        Keyring keyring.Keyring
}

type OIDCTokenData struct {
        Token      ssooidc.CreateTokenOutput
        Expiration time.Time
}

const oidcTokenKeyPrefix = "oidc:"

func (o *OIDCTokenKeyring) fmtKey(startURL string) string <span class="cov0" title="0">{
        return oidcTokenKeyPrefix + startURL
}</span>

func IsOIDCTokenKey(k string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(k, oidcTokenKeyPrefix)
}</span>

func (o OIDCTokenKeyring) Has(startURL string) (bool, error) <span class="cov0" title="0">{
        kk, err := o.Keyring.Keys()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">for _, k := range kk </span><span class="cov0" title="0">{
                if startURL == k </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

func (o OIDCTokenKeyring) Get(startURL string) (*ssooidc.CreateTokenOutput, error) <span class="cov0" title="0">{
        item, err := o.Keyring.Get(o.fmtKey(startURL))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">val := OIDCTokenData{}

        if err = json.Unmarshal(item.Data, &amp;val); err != nil </span><span class="cov0" title="0">{
                log.Printf("Invalid data in keyring: %s", err.Error())
                return nil, keyring.ErrKeyNotFound
        }</span>
        <span class="cov0" title="0">if time.Now().After(val.Expiration) </span><span class="cov0" title="0">{
                log.Printf("OIDC token for '%s' expired, removing", startURL)
                _ = o.Remove(startURL)
                return nil, keyring.ErrKeyNotFound
        }</span>

        <span class="cov0" title="0">secondsLeft := time.Until(val.Expiration) / time.Second

        val.Token.ExpiresIn = int32(secondsLeft)

        return &amp;val.Token, err</span>
}

func (o OIDCTokenKeyring) Set(startURL string, token *ssooidc.CreateTokenOutput) error <span class="cov0" title="0">{
        val := OIDCTokenData{
                Token:      *token,
                Expiration: time.Now().Add(time.Duration(token.ExpiresIn) * time.Second),
        }

        valJSON, err := json.Marshal(val)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return o.Keyring.Set(keyring.Item{
                Key:         o.fmtKey(startURL),
                Data:        valJSON,
                Label:       fmt.Sprintf("aws-vault oidc token for %s (expires %s)", startURL, val.Expiration.Format(time.RFC3339)),
                Description: "aws-vault oidc token",
        })</span>
}

func (o OIDCTokenKeyring) Remove(startURL string) error <span class="cov0" title="0">{
        return o.Keyring.Remove(o.fmtKey(startURL))
}</span>

func (o *OIDCTokenKeyring) RemoveAll() (n int, err error) <span class="cov0" title="0">{
        allKeys, err := o.Keys()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">for _, key := range allKeys </span><span class="cov0" title="0">{
                if err = o.Remove(key); err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
                <span class="cov0" title="0">n++</span>
        }
        <span class="cov0" title="0">return n, nil</span>
}

func (o *OIDCTokenKeyring) Keys() (kk []string, err error) <span class="cov0" title="0">{
        allKeys, err := o.Keyring.Keys()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, k := range allKeys </span><span class="cov0" title="0">{
                if IsOIDCTokenKey(k) </span><span class="cov0" title="0">{
                        kk = append(kk, strings.TrimPrefix(k, oidcTokenKeyPrefix))
                }</span>
        }

        <span class="cov0" title="0">return kk, nil</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package vault

import (
        "encoding/base64"
        "encoding/json"
        "fmt"
        "log"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/byteness/keyring"
        ststypes "github.com/aws/aws-sdk-go-v2/service/sts/types"
)

var sessionKeyPattern = regexp.MustCompile(`^(?P&lt;type&gt;[^,]+),(?P&lt;profile&gt;[^,]+),(?P&lt;mfaSerial&gt;[^,]*),(?P&lt;expiration&gt;[0-9]{1,})$`)

var oldSessionKeyPatterns = []*regexp.Regexp{
        regexp.MustCompile(`^session,(?P&lt;profile&gt;[^,]+),(?P&lt;mfaSerial&gt;[^,]*),(?P&lt;expiration&gt;[0-9]{2,})$`),
        regexp.MustCompile(`^session:(?P&lt;profile&gt;[^ ]+):(?P&lt;mfaSerial&gt;[^ ]*):(?P&lt;expiration&gt;[^:]+)$`),
        regexp.MustCompile(`^(.+?) session \((\d+)\)$`),
}
var base64URLEncodingNoPadding = base64.URLEncoding.WithPadding(base64.NoPadding)

func IsOldSessionKey(s string) bool <span class="cov5" title="3">{
        for _, pattern := range oldSessionKeyPatterns </span><span class="cov10" title="9">{
                if pattern.MatchString(s) </span><span class="cov3" title="2">{
                        return true
                }</span>
        }
        <span class="cov1" title="1">return false</span>
}

func IsCurrentSessionKey(s string) bool <span class="cov7" title="5">{
        _, err := NewSessionKeyFromString(s)
        return err == nil
}</span>

func IsSessionKey(s string) bool <span class="cov7" title="5">{
        return IsCurrentSessionKey(s) || IsOldSessionKey(s)
}</span>

type SessionMetadata struct {
        Type        string
        ProfileName string
        MfaSerial   string
        Expiration  time.Time
}

func (k *SessionMetadata) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "%s,%s,%s,%d",
                k.Type,
                base64URLEncodingNoPadding.EncodeToString([]byte(k.ProfileName)),
                base64URLEncodingNoPadding.EncodeToString([]byte(k.MfaSerial)),
                k.Expiration.Unix(),
        )
}</span>

func (k *SessionMetadata) StringForMatching() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "%s,%s,%s,",
                k.Type,
                base64URLEncodingNoPadding.EncodeToString([]byte(k.ProfileName)),
                base64URLEncodingNoPadding.EncodeToString([]byte(k.MfaSerial)),
        )
}</span>

func NewSessionKeyFromString(s string) (SessionMetadata, error) <span class="cov7" title="5">{
        matches := sessionKeyPattern.FindStringSubmatch(s)
        if len(matches) == 0 </span><span class="cov5" title="3">{
                return SessionMetadata{}, fmt.Errorf("failed to parse session name: %s", s)
        }</span>

        <span class="cov3" title="2">profileName, err := base64URLEncodingNoPadding.DecodeString(matches[2])
        if err != nil </span><span class="cov0" title="0">{
                return SessionMetadata{}, err
        }</span>
        <span class="cov3" title="2">mfaSerial, err := base64URLEncodingNoPadding.DecodeString(matches[3])
        if err != nil </span><span class="cov0" title="0">{
                return SessionMetadata{}, err
        }</span>
        <span class="cov3" title="2">expiryUnixtime, err := strconv.Atoi(matches[4])
        if err != nil </span><span class="cov0" title="0">{
                return SessionMetadata{}, err
        }</span>

        <span class="cov3" title="2">return SessionMetadata{
                Type:        matches[1],
                ProfileName: string(profileName),
                MfaSerial:   string(mfaSerial),
                Expiration:  time.Unix(int64(expiryUnixtime), 0),
        }, nil</span>
}

type SessionKeyring struct {
        Keyring keyring.Keyring
}

var ErrNotFound = keyring.ErrKeyNotFound

func (sk *SessionKeyring) lookupKeyName(key SessionMetadata) (string, error) <span class="cov0" title="0">{
        allKeys, err := sk.Keyring.Keys()
        if err != nil </span><span class="cov0" title="0">{
                return key.String(), err
        }</span>
        <span class="cov0" title="0">for _, keyName := range allKeys </span><span class="cov0" title="0">{
                if strings.HasPrefix(keyName, key.StringForMatching()) </span><span class="cov0" title="0">{
                        return keyName, nil
                }</span>
        }
        <span class="cov0" title="0">return key.String(), ErrNotFound</span>
}

func (sk *SessionKeyring) Has(key SessionMetadata) (bool, error) <span class="cov0" title="0">{
        _, err := sk.lookupKeyName(key)
        if err == ErrNotFound </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        <span class="cov0" title="0">return false, err</span>
}

func (sk *SessionKeyring) Get(key SessionMetadata) (creds *ststypes.Credentials, err error) <span class="cov0" title="0">{
        _, _ = sk.RemoveOldSessions()

        keyName, err := sk.lookupKeyName(key)
        if err != nil &amp;&amp; err != ErrNotFound </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">item, err := sk.Keyring.Get(keyName)
        if err != nil </span><span class="cov0" title="0">{
                return creds, err
        }</span>
        <span class="cov0" title="0">if err = json.Unmarshal(item.Data, &amp;creds); err != nil </span><span class="cov0" title="0">{
                log.Printf("SessionKeyring: Ignoring invalid data: %s", err.Error())
                return creds, ErrNotFound
        }</span>
        <span class="cov0" title="0">return creds, err</span>
}

func (sk *SessionKeyring) Set(key SessionMetadata, creds *ststypes.Credentials) error <span class="cov0" title="0">{
        _, _ = sk.RemoveOldSessions()

        key.Expiration = *creds.Expiration

        valJSON, err := json.Marshal(creds)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">keyName, err := sk.lookupKeyName(key)
        if err != ErrNotFound </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if keyName != key.String() </span><span class="cov0" title="0">{
                        err = sk.Keyring.Remove(keyName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return sk.Keyring.Set(keyring.Item{
                Key:         key.String(),
                Data:        valJSON,
                Label:       fmt.Sprintf("aws-vault session for %s (expires %s)", key.ProfileName, creds.Expiration.Format(time.RFC3339)),
                Description: "aws-vault session",
        })</span>
}

func (sk *SessionKeyring) Remove(key SessionMetadata) error <span class="cov0" title="0">{
        keyName, err := sk.lookupKeyName(key)
        if err != nil &amp;&amp; err != ErrNotFound </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sk.Keyring.Remove(keyName)</span>
}

func (sk *SessionKeyring) RemoveAll() (n int, err error) <span class="cov0" title="0">{
        allKeys, err := sk.Keys()
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">for _, key := range allKeys </span><span class="cov0" title="0">{
                if err = sk.Remove(key); err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
                <span class="cov0" title="0">n++</span>
        }
        <span class="cov0" title="0">return n, nil</span>
}

func (sk *SessionKeyring) Keys() (kk []SessionMetadata, err error) <span class="cov0" title="0">{
        allKeys, err := sk.Keyring.Keys()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, s := range allKeys </span><span class="cov0" title="0">{
                if k, err := NewSessionKeyFromString(s); err == nil </span><span class="cov0" title="0">{
                        kk = append(kk, k)
                }</span>
        }

        <span class="cov0" title="0">return kk, nil</span>
}

func (sk *SessionKeyring) realSessionKey(key SessionMetadata) (m SessionMetadata, err error) <span class="cov0" title="0">{
        keyName, err := sk.lookupKeyName(key)
        if err != nil </span><span class="cov0" title="0">{
                return m, err
        }</span>
        <span class="cov0" title="0">sessKey, err := NewSessionKeyFromString(keyName)
        if err != nil </span><span class="cov0" title="0">{
                return m, err
        }</span>
        <span class="cov0" title="0">return sessKey, nil</span>
}

func (sk *SessionKeyring) GetAllMetadata() (mm []SessionMetadata, err error) <span class="cov0" title="0">{
        allKeys, err := sk.Keys()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, k := range allKeys </span><span class="cov0" title="0">{
                m, err := sk.realSessionKey(k)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("GetAllMetadata: %w", err)
                }</span>

                <span class="cov0" title="0">mm = append(mm, m)</span>
        }

        <span class="cov0" title="0">return mm, nil</span>
}

func (sk *SessionKeyring) RemoveForProfile(profileName string) (n int, err error) <span class="cov0" title="0">{
        sessions, err := sk.GetAllMetadata()
        if err != nil </span><span class="cov0" title="0">{
                return n, err
        }</span>
        <span class="cov0" title="0">for _, s := range sessions </span><span class="cov0" title="0">{
                if s.ProfileName == profileName </span><span class="cov0" title="0">{
                        err = sk.Remove(s)
                        if err != nil </span><span class="cov0" title="0">{
                                return n, err
                        }</span>
                        <span class="cov0" title="0">n++</span>
                }
        }

        <span class="cov0" title="0">return n, nil</span>
}

func (sk *SessionKeyring) RemoveOldSessions() (n int, err error) <span class="cov0" title="0">{
        allKeys, err := sk.Keyring.Keys()
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error while deleting old session: %s", err.Error())
        }</span>

        <span class="cov0" title="0">for _, k := range allKeys </span><span class="cov0" title="0">{
                if IsOldSessionKey(k) </span><span class="cov0" title="0">{
                        err = sk.Keyring.Remove(k)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Error while deleting old session: %s", err.Error())
                                continue</span>
                        }
                        <span class="cov0" title="0">n++</span>
                } else<span class="cov0" title="0"> {
                        stsk, err := NewSessionKeyFromString(k)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if time.Now().After(stsk.Expiration) </span><span class="cov0" title="0">{
                                err = sk.Keyring.Remove(k)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Printf("Error while deleting old session: %s", err.Error())
                                        continue</span>
                                }
                                <span class="cov0" title="0">n++</span>
                        }
                }
        }

        <span class="cov0" title="0">return n, nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package vault

import (
        "context"
        "log"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sts"
        ststypes "github.com/aws/aws-sdk-go-v2/service/sts/types"
)

// SessionTokenProvider retrieves temporary credentials from STS using GetSessionToken
type SessionTokenProvider struct {
        StsClient *sts.Client
        Duration  time.Duration
        Mfa
}

// Retrieve generates a new set of temporary credentials using STS GetSessionToken
func (p *SessionTokenProvider) Retrieve(ctx context.Context) (aws.Credentials, error) <span class="cov0" title="0">{
        creds, err := p.RetrieveStsCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return aws.Credentials{}, err
        }</span>

        <span class="cov0" title="0">return aws.Credentials{
                AccessKeyID:     aws.ToString(creds.AccessKeyId),
                SecretAccessKey: aws.ToString(creds.SecretAccessKey),
                SessionToken:    aws.ToString(creds.SessionToken),
                CanExpire:       true,
                Expires:         aws.ToTime(creds.Expiration),
        }, nil</span>
}

// GetSessionToken generates a new set of temporary credentials using STS GetSessionToken
func (p *SessionTokenProvider) RetrieveStsCredentials(ctx context.Context) (*ststypes.Credentials, error) <span class="cov0" title="0">{
        var err error

        input := &amp;sts.GetSessionTokenInput{
                DurationSeconds: aws.Int32(int32(p.Duration.Seconds())),
        }

        if p.MfaSerial != "" </span><span class="cov0" title="0">{
                input.SerialNumber = aws.String(p.MfaSerial)
                input.TokenCode, err = p.GetMfaToken()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">resp, err := p.StsClient.GetSessionToken(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Printf("Generated credentials %s using GetSessionToken, expires in %s", FormatKeyForDisplay(*resp.Credentials.AccessKeyId), time.Until(*resp.Credentials.Expiration).String())

        return resp.Credentials, nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package vault

import (
        "context"
        "errors"
        "fmt"
        "log"
        "net/http"
        "os"
        "time"

        "github.com/byteness/keyring"
        "github.com/aws/aws-sdk-go-v2/aws"
        awshttp "github.com/aws/aws-sdk-go-v2/aws/transport/http"
        "github.com/aws/aws-sdk-go-v2/service/sso"
        ssotypes "github.com/aws/aws-sdk-go-v2/service/sso/types"
        "github.com/aws/aws-sdk-go-v2/service/ssooidc"
        ssooidctypes "github.com/aws/aws-sdk-go-v2/service/ssooidc/types"
        ststypes "github.com/aws/aws-sdk-go-v2/service/sts/types"
        "github.com/skratchdot/open-golang/open"
)

type OIDCTokenCacher interface {
        Get(string) (*ssooidc.CreateTokenOutput, error)
        Set(string, *ssooidc.CreateTokenOutput) error
        Remove(string) error
}

// SSORoleCredentialsProvider creates temporary credentials for an SSO Role.
type SSORoleCredentialsProvider struct {
        OIDCClient     *ssooidc.Client
        OIDCTokenCache OIDCTokenCacher
        StartURL       string
        SSOClient      *sso.Client
        AccountID      string
        RoleName       string
        UseStdout      bool
}

func millisecondsTimeValue(v int64) time.Time <span class="cov0" title="0">{
        return time.Unix(0, v*int64(time.Millisecond))
}</span>

// Retrieve generates a new set of temporary credentials using SSO GetRoleCredentials.
func (p *SSORoleCredentialsProvider) Retrieve(ctx context.Context) (aws.Credentials, error) <span class="cov0" title="0">{
        creds, err := p.getRoleCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return aws.Credentials{}, err
        }</span>

        <span class="cov0" title="0">return aws.Credentials{
                AccessKeyID:     aws.ToString(creds.AccessKeyId),
                SecretAccessKey: aws.ToString(creds.SecretAccessKey),
                SessionToken:    aws.ToString(creds.SessionToken),
                CanExpire:       true,
                Expires:         millisecondsTimeValue(creds.Expiration),
        }, nil</span>
}

func (p *SSORoleCredentialsProvider) getRoleCredentials(ctx context.Context) (*ssotypes.RoleCredentials, error) <span class="cov0" title="0">{
        token, cached, err := p.getOIDCToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := p.SSOClient.GetRoleCredentials(ctx, &amp;sso.GetRoleCredentialsInput{
                AccessToken: token.AccessToken,
                AccountId:   aws.String(p.AccountID),
                RoleName:    aws.String(p.RoleName),
        })
        if err != nil </span><span class="cov0" title="0">{
                if cached &amp;&amp; p.OIDCTokenCache != nil </span><span class="cov0" title="0">{
                        var rspError *awshttp.ResponseError
                        if !errors.As(err, &amp;rspError) </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // If the error is a 401, remove the cached oidc token and try
                        // again. This is a recursive call but it should only happen once
                        // due to the cache being cleared before retrying.
                        <span class="cov0" title="0">if rspError.HTTPStatusCode() == http.StatusUnauthorized </span><span class="cov0" title="0">{
                                err = p.OIDCTokenCache.Remove(p.StartURL)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">return p.getRoleCredentials(ctx)</span>
                        }
                }
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">log.Printf("Got credentials %s for SSO role %s (account: %s), expires in %s", FormatKeyForDisplay(*resp.RoleCredentials.AccessKeyId), p.RoleName, p.AccountID, time.Until(millisecondsTimeValue(resp.RoleCredentials.Expiration)).String())

        return resp.RoleCredentials, nil</span>
}

func (p *SSORoleCredentialsProvider) RetrieveStsCredentials(ctx context.Context) (*ststypes.Credentials, error) <span class="cov0" title="0">{
        return p.getRoleCredentialsAsStsCredemtials(ctx)
}</span>

// getRoleCredentialsAsStsCredemtials returns getRoleCredentials as sts.Credentials because sessions.Store expects it
func (p *SSORoleCredentialsProvider) getRoleCredentialsAsStsCredemtials(ctx context.Context) (*ststypes.Credentials, error) <span class="cov0" title="0">{
        creds, err := p.getRoleCredentials(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ststypes.Credentials{
                AccessKeyId:     creds.AccessKeyId,
                SecretAccessKey: creds.SecretAccessKey,
                SessionToken:    creds.SessionToken,
                Expiration:      aws.Time(millisecondsTimeValue(creds.Expiration)),
        }, nil</span>
}

func (p *SSORoleCredentialsProvider) getOIDCToken(ctx context.Context) (token *ssooidc.CreateTokenOutput, cached bool, err error) <span class="cov0" title="0">{
        if p.OIDCTokenCache != nil </span><span class="cov0" title="0">{
                token, err = p.OIDCTokenCache.Get(p.StartURL)
                if err != nil &amp;&amp; err != keyring.ErrKeyNotFound </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span>
                <span class="cov0" title="0">if token != nil </span><span class="cov0" title="0">{
                        return token, true, nil
                }</span>
        }
        <span class="cov0" title="0">token, err = p.newOIDCToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">if p.OIDCTokenCache != nil </span><span class="cov0" title="0">{
                err = p.OIDCTokenCache.Set(p.StartURL, token)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span>
        }
        <span class="cov0" title="0">return token, false, err</span>
}

func (p *SSORoleCredentialsProvider) newOIDCToken(ctx context.Context) (*ssooidc.CreateTokenOutput, error) <span class="cov0" title="0">{
        clientCreds, err := p.OIDCClient.RegisterClient(ctx, &amp;ssooidc.RegisterClientInput{
                ClientName: aws.String("aws-vault"),
                ClientType: aws.String("public"),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Printf("Created new OIDC client (expires at: %s)", time.Unix(clientCreds.ClientSecretExpiresAt, 0))

        deviceCreds, err := p.OIDCClient.StartDeviceAuthorization(ctx, &amp;ssooidc.StartDeviceAuthorizationInput{
                ClientId:     clientCreds.ClientId,
                ClientSecret: clientCreds.ClientSecret,
                StartUrl:     aws.String(p.StartURL),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">log.Printf("Created OIDC device code for %s (expires in: %ds)", p.StartURL, deviceCreds.ExpiresIn)

        if p.UseStdout </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Open the SSO authorization page in a browser (use Ctrl-C to abort)\n%s\n", aws.ToString(deviceCreds.VerificationUriComplete))
        }</span> else<span class="cov0" title="0"> {
                log.Println("Opening SSO authorization page in browser")
                fmt.Fprintf(os.Stderr, "Opening the SSO authorization page in your default browser (use Ctrl-C to abort)\n%s\n", aws.ToString(deviceCreds.VerificationUriComplete))
                if err := open.Run(aws.ToString(deviceCreds.VerificationUriComplete)); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to open browser: %s", err)
                }</span>
        }

        // These are the default values defined in the following RFC:
        // https://tools.ietf.org/html/draft-ietf-oauth-device-flow-15#section-3.5
        <span class="cov0" title="0">var slowDownDelay = 5 * time.Second
        var retryInterval = 5 * time.Second

        if i := deviceCreds.Interval; i &gt; 0 </span><span class="cov0" title="0">{
                retryInterval = time.Duration(i) * time.Second
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                t, err := p.OIDCClient.CreateToken(ctx, &amp;ssooidc.CreateTokenInput{
                        ClientId:     clientCreds.ClientId,
                        ClientSecret: clientCreds.ClientSecret,
                        DeviceCode:   deviceCreds.DeviceCode,
                        GrantType:    aws.String("urn:ietf:params:oauth:grant-type:device_code"),
                })
                if err != nil </span><span class="cov0" title="0">{
                        var sde *ssooidctypes.SlowDownException
                        if errors.As(err, &amp;sde) </span><span class="cov0" title="0">{
                                retryInterval += slowDownDelay
                        }</span>

                        <span class="cov0" title="0">var ape *ssooidctypes.AuthorizationPendingException
                        if errors.As(err, &amp;ape) </span><span class="cov0" title="0">{
                                time.Sleep(retryInterval)
                                continue</span>
                        }

                        <span class="cov0" title="0">return nil, err</span>
                }

                <span class="cov0" title="0">log.Printf("Created new OIDC access token for %s (expires in: %ds)", p.StartURL, t.ExpiresIn)
                return t, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package vault

import (
        "log"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sts"
)

// getEndpointResolver resolves endpoints in accordance with
// https://docs.aws.amazon.com/credref/latest/refdocs/setting-global-sts_regional_endpoints.html
func getSTSEndpointResolver(stsRegionalEndpoints, endpointURL string) aws.EndpointResolverWithOptionsFunc <span class="cov10" title="2">{
        return func(service, region string, options ...interface{}) (aws.Endpoint, error) </span><span class="cov0" title="0">{
                if endpointURL != "" </span><span class="cov0" title="0">{
                        log.Println("Using custom STS endpoint " + endpointURL)

                        return aws.Endpoint{
                                URL:           endpointURL,
                                SigningRegion: region,
                        }, nil
                }</span>

                <span class="cov0" title="0">if stsRegionalEndpoints == "legacy" &amp;&amp; service == sts.ServiceID </span><span class="cov0" title="0">{
                        if region == "ap-northeast-1" ||
                                region == "ap-south-1" ||
                                region == "ap-southeast-1" ||
                                region == "ap-southeast-2" ||
                                region == "aws-global" ||
                                region == "ca-central-1" ||
                                region == "eu-central-1" ||
                                region == "eu-north-1" ||
                                region == "eu-west-1" ||
                                region == "eu-west-2" ||
                                region == "eu-west-3" ||
                                region == "sa-east-1" ||
                                region == "us-east-1" ||
                                region == "us-east-2" ||
                                region == "us-west-1" ||
                                region == "us-west-2" </span><span class="cov0" title="0">{
                                log.Println("Using legacy STS endpoint sts.amazonaws.com")

                                return aws.Endpoint{
                                        URL:           "https://sts.amazonaws.com",
                                        SigningRegion: region,
                                }, nil
                        }</span>
                }

                <span class="cov0" title="0">return aws.Endpoint{}, &amp;aws.EndpointNotFoundError{}</span>
        }
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package vault

import (
        "context"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/sso"
        "github.com/aws/aws-sdk-go-v2/service/ssooidc"
        "github.com/aws/aws-sdk-go-v2/service/sts"
        "github.com/byteness/keyring"
)

var defaultExpirationWindow = 5 * time.Minute

func init() <span class="cov1" title="1">{
        if d, err := time.ParseDuration(os.Getenv("AWS_MIN_TTL")); err == nil </span><span class="cov0" title="0">{
                defaultExpirationWindow = d
        }</span>
}

func NewAwsConfig(region, stsRegionalEndpoints, endpointURL string) aws.Config <span class="cov5" title="2">{
        return aws.Config{
                Region:                      region,
                EndpointResolverWithOptions: getSTSEndpointResolver(stsRegionalEndpoints, endpointURL),
        }
}</span>

func NewAwsConfigWithCredsProvider(credsProvider aws.CredentialsProvider, region, stsRegionalEndpoints, endpointURL string) aws.Config <span class="cov0" title="0">{
        return aws.Config{
                Region:                      region,
                Credentials:                 credsProvider,
                EndpointResolverWithOptions: getSTSEndpointResolver(stsRegionalEndpoints, endpointURL),
        }
}</span>

func FormatKeyForDisplay(k string) string <span class="cov0" title="0">{
        return fmt.Sprintf("****************%s", k[len(k)-4:])
}</span>

func isMasterCredentialsProvider(credsProvider aws.CredentialsProvider) bool <span class="cov0" title="0">{
        _, ok := credsProvider.(*KeyringProvider)
        return ok
}</span>

// NewMasterCredentialsProvider creates a provider for the master credentials
func NewMasterCredentialsProvider(k *CredentialKeyring, credentialsName string) *KeyringProvider <span class="cov0" title="0">{
        return &amp;KeyringProvider{k, credentialsName}
}</span>

func NewSessionTokenProvider(credsProvider aws.CredentialsProvider, k keyring.Keyring, config *ProfileConfig, useSessionCache bool) (aws.CredentialsProvider, error) <span class="cov0" title="0">{
        cfg := NewAwsConfigWithCredsProvider(credsProvider, config.Region, config.STSRegionalEndpoints, config.EndpointURL)

        sessionTokenProvider := &amp;SessionTokenProvider{
                StsClient: sts.NewFromConfig(cfg),
                Duration:  config.GetSessionTokenDuration(),
                Mfa:       NewMfa(config),
        }

        if useSessionCache </span><span class="cov0" title="0">{
                return &amp;CachedSessionProvider{
                        SessionKey: SessionMetadata{
                                Type:        "sts.GetSessionToken",
                                ProfileName: config.ProfileName,
                                MfaSerial:   config.MfaSerial,
                        },
                        Keyring:         &amp;SessionKeyring{Keyring: k},
                        ExpiryWindow:    defaultExpirationWindow,
                        SessionProvider: sessionTokenProvider,
                }, nil
        }</span>

        <span class="cov0" title="0">return sessionTokenProvider, nil</span>
}

// NewAssumeRoleProvider returns a provider that generates credentials using AssumeRole
func NewAssumeRoleProvider(credsProvider aws.CredentialsProvider, k keyring.Keyring, config *ProfileConfig, useSessionCache bool) (aws.CredentialsProvider, error) <span class="cov0" title="0">{
        cfg := NewAwsConfigWithCredsProvider(credsProvider, config.Region, config.STSRegionalEndpoints, config.EndpointURL)

        p := &amp;AssumeRoleProvider{
                StsClient:         sts.NewFromConfig(cfg),
                RoleARN:           config.RoleARN,
                RoleSessionName:   config.RoleSessionName,
                ExternalID:        config.ExternalID,
                Duration:          config.AssumeRoleDuration,
                Tags:              config.SessionTags,
                TransitiveTagKeys: config.TransitiveSessionTags,
                SourceIdentity:    config.SourceIdentity,
                Mfa:               NewMfa(config),
        }

        if useSessionCache &amp;&amp; config.MfaSerial != "" </span><span class="cov0" title="0">{
                return &amp;CachedSessionProvider{
                        SessionKey: SessionMetadata{
                                Type:        "sts.AssumeRole",
                                ProfileName: config.ProfileName,
                                MfaSerial:   config.MfaSerial,
                        },
                        Keyring:         &amp;SessionKeyring{Keyring: k},
                        ExpiryWindow:    defaultExpirationWindow,
                        SessionProvider: p,
                }, nil
        }</span>

        <span class="cov0" title="0">return p, nil</span>
}

// NewAssumeRoleWithWebIdentityProvider returns a provider that generates
// credentials using AssumeRoleWithWebIdentity
func NewAssumeRoleWithWebIdentityProvider(k keyring.Keyring, config *ProfileConfig, useSessionCache bool) (aws.CredentialsProvider, error) <span class="cov1" title="1">{
        cfg := NewAwsConfig(config.Region, config.STSRegionalEndpoints, config.EndpointURL)

        p := &amp;AssumeRoleWithWebIdentityProvider{
                StsClient:               sts.NewFromConfig(cfg),
                RoleARN:                 config.RoleARN,
                RoleSessionName:         config.RoleSessionName,
                WebIdentityTokenFile:    config.WebIdentityTokenFile,
                WebIdentityTokenProcess: config.WebIdentityTokenProcess,
                Duration:                config.AssumeRoleDuration,
        }

        if useSessionCache </span><span class="cov0" title="0">{
                return &amp;CachedSessionProvider{
                        SessionKey: SessionMetadata{
                                Type:        "sts.AssumeRoleWithWebIdentity",
                                ProfileName: config.ProfileName,
                        },
                        Keyring:         &amp;SessionKeyring{Keyring: k},
                        ExpiryWindow:    defaultExpirationWindow,
                        SessionProvider: p,
                }, nil
        }</span>

        <span class="cov1" title="1">return p, nil</span>
}

// NewSSORoleCredentialsProvider creates a provider for SSO credentials
func NewSSORoleCredentialsProvider(k keyring.Keyring, config *ProfileConfig, useSessionCache bool) (aws.CredentialsProvider, error) <span class="cov1" title="1">{
        cfg := NewAwsConfig(config.SSORegion, config.STSRegionalEndpoints, config.EndpointURL)

        ssoRoleCredentialsProvider := &amp;SSORoleCredentialsProvider{
                OIDCClient: ssooidc.NewFromConfig(cfg),
                StartURL:   config.SSOStartURL,
                SSOClient:  sso.NewFromConfig(cfg),
                AccountID:  config.SSOAccountID,
                RoleName:   config.SSORoleName,
                UseStdout:  config.SSOUseStdout,
        }

        if useSessionCache </span><span class="cov0" title="0">{
                ssoRoleCredentialsProvider.OIDCTokenCache = OIDCTokenKeyring{Keyring: k}
                return &amp;CachedSessionProvider{
                        SessionKey: SessionMetadata{
                                Type:        "sso.GetRoleCredentials",
                                ProfileName: config.ProfileName,
                                MfaSerial:   config.SSOStartURL,
                        },
                        Keyring:         &amp;SessionKeyring{Keyring: k},
                        ExpiryWindow:    defaultExpirationWindow,
                        SessionProvider: ssoRoleCredentialsProvider,
                }, nil
        }</span>

        <span class="cov1" title="1">return ssoRoleCredentialsProvider, nil</span>
}

// NewCredentialProcessProvider creates a provider to retrieve credentials from an external
// executable as described in https://docs.aws.amazon.com/cli/latest/topic/config-vars.html#sourcing-credentials-from-external-processes
func NewCredentialProcessProvider(k keyring.Keyring, config *ProfileConfig, useSessionCache bool) (aws.CredentialsProvider, error) <span class="cov1" title="1">{
        credentialProcessProvider := &amp;CredentialProcessProvider{
                CredentialProcess: config.CredentialProcess,
        }

        if useSessionCache </span><span class="cov0" title="0">{
                return &amp;CachedSessionProvider{
                        SessionKey: SessionMetadata{
                                Type:        "credential_process",
                                ProfileName: config.ProfileName,
                        },
                        Keyring:         &amp;SessionKeyring{Keyring: k},
                        ExpiryWindow:    defaultExpirationWindow,
                        SessionProvider: credentialProcessProvider,
                }, nil
        }</span>

        <span class="cov1" title="1">return credentialProcessProvider, nil</span>
}

func NewFederationTokenProvider(ctx context.Context, credsProvider aws.CredentialsProvider, config *ProfileConfig) (*FederationTokenProvider, error) <span class="cov0" title="0">{
        cfg := NewAwsConfigWithCredsProvider(credsProvider, config.Region, config.STSRegionalEndpoints, config.EndpointURL)

        name, err := GetUsernameFromSession(ctx, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Printf("Using GetFederationToken for credentials")
        return &amp;FederationTokenProvider{
                StsClient: sts.NewFromConfig(cfg),
                Name:      name,
                Duration:  config.GetFederationTokenDuration,
        }, nil</span>
}

func FindMasterCredentialsNameFor(profileName string, keyring *CredentialKeyring, config *ProfileConfig) (string, error) <span class="cov0" title="0">{
        hasMasterCreds, err := keyring.Has(profileName)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if hasMasterCreds </span><span class="cov0" title="0">{
                return profileName, nil
        }</span>

        <span class="cov0" title="0">if profileName == config.SourceProfileName </span><span class="cov0" title="0">{
                return "", fmt.Errorf("No master credentials found")
        }</span>

        <span class="cov0" title="0">return FindMasterCredentialsNameFor(config.SourceProfileName, keyring, config)</span>
}

type TempCredentialsCreator struct {
        Keyring *CredentialKeyring
        // DisableSessions will disable the use of GetSessionToken
        DisableSessions bool
        // DisableCache will disable the use of the session cache
        DisableCache bool
        // DisableSessionsForProfile is a profile for which sessions should not be used
        DisableSessionsForProfile string

        chainedMfa string
}

func (t *TempCredentialsCreator) getSourceCreds(config *ProfileConfig, hasStoredCredentials bool) (sourcecredsProvider aws.CredentialsProvider, err error) <span class="cov1" title="1">{
        if hasStoredCredentials </span><span class="cov0" title="0">{
                log.Printf("profile %s: using stored credentials", config.ProfileName)
                return NewMasterCredentialsProvider(t.Keyring, config.ProfileName), nil
        }</span>

        <span class="cov1" title="1">if config.HasSourceProfile() </span><span class="cov1" title="1">{
                log.Printf("profile %s: sourcing credentials from profile %s", config.ProfileName, config.SourceProfile.ProfileName)
                return t.GetProviderForProfile(config.SourceProfile)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("profile %s: credentials missing", config.ProfileName)</span>
}

func (t *TempCredentialsCreator) getSourceCredWithSession(config *ProfileConfig, hasStoredCredentials bool) (sourcecredsProvider aws.CredentialsProvider, err error) <span class="cov1" title="1">{
        sourcecredsProvider, err = t.getSourceCreds(config, hasStoredCredentials)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if hasStoredCredentials || !config.HasRole() </span><span class="cov1" title="1">{
                if canUseGetSessionToken, reason := t.canUseGetSessionToken(config); !canUseGetSessionToken </span><span class="cov1" title="1">{
                        log.Printf("profile %s: skipping GetSessionToken because %s", config.ProfileName, reason)
                        if !config.HasRole() </span><span class="cov1" title="1">{
                                return sourcecredsProvider, nil
                        }</span>
                }
                <span class="cov0" title="0">t.chainedMfa = config.MfaSerial
                log.Printf("profile %s: using GetSessionToken %s", config.ProfileName, mfaDetails(false, config))
                sourcecredsProvider, err = NewSessionTokenProvider(sourcecredsProvider, t.Keyring.Keyring, config, !t.DisableCache)
                if !config.HasRole() || err != nil </span><span class="cov0" title="0">{
                        return sourcecredsProvider, err
                }</span>
        }

        <span class="cov0" title="0">if config.HasRole() </span><span class="cov0" title="0">{
                isMfaChained := config.MfaSerial != "" &amp;&amp; config.MfaSerial == t.chainedMfa
                if isMfaChained </span><span class="cov0" title="0">{
                        config.MfaSerial = ""
                }</span>
                <span class="cov0" title="0">log.Printf("profile %s: using AssumeRole %s", config.ProfileName, mfaDetails(isMfaChained, config))
                return NewAssumeRoleProvider(sourcecredsProvider, t.Keyring.Keyring, config, !t.DisableCache)</span>
        }

        <span class="cov0" title="0">if isMasterCredentialsProvider(sourcecredsProvider) </span><span class="cov0" title="0">{
                canUseGetSessionToken, reason := t.canUseGetSessionToken(config)
                if canUseGetSessionToken </span><span class="cov0" title="0">{
                        t.chainedMfa = config.MfaSerial
                        log.Printf("profile %s: using GetSessionToken %s", config.ProfileName, mfaDetails(false, config))
                        return NewSessionTokenProvider(sourcecredsProvider, t.Keyring.Keyring, config, !t.DisableCache)
                }</span>
                <span class="cov0" title="0">log.Printf("profile %s: skipping GetSessionToken because %s", config.ProfileName, reason)</span>
        }

        <span class="cov0" title="0">return sourcecredsProvider, nil</span>
}

func (t *TempCredentialsCreator) GetProviderForProfile(config *ProfileConfig) (aws.CredentialsProvider, error) <span class="cov10" title="4">{
        hasStoredCredentials, err := t.Keyring.Has(config.ProfileName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="4">if hasStoredCredentials || config.HasSourceProfile() </span><span class="cov1" title="1">{
                return t.getSourceCredWithSession(config, hasStoredCredentials)
        }</span>

        <span class="cov8" title="3">if config.HasSSOStartURL() </span><span class="cov1" title="1">{
                log.Printf("profile %s: using SSO role credentials", config.ProfileName)
                return NewSSORoleCredentialsProvider(t.Keyring.Keyring, config, !t.DisableCache)
        }</span>

        <span class="cov5" title="2">if config.HasWebIdentity() </span><span class="cov1" title="1">{
                log.Printf("profile %s: using web identity", config.ProfileName)
                return NewAssumeRoleWithWebIdentityProvider(t.Keyring.Keyring, config, !t.DisableCache)
        }</span>

        <span class="cov1" title="1">if config.HasCredentialProcess() </span><span class="cov1" title="1">{
                log.Printf("profile %s: using credential process", config.ProfileName)
                return NewCredentialProcessProvider(t.Keyring.Keyring, config, !t.DisableCache)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("profile %s: credentials missing", config.ProfileName)</span>
}

// canUseGetSessionToken determines if GetSessionToken should be used, and if not returns a reason
func (t *TempCredentialsCreator) canUseGetSessionToken(c *ProfileConfig) (bool, string) <span class="cov1" title="1">{
        if t.DisableSessions </span><span class="cov1" title="1">{
                return false, "sessions are disabled"
        }</span>
        <span class="cov0" title="0">if t.DisableSessionsForProfile == c.ProfileName </span><span class="cov0" title="0">{
                return false, "sessions are disabled for this profile"
        }</span>

        <span class="cov0" title="0">if c.IsChained() </span><span class="cov0" title="0">{
                if !c.ChainedFromProfile.HasMfaSerial() </span><span class="cov0" title="0">{
                        return false, fmt.Sprintf("profile '%s' has no MFA serial defined", c.ChainedFromProfile.ProfileName)
                }</span>

                <span class="cov0" title="0">if !c.HasMfaSerial() &amp;&amp; c.ChainedFromProfile.HasMfaSerial() </span><span class="cov0" title="0">{
                        return false, fmt.Sprintf("profile '%s' has no MFA serial defined", c.ProfileName)
                }</span>

                <span class="cov0" title="0">if c.ChainedFromProfile.MfaSerial != c.MfaSerial </span><span class="cov0" title="0">{
                        return false, fmt.Sprintf("MFA serial doesn't match profile '%s'", c.ChainedFromProfile.ProfileName)
                }</span>

                <span class="cov0" title="0">if c.ChainedFromProfile.AssumeRoleDuration &gt; roleChainingMaximumDuration </span><span class="cov0" title="0">{
                        return false, fmt.Sprintf("duration %s in profile '%s' is greater than the AWS maximum %s for chaining MFA", c.ChainedFromProfile.AssumeRoleDuration, c.ChainedFromProfile.ProfileName, roleChainingMaximumDuration)
                }</span>
        }

        <span class="cov0" title="0">return true, ""</span>
}

func mfaDetails(mfaChained bool, config *ProfileConfig) string <span class="cov0" title="0">{
        if mfaChained </span><span class="cov0" title="0">{
                return "(chained MFA)"
        }</span>
        <span class="cov0" title="0">if config.HasMfaSerial() </span><span class="cov0" title="0">{
                return "(with MFA)"
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// NewTempCredentialsProvider creates a credential provider for the given config
func NewTempCredentialsProvider(config *ProfileConfig, keyring *CredentialKeyring, disableSessions bool, disableCache bool) (aws.CredentialsProvider, error) <span class="cov8" title="3">{
        t := TempCredentialsCreator{
                Keyring:         keyring,
                DisableSessions: disableSessions,
                DisableCache:    disableCache,
        }
        return t.GetProviderForProfile(config)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
