---
phase: 72-security-validation
plan: 03
type: execute
wave: 2
depends_on: ["72-01", "72-02"]
files_modified: [cli/identity_security_test.go]
autonomous: true
---

<objective>
Create comprehensive security validation tests for AWS identity integration.

Purpose: Verify that all identity types (IAM user, SSO assumed-role, regular assumed-role, federated-user, root) work correctly across all Sentinel commands with the new AWS identity extraction.
Output: Security regression test suite validating the OS username bug fix.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/72-security-validation/72-01-SUMMARY.md
@.planning/phases/72-security-validation/72-02-SUMMARY.md

# Identity package with all types
@identity/aws_identity.go
@identity/aws_identity_test.go

# Commands to test
@cli/credentials.go
@cli/approve.go
@cli/breakglass.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create security regression tests for identity extraction</name>
  <files>cli/identity_security_test.go</files>
  <action>
Create a new test file with security-focused tests verifying the OS username bug is fixed:

```go
package cli

import (
    "context"
    "testing"

    "github.com/aws/aws-sdk-go-v2/aws"
    "github.com/aws/aws-sdk-go-v2/service/sts"
    "github.com/byteness/aws-vault/v7/identity"
)

// TestSecurityRegression_IdentityExtraction verifies that all commands use
// AWS identity instead of OS username for security-critical operations.
//
// Bug: Prior to v1.7.1, Sentinel used os/user.Current() for policy evaluation,
// allowing users to bypass policies by running as a different local user.

func TestSecurityRegression_CredentialsUsesAWSIdentity(t *testing.T) {
    // Test that credentials command extracts username from AWS ARN, not OS
    tests := []struct {
        name        string
        arnReturned string
        wantUser    string
    }{
        {
            name:        "IAM user",
            arnReturned: "arn:aws:iam::123456789012:user/alice",
            wantUser:    "alice",
        },
        {
            name:        "SSO assumed-role with email",
            arnReturned: "arn:aws:sts::123456789012:assumed-role/AWSReservedSSO_Admin_abc/alice@company.com",
            wantUser:    "alicecompanycom",
        },
        {
            name:        "Regular assumed-role",
            arnReturned: "arn:aws:sts::123456789012:assumed-role/AdminRole/bob",
            wantUser:    "bob",
        },
        {
            name:        "Federated user",
            arnReturned: "arn:aws:sts::123456789012:federated-user/carol",
            wantUser:    "carol",
        },
        {
            name:        "GovCloud IAM user",
            arnReturned: "arn:aws-us-gov:iam::123456789012:user/dave",
            wantUser:    "dave",
        },
        {
            name:        "China partition",
            arnReturned: "arn:aws-cn:iam::123456789012:user/eve",
            wantUser:    "eve",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            mockClient := &mockSTSClient{
                GetCallerIdentityFunc: func(ctx context.Context, params *sts.GetCallerIdentityInput, optFns ...func(*sts.Options)) (*sts.GetCallerIdentityOutput, error) {
                    return &sts.GetCallerIdentityOutput{
                        Arn:     aws.String(tt.arnReturned),
                        Account: aws.String("123456789012"),
                    }, nil
                },
            }

            username, err := identity.GetAWSUsername(context.Background(), mockClient)
            if err != nil {
                t.Fatalf("GetAWSUsername() error = %v", err)
            }

            if username != tt.wantUser {
                t.Errorf("SECURITY VIOLATION: Expected username %q from ARN, got %q", tt.wantUser, username)
            }
        })
    }
}

func TestSecurityRegression_NoOSUserLeakage(t *testing.T) {
    // Verify that extracting identity does not return OS-level information
    // when given an AWS ARN. This guards against regression where someone
    // might accidentally re-add os/user imports.

    testARNs := []string{
        "arn:aws:iam::123456789012:user/aws-alice",
        "arn:aws:sts::123456789012:assumed-role/Role/session",
    }

    for _, arn := range testARNs {
        t.Run(arn, func(t *testing.T) {
            identity, err := identity.ParseARN(arn)
            if err != nil {
                t.Fatalf("ParseARN() error = %v", err)
            }

            // Username must come from ARN, not match any potential OS user
            // This is a sanity check - the real protection is code review
            if identity.Username == "" {
                t.Error("SECURITY VIOLATION: Empty username extracted from ARN")
            }
        })
    }
}
```

Include additional tests for:
- Break-glass authorization uses mock ARN username
- Approval authorization uses mock ARN username
- Request submission uses mock ARN username

Follow TestSecurityRegression_ naming convention for CI filtering.
  </action>
  <verify>go test ./cli/... -run "TestSecurityRegression_" -v passes all security tests</verify>
  <done>identity_security_test.go created with comprehensive security regression tests</done>
</task>

<task type="auto">
  <name>Task 2: Add policy bypass prevention tests</name>
  <files>cli/identity_security_test.go</files>
  <action>
Add tests that verify policy evaluation uses the AWS identity, not OS username:

```go
func TestSecurityRegression_PolicyUsesAWSUsername(t *testing.T) {
    // Create a policy that allows "alice" but denies everyone else
    // Verify that when STS returns alice's ARN, policy allows
    // Verify that when STS returns bob's ARN, policy denies
    // This proves policy uses AWS identity, not OS user

    // Test setup with mock policy evaluator
    // ...
}

func TestSecurityRegression_BreakGlassUsesAWSUsername(t *testing.T) {
    // Create break-glass policy allowing "alice" to invoke
    // Verify when STS returns alice's ARN, break-glass is allowed
    // Verify when STS returns bob's ARN, break-glass is denied
}

func TestSecurityRegression_ApprovalUsesAWSUsername(t *testing.T) {
    // Create approval policy with "alice" as approver
    // Verify when STS returns alice's ARN, approval succeeds
    // Verify when STS returns bob's ARN, approval is unauthorized
}
```

These tests directly verify the security fix - that the AWS identity from GetCallerIdentity is used for all authorization decisions.
  </action>
  <verify>go test ./cli/... -run "TestSecurityRegression_" -v shows all policy bypass tests pass</verify>
  <done>Policy bypass prevention tests added, proving AWS identity is used for authorization</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./cli/... -run "TestSecurityRegression_"` all pass
- [ ] Tests cover all identity types (IAM user, SSO, assumed-role, federated, root)
- [ ] Tests verify policy evaluation uses AWS identity, not OS username
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Security regression tests cover the fix comprehensively
- Tests use TestSecurityRegression_ prefix for easy CI/CD filtering
  </success_criteria>

<output>
After completion, create `.planning/phases/72-security-validation/72-03-SUMMARY.md`
</output>
