---
phase: 128-audit-log-integrity
plan: 03
type: execute
wave: 2
depends_on: ["128-01"]
files_modified: [cli/audit_verify_logs.go, cli/audit_verify_logs_test.go, cmd/sentinel/main.go, logging/security_test.go]
autonomous: true
---

<objective>
Implement log verification CLI command and security regression tests for audit log integrity.

Purpose: Enable operators to verify log file integrity by checking HMAC signatures, and establish security regression tests to prevent tampering vulnerabilities from being reintroduced.

Output:
- `sentinel audit verify-logs <file>` command for log integrity verification
- Security regression tests for tamper detection
- Integration with existing CLI structure
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/128-audit-log-integrity/128-01-SUMMARY.md

@logging/logger.go
@logging/signature.go
@logging/signed_logger.go
@cli/audit.go
@cmd/sentinel/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create audit verify-logs command</name>
  <files>cli/audit_verify_logs.go, cli/audit_verify_logs_test.go</files>
  <action>
Create CLI command to verify HMAC signatures in log files.

**Command structure:**

```
sentinel audit verify-logs <file> [--key <hex-key>] [--key-file <path>]
```

**Flags:**
- `--key`: Hex-encoded HMAC key (64 chars for 32 bytes)
- `--key-file`: Path to file containing hex-encoded key
- (At least one of --key or --key-file required)

**Behavior:**
1. Read log file line by line (JSON Lines format)
2. For each line, parse as SignedEntry JSON
3. Verify signature using VerifySignature from logging/signature.go
4. Track: total lines, verified OK, verification failed, parse errors
5. Output summary to stdout
6. Exit code: 0 if all valid, 1 if any failures/tampering detected

**Output format:**

```
Verifying: /path/to/audit.log
  Lines scanned: 1234
  Verified OK:   1230
  Invalid sig:   2
  Parse errors:  2

VERIFICATION FAILED: 4 entries have integrity issues
  Line 45: invalid signature (possible tampering)
  Line 89: invalid signature (possible tampering)
  Line 102: parse error: invalid JSON
  Line 567: parse error: missing signature field

Exit code: 1
```

If all valid:
```
Verifying: /path/to/audit.log
  Lines scanned: 1234
  Verified OK:   1234
  Invalid sig:   0
  Parse errors:  0

VERIFICATION PASSED: All 1234 entries have valid signatures
Exit code: 0
```

**Implementation notes:**
- Use bufio.Scanner for line-by-line reading (memory efficient)
- Parse each line as json.RawMessage first, then unmarshal to SignedEntry
- Use logging.VerifySignature for actual verification
- Collect first N (e.g., 10) failures for detailed output, then summarize
- Support stdin via "-" as filename
- Validate key is 32 bytes after hex decode

**CLI integration:**
Follow existing audit command pattern from cli/audit.go. Add as subcommand under "audit".

**Test cases:**
- Valid log file with all correct signatures -> exit 0
- Log file with tampered entry -> exit 1, shows line number
- Log file with missing signature -> exit 1, parse error
- Invalid JSON line -> exit 1, parse error
- Empty file -> exit 0 (0 entries verified)
- Key from --key flag
- Key from --key-file
- Missing key -> error message
- Invalid hex key -> error message
  </action>
  <verify>go build ./cli && go test ./cli -run TestAuditVerifyLogs -v</verify>
  <done>
- Command parses file and verifies signatures
- Exit code 0 for all valid, 1 for any failures
- Detailed output showing failure locations
- Key loading from flag or file
- Edge cases handled (empty file, parse errors)
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Register verify-logs command in main</name>
  <files>cmd/sentinel/main.go</files>
  <action>
Register the audit verify-logs command in the CLI application.

Add to the audit command group (find existing pattern in main.go with "audit" subcommands):

```go
// Audit verify-logs command
auditVerifyLogs := audit.Command("verify-logs", "Verify HMAC signatures in audit log files.")
auditVerifyLogsFile := auditVerifyLogs.Arg("file", "Path to log file (use - for stdin).").Required().String()
auditVerifyLogsKey := auditVerifyLogs.Flag("key", "Hex-encoded HMAC key (64 chars).").String()
auditVerifyLogsKeyFile := auditVerifyLogs.Flag("key-file", "Path to file containing hex key.").String()
```

Add case in switch statement:

```go
case auditVerifyLogs.FullCommand():
    return cli.AuditVerifyLogsCommand(
        *auditVerifyLogsFile,
        *auditVerifyLogsKey,
        *auditVerifyLogsKeyFile,
    )
```

Follow existing patterns from other audit commands (audit verify, audit untracked-sessions, audit session-compliance).
  </action>
  <verify>go build ./cmd/sentinel && ./cmd/sentinel/sentinel audit verify-logs --help</verify>
  <done>
- verify-logs appears in audit --help output
- sentinel audit verify-logs --help shows correct flags
- Command is wired to CLI function
  </done>
</task>

<task type="auto">
  <name>Task 3: Create security regression tests for log integrity</name>
  <files>logging/security_test.go</files>
  <action>
Create comprehensive security regression tests for audit log integrity.

**Test file: logging/security_test.go**

Follow TestSecurity_ naming convention from policy/security_test.go.

**Test cases to implement:**

1. **TestSecurity_SignatureDetectsTampering**
   - Create signed entry
   - Modify entry content
   - Verify signature fails
   - Documents: Tampering with log entry invalidates signature

2. **TestSecurity_SignatureDetectsTruncation**
   - Create signed entry with all fields
   - Remove a field from entry
   - Verify signature fails
   - Documents: Removing fields is detected as tampering

3. **TestSecurity_SignatureDetectsReplay**
   - Create two signed entries at different times
   - Swap signatures between entries
   - Verify both fail
   - Documents: Signatures are entry-specific, not reusable

4. **TestSecurity_WrongKeyRejected**
   - Create signed entry with key A
   - Verify with key B
   - Verify signature fails
   - Documents: Correct key required for verification

5. **TestSecurity_ConstantTimeComparison**
   - Use AST parsing to verify VerifySignature uses crypto/subtle.ConstantTimeCompare
   - Follows pattern from mfa/security_test.go
   - Documents: Timing attack prevention

6. **TestSecurity_MinimumKeyLength**
   - Attempt to create SignatureConfig with short key (< 32 bytes)
   - Verify error returned
   - Documents: Weak keys rejected

7. **TestSecurity_EmptySignatureRejected**
   - Create entry with empty signature field
   - Verify fails
   - Documents: Missing signatures detected

**AST verification for constant-time comparison:**
```go
// Verify VerifySignature uses subtle.ConstantTimeCompare
func TestSecurity_ConstantTimeComparison(t *testing.T) {
    // Parse logging/signature.go
    // Find VerifySignature function
    // Check for subtle.ConstantTimeCompare call
    // Pattern from mfa/security_test.go
}
```

**Security comment pattern:**
Each test should have a comment explaining the attack scenario:
```go
// SECURITY: This test verifies that modifying a log entry after signing
// is detected. An attacker who gains access to log files cannot modify
// entries without detection if the signing key is protected.
func TestSecurity_SignatureDetectsTampering(t *testing.T) {
```
  </action>
  <verify>go test ./logging -run TestSecurity -v</verify>
  <done>
- All security regression tests pass
- Tests cover tampering, truncation, replay, wrong key, timing safety, key length, empty signature
- AST verification for constant-time comparison
- Security comments document attack scenarios
- Tests will fail if signature verification is weakened
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./cli succeeds
- [ ] go build ./cmd/sentinel succeeds
- [ ] go test ./cli -run TestAuditVerifyLogs -v passes
- [ ] go test ./logging -run TestSecurity -v passes
- [ ] sentinel audit verify-logs --help shows usage
- [ ] Security tests verify constant-time comparison via AST
</verification>

<success_criteria>

- All tasks completed
- verify-logs command functional with proper exit codes
- Security regression tests cover key attack scenarios
- AST-based verification of timing-safe comparison
- All verification checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/128-audit-log-integrity/128-03-SUMMARY.md`
</output>
