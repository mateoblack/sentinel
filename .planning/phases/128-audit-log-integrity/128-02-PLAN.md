---
phase: 128-audit-log-integrity
plan: 02
type: execute
wave: 2
depends_on: ["128-01"]
files_modified: [go.mod, go.sum, logging/cloudwatch.go, logging/cloudwatch_test.go, lambda/config.go, lambda/config_test.go]
autonomous: true
---

<objective>
Implement CloudWatch Logs forwarder with signed log forwarding for Lambda TVM.

Purpose: Enable centralized, tamper-evident log aggregation in CloudWatch Logs. This provides durable storage with AWS-managed retention and enables cross-account log analysis for security teams.

Output:
- CloudWatchLogger that forwards signed logs to CloudWatch Logs
- Lambda TVM configuration for CloudWatch log forwarding
- Integration tests for CloudWatch logging
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/128-audit-log-integrity/128-01-SUMMARY.md

@logging/logger.go
@logging/signature.go
@logging/signed_logger.go
@lambda/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CloudWatch Logs SDK dependency</name>
  <files>go.mod, go.sum</files>
  <action>
Add the CloudWatch Logs SDK to the project dependencies.

```bash
go get github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs
```

This follows the existing pattern of AWS SDK v2 service dependencies already in go.mod (ssm, dynamodb, sts, kms, sns, etc.).
  </action>
  <verify>go mod tidy && grep cloudwatchlogs go.mod</verify>
  <done>
- github.com/aws/aws-sdk-go-v2/service/cloudwatchlogs in go.mod
- go mod tidy completes without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CloudWatch Logs forwarder</name>
  <files>logging/cloudwatch.go, logging/cloudwatch_test.go</files>
  <action>
Create CloudWatchLogger that forwards signed logs to CloudWatch Logs.

**Types to create:**

```go
// CloudWatchConfig holds configuration for CloudWatch log forwarding.
type CloudWatchConfig struct {
    LogGroupName  string           // CloudWatch log group name
    LogStreamName string           // CloudWatch log stream name (typically instance/function ID)
    SignConfig    *SignatureConfig // Signature config for signing entries (nil to disable)
}

// CloudWatchAPI defines the CloudWatch Logs operations used.
// This interface enables testing with mock implementations.
type CloudWatchAPI interface {
    PutLogEvents(ctx context.Context, params *cloudwatchlogs.PutLogEventsInput, optFns ...func(*cloudwatchlogs.Options)) (*cloudwatchlogs.PutLogEventsOutput, error)
}

// CloudWatchLogger implements Logger by forwarding to CloudWatch Logs.
type CloudWatchLogger struct {
    client        CloudWatchAPI
    config        *CloudWatchConfig
    sequenceToken *string // For PutLogEvents sequencing
    mu            sync.Mutex
}

// NewCloudWatchLogger creates a CloudWatch logger from AWS config.
func NewCloudWatchLogger(awsCfg aws.Config, config *CloudWatchConfig) *CloudWatchLogger
```

**Interface implementation:**
- LogDecision(entry DecisionLogEntry) - sign (if config) and forward to CloudWatch
- LogApproval(entry ApprovalLogEntry) - sign (if config) and forward to CloudWatch
- LogBreakGlass(entry BreakGlassLogEntry) - sign (if config) and forward to CloudWatch

**Implementation notes:**
- Use PutLogEvents API with single event per call (simplest, Lambda context is short-lived)
- If SignConfig is set, wrap entry with signature before sending
- JSON marshal the entry/SignedEntry for the log message
- Use current timestamp (milliseconds since epoch) for CloudWatch timestamp
- Handle sequence token for log stream (store and update after each call)
- Fail-open on CloudWatch errors (log to stderr, don't block) - matches rate limiter pattern
- Use sync.Mutex for sequence token thread safety

**CloudWatch Logs format:**
Each log event message is the JSON entry (signed or unsigned):
```json
{"entry":{...},"signature":"...","key_id":"...","timestamp":"..."}
```

**Test cases (with mock CloudWatchAPI):**
- Verify PutLogEvents called with correct log group/stream
- Verify message is valid JSON
- Verify signature included when SignConfig is set
- Verify signature omitted when SignConfig is nil
- Verify sequence token is updated after calls
- Verify errors are logged but don't fail the call
  </action>
  <verify>go build ./logging && go test ./logging -run TestCloudWatch -v</verify>
  <done>
- CloudWatchLogger implements Logger interface
- PutLogEvents called with correct parameters
- Signed entries include signature, key_id, timestamp
- Sequence token handled correctly
- Errors logged but don't block logging
- All tests pass with mock CloudWatchAPI
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate CloudWatch logging into Lambda TVM</name>
  <files>lambda/config.go, lambda/config_test.go</files>
  <action>
Add CloudWatch log forwarding configuration to Lambda TVM.

**New environment variables:**

```go
const (
    // CloudWatch logging configuration
    EnvLogSigningKey     = "SENTINEL_LOG_SIGNING_KEY"      // Hex-encoded HMAC key (64 chars for 32 bytes)
    EnvLogSigningKeyID   = "SENTINEL_LOG_SIGNING_KEY_ID"   // Key identifier for rotation
    EnvCloudWatchGroup   = "SENTINEL_CLOUDWATCH_LOG_GROUP" // CloudWatch log group (optional)
    EnvCloudWatchStream  = "SENTINEL_CLOUDWATCH_STREAM"    // CloudWatch log stream (default: function name)
)
```

**TVMConfig additions:**

```go
type TVMConfig struct {
    // ... existing fields ...

    // LogSigningKey is the HMAC key for signing log entries.
    // If set, all log entries will include a signature for integrity verification.
    // Environment variable: SENTINEL_LOG_SIGNING_KEY (hex-encoded, 64 chars)
    LogSigningKey []byte

    // LogSigningKeyID identifies the signing key for key rotation.
    // Environment variable: SENTINEL_LOG_SIGNING_KEY_ID
    LogSigningKeyID string

    // CloudWatchLogGroup is the log group for CloudWatch forwarding.
    // If empty, CloudWatch forwarding is disabled (logs go to stdout only).
    // Environment variable: SENTINEL_CLOUDWATCH_LOG_GROUP
    CloudWatchLogGroup string

    // CloudWatchStream is the log stream name within the group.
    // Defaults to AWS_LAMBDA_FUNCTION_NAME if not set.
    // Environment variable: SENTINEL_CLOUDWATCH_STREAM
    CloudWatchStream string
}
```

**LoadConfigFromEnv updates:**

1. Parse SENTINEL_LOG_SIGNING_KEY (hex decode to bytes, validate 32 bytes)
2. Parse SENTINEL_LOG_SIGNING_KEY_ID
3. Parse SENTINEL_CLOUDWATCH_LOG_GROUP
4. Parse SENTINEL_CLOUDWATCH_STREAM (default to AWS_LAMBDA_FUNCTION_NAME)
5. Configure Logger based on settings:
   - No signing, no CloudWatch: JSONLogger to stdout (existing)
   - Signing, no CloudWatch: SignedLogger to stdout
   - Signing + CloudWatch: CloudWatchLogger with SignConfig
   - No signing + CloudWatch: CloudWatchLogger without SignConfig

**Logger selection logic:**

```go
// Configure logger based on signing and CloudWatch settings
if cfg.CloudWatchLogGroup != "" {
    // CloudWatch forwarding enabled
    cwConfig := &logging.CloudWatchConfig{
        LogGroupName:  cfg.CloudWatchLogGroup,
        LogStreamName: cfg.CloudWatchStream,
    }
    if len(cfg.LogSigningKey) > 0 {
        cwConfig.SignConfig = &logging.SignatureConfig{
            KeyID:     cfg.LogSigningKeyID,
            SecretKey: cfg.LogSigningKey,
        }
    }
    cfg.Logger = logging.NewCloudWatchLogger(awsCfg, cwConfig)
} else if len(cfg.LogSigningKey) > 0 {
    // Signing enabled, stdout output
    signConfig := &logging.SignatureConfig{
        KeyID:     cfg.LogSigningKeyID,
        SecretKey: cfg.LogSigningKey,
    }
    cfg.Logger = logging.NewSignedLogger(os.Stdout, signConfig)
} else {
    // Default: unsigned stdout (existing behavior)
    cfg.Logger = logging.NewJSONLogger(os.Stdout)
}
```

**Test cases:**
- Verify hex key parsing (valid 64-char hex -> 32 bytes)
- Verify invalid hex key returns error
- Verify short key (< 32 bytes) returns error
- Verify CloudWatch config created when log group set
- Verify SignConfig included when signing key set
- Verify default stream name from AWS_LAMBDA_FUNCTION_NAME
  </action>
  <verify>go build ./lambda && go test ./lambda -run TestConfig -v</verify>
  <done>
- Environment variable parsing for all new config options
- Hex key decoding with validation (32 bytes minimum)
- Logger selection based on signing + CloudWatch settings
- Default stream name from Lambda function name
- All tests pass with various configuration combinations
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go mod tidy completes without errors
- [ ] go build ./logging succeeds
- [ ] go build ./lambda succeeds
- [ ] go test ./logging -v passes all tests
- [ ] go test ./lambda -v passes all tests
- [ ] CloudWatch Logs SDK added to go.mod
- [ ] Lambda TVM supports signing + CloudWatch configuration
</verification>

<success_criteria>

- All tasks completed
- CloudWatch Logs SDK dependency added
- CloudWatchLogger implements Logger interface
- Lambda TVM configurable for signed CloudWatch logging
- All verification checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/128-audit-log-integrity/128-02-SUMMARY.md`
</output>
