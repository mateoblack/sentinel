---
phase: 128-audit-log-integrity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [logging/signature.go, logging/signature_test.go, logging/signed_logger.go, logging/signed_logger_test.go]
autonomous: true
---

<objective>
Implement HMAC-SHA256 signing infrastructure for tamper-evident audit logs.

Purpose: Provide cryptographic integrity for all Sentinel log entries, enabling detection of tampering or modification. This is foundational for audit log integrity - all subsequent plans depend on this signing infrastructure.

Output:
- Signature types and HMAC-SHA256 signing utilities
- SignedLogger that wraps existing Logger with automatic signature generation
- Comprehensive unit tests for signature generation and verification
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@logging/logger.go
@logging/decision.go
@logging/breakglass.go
@device/identity.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HMAC signature types and utilities</name>
  <files>logging/signature.go, logging/signature_test.go</files>
  <action>
Create signature types and HMAC-SHA256 signing utilities for log integrity.

**Types to create:**

```go
// SignatureConfig holds configuration for log signing.
type SignatureConfig struct {
    KeyID     string // Identifier for the signing key (for key rotation)
    SecretKey []byte // HMAC-SHA256 secret key (32 bytes recommended)
}

// SignedEntry wraps a log entry with its cryptographic signature.
type SignedEntry struct {
    Entry     any    `json:"entry"`     // The original log entry (any type)
    Signature string `json:"signature"` // Hex-encoded HMAC-SHA256 signature
    KeyID     string `json:"key_id"`    // Key identifier for verification
    Timestamp string `json:"timestamp"` // ISO8601 timestamp when signed
}
```

**Functions to create:**

```go
// ComputeSignature computes HMAC-SHA256 of the entry's JSON representation.
// Returns hex-encoded signature string.
func ComputeSignature(entry any, secretKey []byte) (string, error)

// VerifySignature verifies the HMAC-SHA256 signature of an entry.
// Uses constant-time comparison to prevent timing attacks.
func VerifySignature(entry any, signature string, secretKey []byte) (bool, error)

// NewSignedEntry creates a signed entry with current timestamp.
func NewSignedEntry(entry any, config *SignatureConfig) (*SignedEntry, error)

// Verify checks the signature of a SignedEntry.
func (s *SignedEntry) Verify(secretKey []byte) (bool, error)
```

**Implementation notes:**
- Use crypto/hmac and crypto/sha256 from stdlib (no new dependencies)
- Use crypto/subtle.ConstantTimeCompare for signature verification (timing attack prevention)
- JSON marshal the entry before computing HMAC to ensure deterministic input
- Hex-encode signatures for JSON compatibility (32 bytes -> 64 chars)
- Include key_id in output for key rotation support (different keys for different environments)

**Security requirements:**
- MUST use crypto/subtle.ConstantTimeCompare (timing attack prevention per v1.16)
- MUST validate key length (minimum 32 bytes for HMAC-SHA256)
- MUST return (false, nil) for invalid signatures (not error) - matches KMS pattern from Phase 126
  </action>
  <verify>go build ./logging && go test ./logging -run TestSignature -v</verify>
  <done>
- ComputeSignature returns hex-encoded HMAC-SHA256 signature
- VerifySignature uses constant-time comparison
- NewSignedEntry creates signed entries with key_id and timestamp
- SignedEntry.Verify validates signature integrity
- All tests pass with coverage for edge cases (empty entry, wrong key, tampered data)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SignedLogger wrapper implementation</name>
  <files>logging/signed_logger.go, logging/signed_logger_test.go</files>
  <action>
Create SignedLogger that wraps existing Logger implementations with automatic signature generation.

**Type to create:**

```go
// SignedLogger wraps a Logger to automatically sign all log entries.
// It implements the Logger interface and delegates to an underlying writer.
type SignedLogger struct {
    writer io.Writer      // Output destination (e.g., os.Stdout, file)
    config *SignatureConfig
}

// NewSignedLogger creates a SignedLogger with the given writer and config.
func NewSignedLogger(w io.Writer, config *SignatureConfig) *SignedLogger
```

**Interface implementation:**
- LogDecision(entry DecisionLogEntry) - signs and writes
- LogApproval(entry ApprovalLogEntry) - signs and writes
- LogBreakGlass(entry BreakGlassLogEntry) - signs and writes

**Output format:**
Each log line is a JSON object:
```json
{"entry":{...original fields...},"signature":"hex64chars","key_id":"prod-2026","timestamp":"2026-01-26T12:00:00Z"}
```

**Implementation notes:**
- Create SignedEntry from input, JSON marshal the wrapped entry
- Write single line of JSON (JSON Lines format preserved)
- Use NewSignedEntry internally for consistent signing
- On signing error, log to stderr but don't fail (fail-open for availability, matches rate limiter pattern)

**Test cases:**
- Verify signature is included in output
- Verify different entry types (Decision, Approval, BreakGlass) all get signed
- Verify output is valid JSON
- Verify signature can be verified with same key
- Verify signature fails verification with wrong key
  </action>
  <verify>go build ./logging && go test ./logging -run TestSigned -v</verify>
  <done>
- SignedLogger implements Logger interface
- All three log methods (LogDecision, LogApproval, LogBreakGlass) produce signed output
- Output is valid JSON Lines with entry, signature, key_id, timestamp fields
- Signatures can be verified with VerifySignature
- Signing errors logged but don't block logging (fail-open)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./logging succeeds
- [ ] go test ./logging -v passes all tests
- [ ] go vet ./logging shows no issues
- [ ] gofmt -l ./logging shows no formatting issues
- [ ] Signature uses HMAC-SHA256 with crypto/subtle for verification
- [ ] SignedLogger implements all Logger interface methods
</verification>

<success_criteria>

- All tasks completed
- HMAC-SHA256 signature infrastructure in place
- SignedLogger wraps existing logger with automatic signing
- All verification checks pass
- No new external dependencies (uses stdlib crypto)
</success_criteria>

<output>
After completion, create `.planning/phases/128-audit-log-integrity/128-01-SUMMARY.md`
</output>
