---
phase: 20-request-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [cli/request.go, cli/request_test.go, cmd/sentinel/main.go]
autonomous: true
---

<objective>
Implement CLI command for submitting access requests with profile, duration, and justification.

Purpose: Enable users to request access to AWS profiles that require approval before credentials are issued.
Output: Working `sentinel request` command that creates requests in DynamoDB and outputs request ID for tracking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-request-schema/18-01-SUMMARY.md
@.planning/phases/19-dynamodb-backend/19-01-SUMMARY.md
@.planning/phases/19-dynamodb-backend/19-02-SUMMARY.md

# Relevant source files
@request/types.go
@request/validate.go
@request/store.go
@request/dynamodb.go
@cli/credentials.go
@cli/sentinel.go
@cmd/sentinel/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create request command with CLI configuration and core logic</name>
  <files>cli/request.go</files>
  <action>
Create `cli/request.go` with the request command implementation:

1. Define `RequestCommandInput` struct with fields:
   - `ProfileName string` - AWS profile to request access to (required)
   - `Duration time.Duration` - how long access is needed (default 1h, max 8h)
   - `Justification string` - reason for access (required, 10-500 chars)
   - `RequestTable string` - DynamoDB table name for requests (required)
   - `Region string` - AWS region for DynamoDB (optional, uses default)

2. Create `ConfigureRequestCommand(app *kingpin.Application, s *Sentinel)`:
   - Add "request" command with description "Submit an access request for approval"
   - Add flags: `--profile` (required), `--duration` (default 1h), `--justification` (required), `--request-table` (required), `--region` (optional)
   - Register action that calls `RequestCommand`

3. Implement `RequestCommand(ctx context.Context, input RequestCommandInput, s *Sentinel) error`:
   - Get current user via `user.Current()` (same pattern as credentials.go)
   - Validate profile exists using `s.ValidateProfile(input.ProfileName)`
   - Cap duration at `request.MaxDuration` (8h) - if user provides longer, cap it and warn
   - Load AWS config with `config.LoadDefaultConfig(ctx)`, optionally with region
   - Create DynamoDB store: `request.NewDynamoDBStore(awsCfg, input.RequestTable)`
   - Build Request struct:
     - ID: `request.NewRequestID()`
     - Requester: current user's username
     - Profile: from input
     - Justification: from input
     - Duration: from input (capped)
     - Status: `request.StatusPending`
     - CreatedAt/UpdatedAt: `time.Now()`
     - ExpiresAt: `time.Now().Add(request.DefaultRequestTTL)`
   - Validate request with `req.Validate()`
   - Store with `store.Create(ctx, req)`
   - On success: output JSON with request ID and status for user
   - On error: output error to stderr and return error

Output format (JSON to stdout for scripting):
```json
{
  "request_id": "a1b2c3d4e5f67890",
  "profile": "production",
  "status": "pending",
  "expires_at": "2026-01-16T12:00:00Z"
}
```

Follow existing patterns from `cli/credentials.go`:
- Error handling with `fmt.Fprintf(os.Stderr, ...)`
- JSON output to stdout for tool integration
- Context parameter for cancellation
  </action>
  <verify>go build ./... succeeds</verify>
  <done>cli/request.go exists with ConfigureRequestCommand and RequestCommand functions</done>
</task>

<task type="auto">
  <name>Task 2: Wire command in main.go and add unit tests</name>
  <files>cmd/sentinel/main.go, cli/request_test.go</files>
  <action>
1. Update `cmd/sentinel/main.go`:
   - Add `cli.ConfigureRequestCommand(app, s)` after the existing command configurations
   - Follow existing pattern with credentials and exec commands

2. Create `cli/request_test.go` with tests:
   - Use mock Store interface for testing (don't hit real DynamoDB)
   - Test cases:
     - Success: valid request created and stored
     - Error: profile not found in AWS config
     - Error: justification too short (< 10 chars)
     - Error: justification too long (> 500 chars)
     - Error: duration exceeds max (verify capping behavior)
     - Error: store.Create fails (e.g., network error)

   Create a mock store implementation in the test file:
   ```go
   type mockStore struct {
       createFn func(ctx context.Context, req *request.Request) error
   }
   func (m *mockStore) Create(ctx context.Context, req *request.Request) error {
       return m.createFn(ctx, req)
   }
   // ... other Store methods as no-ops
   ```

   Refactor RequestCommand to accept a Store interface parameter (or add a testable variant) to enable mocking. Options:
   - Add `store request.Store` field to `RequestCommandInput`
   - Or create internal function that takes store as parameter

   Test the core logic, not kingpin flag parsing (that's kingpin's job).
  </action>
  <verify>go test ./cli/... passes</verify>
  <done>main.go wires request command, request_test.go has 6+ test cases passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./...` passes all tests
- [ ] `go vet ./...` reports no issues
- [ ] `sentinel request --help` shows correct usage
</verification>

<success_criteria>

- cli/request.go implements ConfigureRequestCommand and RequestCommand
- cmd/sentinel/main.go wires the request command
- cli/request_test.go has comprehensive test coverage
- All builds and tests pass
- Command accepts --profile, --duration, --justification, --request-table, --region flags
  </success_criteria>

<output>
After completion, create `.planning/phases/20-request-command/20-01-SUMMARY.md`
</output>
