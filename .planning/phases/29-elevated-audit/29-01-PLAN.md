---
phase: 29-elevated-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [logging/breakglass.go, logging/breakglass_test.go, logging/logger.go, logging/logger_test.go]
autonomous: true
---

<objective>
Create break-glass audit logging infrastructure with BreakGlassLogEntry type and LogBreakGlass method.

Purpose: Enable structured audit trail for break-glass emergency access events with mandatory justification and incident correlation fields.
Output: BreakGlassLogEntry type, NewBreakGlassLogEntry constructor, extended Logger interface with LogBreakGlass method.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-break-glass-schema/27-01-SUMMARY.md
@.planning/phases/28-break-glass-command/28-02-SUMMARY.md

@logging/logger.go
@logging/approval.go
@logging/decision.go
@breakglass/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BreakGlassLogEntry type with NewBreakGlassLogEntry constructor</name>
  <files>logging/breakglass.go, logging/breakglass_test.go</files>
  <action>
Create `logging/breakglass.go` following the ApprovalLogEntry pattern:

1. **BreakGlassLogEntry struct** with these fields (all required for break-glass audit):
   - `Timestamp string` (json:"timestamp") - ISO8601 format
   - `Event string` (json:"event") - Event type: "breakglass.invoked", "breakglass.closed", "breakglass.expired"
   - `EventID string` (json:"event_id") - 16-char hex break-glass event ID
   - `RequestID string` (json:"request_id") - 16-char hex request ID for CloudTrail correlation
   - `Invoker string` (json:"invoker") - Who invoked break-glass
   - `Profile string` (json:"profile") - AWS profile accessed
   - `ReasonCode string` (json:"reason_code") - Incident category (incident, maintenance, security, recovery, other)
   - `Justification string` (json:"justification") - Mandatory detailed explanation (20-1000 chars)
   - `Status string` (json:"status") - Current status (active, closed, expired)
   - `Duration int` (json:"duration_seconds") - Requested duration in seconds
   - `ExpiresAt string` (json:"expires_at") - ISO8601 expiration time
   - `ClosedBy string` (json:"closed_by,omitempty") - Who closed (for closed events)
   - `ClosedReason string` (json:"closed_reason,omitempty") - Why closed early

2. **Event type constants** (parallel to notification.EventType but for break-glass):
   - `BreakGlassEventInvoked = "breakglass.invoked"`
   - `BreakGlassEventClosed = "breakglass.closed"`
   - `BreakGlassEventExpired = "breakglass.expired"`

3. **NewBreakGlassLogEntry(event string, bg *breakglass.BreakGlassEvent) BreakGlassLogEntry**:
   - Set Timestamp to iso8601.Format(time.Now())
   - Copy all fields from BreakGlassEvent
   - Duration as int seconds
   - ExpiresAt as ISO8601 string
   - ClosedBy and ClosedReason only populated for closed/expired events

Create `logging/breakglass_test.go` with table-driven tests:
- Test NewBreakGlassLogEntry for each event type (invoked, closed, expired)
- Test JSON marshaling produces expected field names
- Test omitempty behavior for ClosedBy/ClosedReason
- Test Duration conversion to seconds
- Test ExpiresAt ISO8601 formatting
  </action>
  <verify>go test ./logging/... -run TestBreakGlass -v passes</verify>
  <done>BreakGlassLogEntry type created with constructor and tests for all 3 event types</done>
</task>

<task type="auto">
  <name>Task 2: Extend Logger interface with LogBreakGlass method</name>
  <files>logging/logger.go, logging/logger_test.go</files>
  <action>
Extend `logging/logger.go`:

1. **Add LogBreakGlass to Logger interface** (parallel to LogDecision and LogApproval):
   ```go
   type Logger interface {
       LogDecision(entry DecisionLogEntry)
       LogApproval(entry ApprovalLogEntry)
       LogBreakGlass(entry BreakGlassLogEntry)  // NEW
   }
   ```

2. **Implement LogBreakGlass in JSONLogger**:
   - Same pattern as LogApproval: json.Marshal entry, write to writer, append newline

3. **Implement LogBreakGlass in NopLogger**:
   - Empty implementation (intentionally discards)

Update `logging/logger_test.go`:
- Test JSONLogger.LogBreakGlass writes valid JSON with newline
- Test NopLogger.LogBreakGlass succeeds (doesn't panic)
- Verify JSON output contains expected fields
  </action>
  <verify>go test ./logging/... -v passes with all new LogBreakGlass tests</verify>
  <done>Logger interface extended, JSONLogger and NopLogger implement LogBreakGlass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./logging/...` passes all tests
- [ ] BreakGlassLogEntry marshals to expected JSON format
- [ ] Logger interface has all 3 methods: LogDecision, LogApproval, LogBreakGlass
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- BreakGlassLogEntry type follows ApprovalLogEntry pattern
- Logger interface extended with LogBreakGlass method
- JSONLogger and NopLogger both implement LogBreakGlass
- No errors or warnings introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/29-elevated-audit/29-01-SUMMARY.md`
</output>
