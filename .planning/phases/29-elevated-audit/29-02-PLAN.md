---
phase: 29-elevated-audit
plan: 02
type: execute
wave: 2
depends_on: ["29-01"]
files_modified: [cli/breakglass.go, cli/breakglass_test.go]
autonomous: true
---

<objective>
Integrate break-glass logging into the CLI command for complete audit trail.

Purpose: Wire LogBreakGlass into breakglass command so all break-glass invocations are logged.
Output: BreakGlass CLI command logs invocations via Logger interface.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-elevated-audit/29-01-SUMMARY.md

@cli/breakglass.go
@logging/breakglass.go
@logging/logger.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire LogBreakGlass into breakglass CLI command</name>
  <files>cli/breakglass.go</files>
  <action>
Update `cli/breakglass.go` to use the Logger:

1. **Replace the placeholder comment** at line ~180-183:
   ```go
   // 10. Log break-glass invocation if Logger is provided
   // Note: Full break-glass audit logging will be implemented in Phase 29 (elevated-audit)
   // For now, we log a placeholder entry to maintain audit trail
   _ = input.Logger // Logger reserved for Phase 29
   ```

   With actual logging:
   ```go
   // 10. Log break-glass invocation if Logger is provided
   if input.Logger != nil {
       entry := logging.NewBreakGlassLogEntry(logging.BreakGlassEventInvoked, event)
       input.Logger.LogBreakGlass(entry)
   }
   ```

2. **Ensure import** for logging package is present (should already be there).

3. **Do NOT change** anything else - the Logger field is already in BreakGlassCommandInput and is injected by callers.
  </action>
  <verify>go build ./cli/... succeeds</verify>
  <done>BreakGlass command logs invocations when Logger is provided</done>
</task>

<task type="auto">
  <name>Task 2: Add logging tests to breakglass CLI tests</name>
  <files>cli/breakglass_test.go</files>
  <action>
Update `cli/breakglass_test.go` to verify logging integration:

1. **Create a mock or capture logger** for testing. Options:
   - Use a bytes.Buffer with JSONLogger to capture output
   - Create a simple LogCapture struct that records entries

2. **Add test case "logs break-glass invocation"**:
   - Inject Logger via BreakGlassCommandInput
   - Execute successful break-glass command
   - Verify Logger received BreakGlassLogEntry with:
     - Event = "breakglass.invoked"
     - EventID = event ID from output
     - RequestID = request ID from output
     - Invoker = current user
     - Profile = test profile
     - ReasonCode = "incident"
     - Justification = test justification
     - Status = "active"
     - Duration > 0
     - ExpiresAt non-empty

3. **Add test case "no logging when Logger is nil"**:
   - Verify command succeeds without Logger (no panic, no error)
   - This should already pass but document the behavior
  </action>
  <verify>go test ./cli/... -run TestBreakGlass -v passes including logging tests</verify>
  <done>CLI tests verify logging integration and nil-Logger safety</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./cli/... -run TestBreakGlass` passes all tests
- [ ] Break-glass command logs invocations when Logger provided
- [ ] Break-glass command succeeds when Logger is nil
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- BreakGlass CLI logs invocations via LogBreakGlass
- Logging is optional (nil Logger doesn't break command)
- No errors or warnings introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/29-elevated-audit/29-02-SUMMARY.md`
</output>
