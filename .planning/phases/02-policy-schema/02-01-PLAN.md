---
phase: 02-policy-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [policy/types.go]
autonomous: true
---

<objective>
Define Go types for Sentinel's policy schema including Policy, Rule, Condition, and TimeWindow structs.

Purpose: Establish the data model that represents access control policies, enabling parsing and evaluation in later phases.
Output: policy/types.go with exported types and YAML struct tags.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONVENTIONS.md

# Phase 1 established patterns
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md

# Existing sentinel code
@cli/sentinel.go
@cli/sentinel_provider.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create policy types package with core schema structs</name>
  <files>policy/types.go</files>
  <action>
Create new package `policy` with the following types:

```go
// Policy is the top-level container for access rules.
type Policy struct {
    Version string `yaml:"version" json:"version"`
    Rules   []Rule `yaml:"rules" json:"rules"`
}

// Rule defines a single access control rule.
type Rule struct {
    Name       string    `yaml:"name" json:"name"`
    Effect     Effect    `yaml:"effect" json:"effect"`
    Conditions Condition `yaml:"conditions" json:"conditions"`
    Reason     string    `yaml:"reason,omitempty" json:"reason,omitempty"`
}

// Effect is the outcome of a matched rule.
type Effect string

const (
    EffectAllow Effect = "allow"
    EffectDeny  Effect = "deny"
)

// Condition defines matching criteria for a rule.
type Condition struct {
    Profiles []string    `yaml:"profiles,omitempty" json:"profiles,omitempty"`
    Users    []string    `yaml:"users,omitempty" json:"users,omitempty"`
    Time     *TimeWindow `yaml:"time,omitempty" json:"time,omitempty"`
}

// TimeWindow restricts when a rule applies.
type TimeWindow struct {
    Days     []Weekday  `yaml:"days,omitempty" json:"days,omitempty"`
    Hours    *HourRange `yaml:"hours,omitempty" json:"hours,omitempty"`
    Timezone string     `yaml:"timezone,omitempty" json:"timezone,omitempty"`
}

// Weekday represents a day of the week.
type Weekday string

const (
    Monday    Weekday = "monday"
    Tuesday   Weekday = "tuesday"
    Wednesday Weekday = "wednesday"
    Thursday  Weekday = "thursday"
    Friday    Weekday = "friday"
    Saturday  Weekday = "saturday"
    Sunday    Weekday = "sunday"
)

// HourRange defines a daily time window.
type HourRange struct {
    Start string `yaml:"start" json:"start"` // Format: "HH:MM" (24-hour)
    End   string `yaml:"end" json:"end"`     // Format: "HH:MM" (24-hour)
}
```

Follow conventions:
- PascalCase for exported types
- GoDoc comments for all exported types and constants
- YAML and JSON struct tags for serialization
- Pointer for optional nested structs (TimeWindow, HourRange)
- Slice for optional arrays (Profiles, Users, Days)
  </action>
  <verify>go build ./policy/... compiles without errors</verify>
  <done>
- Policy, Rule, Condition, TimeWindow, HourRange types defined
- Effect and Weekday type aliases with constants
- YAML and JSON struct tags on all fields
- GoDoc comments on all exported types
  </done>
</task>

<task type="auto">
  <name>Task 2: Add helper methods for Effect and Weekday types</name>
  <files>policy/types.go</files>
  <action>
Add validation helper methods to the custom types:

```go
// IsValid returns true if the Effect is a known value.
func (e Effect) IsValid() bool {
    return e == EffectAllow || e == EffectDeny
}

// String returns the string representation of the Effect.
func (e Effect) String() string {
    return string(e)
}

// IsValid returns true if the Weekday is a known value.
func (w Weekday) IsValid() bool {
    switch w {
    case Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday:
        return true
    }
    return false
}

// String returns the string representation of the Weekday.
func (w Weekday) String() string {
    return string(w)
}

// AllWeekdays returns all valid weekday values.
func AllWeekdays() []Weekday {
    return []Weekday{Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday}
}
```

These methods will be used by validation logic in 02-02.
  </action>
  <verify>go build ./policy/... compiles without errors</verify>
  <done>
- Effect.IsValid(), Effect.String() methods exist
- Weekday.IsValid(), Weekday.String() methods exist
- AllWeekdays() helper function exists
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./policy/...` succeeds without errors
- [ ] All types have GoDoc comments
- [ ] All fields have yaml and json struct tags
- [ ] Helper methods compile and are accessible
</verification>

<success_criteria>

- All tasks completed
- policy/types.go exists with all specified types
- No compilation errors
- Types follow codebase naming conventions
  </success_criteria>

<output>
After completion, create `.planning/phases/02-policy-schema/02-01-SUMMARY.md`
</output>
