---
phase: 02-policy-schema
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified: [policy/parse.go, policy/parse_test.go, policy/validate.go, policy/validate_test.go]
autonomous: true
---

<objective>
Implement YAML policy parsing and validation using TDD.

Purpose: Enable loading policies from YAML strings/files and validate they are semantically correct before use in evaluation.
Output: policy/parse.go, policy/validate.go with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Types from 02-01 (required)
@policy/types.go

# Codebase conventions for testing
@.planning/codebase/TESTING.md
@.planning/codebase/CONVENTIONS.md
</context>

<feature>
  <name>Policy Parsing</name>
  <files>policy/parse.go, policy/parse_test.go</files>
  <behavior>
Parse YAML string into Policy struct:
- Valid YAML → *Policy, nil error
- Empty input → error "empty policy"
- Invalid YAML syntax → error with position
- Missing version → error "missing version field"

Test cases:
```
Input: valid YAML with version "1" and one allow rule
Output: Policy{Version: "1", Rules: []Rule{...}}

Input: ""
Output: error containing "empty policy"

Input: "invalid: yaml: here:"
Output: error containing "yaml"

Input: "rules: []" (missing version)
Output: error containing "version"
```
  </behavior>
  <implementation>
Use gopkg.in/yaml.v3 for parsing:
```go
func ParsePolicy(data []byte) (*Policy, error)
func ParsePolicyFromReader(r io.Reader) (*Policy, error)
```

Parsing should:
1. Check for empty input first
2. Unmarshal YAML into Policy struct
3. Return wrapped errors with context
  </implementation>
</feature>

<feature>
  <name>Policy Validation</name>
  <files>policy/validate.go, policy/validate_test.go</files>
  <behavior>
Validate parsed Policy for semantic correctness:
- Valid policy → nil error
- Empty rules → error "policy must have at least one rule"
- Invalid effect → error "invalid effect 'X' in rule 'Y'"
- Rule without name → error "rule at index N missing name"
- Rule with no conditions → error "rule 'X' has no conditions"
- Invalid weekday → error "invalid weekday 'X' in rule 'Y'"
- Invalid hour format → error "invalid hour format 'X'"
- Invalid timezone → error "invalid timezone 'X'"

Test cases:
```
Input: Policy with one valid allow rule
Output: nil

Input: Policy with zero rules
Output: error containing "at least one rule"

Input: Policy with rule effect="invalid"
Output: error containing "invalid effect"

Input: Policy with rule missing name
Output: error containing "missing name"

Input: Rule with empty conditions (no profiles, users, or time)
Output: error containing "no conditions"

Input: TimeWindow with days=["notaday"]
Output: error containing "invalid weekday"

Input: HourRange with start="25:00"
Output: error containing "invalid hour format"

Input: TimeWindow with timezone="Invalid/Zone"
Output: error containing "invalid timezone"
```
  </behavior>
  <implementation>
```go
func (p *Policy) Validate() error
func (r *Rule) Validate() error
func (c *Condition) Validate() error
func (t *TimeWindow) Validate() error
func (h *HourRange) Validate() error
```

Validation approach:
1. Policy.Validate() checks version and delegates to rules
2. Rule.Validate() checks name, effect, delegates to conditions
3. Condition.Validate() checks at least one matcher present, delegates to time
4. TimeWindow.Validate() checks days, hours, timezone validity
5. HourRange.Validate() parses and validates HH:MM format

Use time.LoadLocation() for timezone validation.
Use regexp or time.Parse() for hour format validation.
  </implementation>
</feature>

<verification>
- [ ] `go test ./policy/...` passes all tests
- [ ] Parse tests cover: valid, empty, invalid YAML, missing version
- [ ] Validate tests cover: all error conditions listed above
- [ ] No compilation errors or warnings
</verification>

<success_criteria>

- RED phase: Failing tests written for both features
- GREEN phase: Implementation passes all tests
- REFACTOR phase: Code cleanup if needed
- All test cases from behavior section covered
- 2-3 atomic commits produced
  </success_criteria>

<output>
After completion, create `.planning/phases/02-policy-schema/02-02-SUMMARY.md` with:
- RED: What tests were written, why they failed
- GREEN: What implementation made them pass
- REFACTOR: What cleanup was done (if any)
- Commits: List of commits produced
</output>
