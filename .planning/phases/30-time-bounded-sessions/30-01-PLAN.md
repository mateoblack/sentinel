---
phase: 30-time-bounded-sessions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [breakglass/checker.go, breakglass/checker_test.go]
autonomous: true
---

<objective>
Create break-glass checker function to find active break-glass events for credential issuance.

Purpose: Enable credential commands to check for active break-glass access, paralleling the approved request checker pattern.
Output: FindActiveBreakGlass function with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context - break-glass types and store
@.planning/phases/27-break-glass-schema/27-01-SUMMARY.md
@.planning/phases/28-break-glass-command/28-01-SUMMARY.md

# Pattern reference - approved request checker
@request/checker.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FindActiveBreakGlass checker function</name>
  <files>breakglass/checker.go</files>
  <action>
Create checker.go in breakglass package following request/checker.go pattern:

1. FindActiveBreakGlass(ctx, store, invoker, profile) (*BreakGlassEvent, error):
   - Query store.ListByInvoker(ctx, invoker, limit) to get all events for invoker
   - Filter for: Status == StatusActive, Profile matches, ExpiresAt > now
   - Return first matching event or nil if none
   - Return error only for store errors, not for "no active event found"

2. RemainingDuration(event *BreakGlassEvent) time.Duration:
   - Returns time until ExpiresAt
   - Returns 0 if already expired

3. isBreakGlassValid(event *BreakGlassEvent) bool (internal):
   - Check status is active
   - Check ExpiresAt > now
   - Similar to isRequestValid in request/checker.go

Use MaxQueryLimit constant (define as 100 to match request package pattern).
  </action>
  <verify>go build ./breakglass/... succeeds</verify>
  <done>FindActiveBreakGlass and RemainingDuration functions exist and compile</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for break-glass checker</name>
  <files>breakglass/checker_test.go</files>
  <action>
Create checker_test.go with table-driven tests covering:

1. FindActiveBreakGlass:
   - Returns active break-glass for matching invoker+profile
   - Returns nil when no active event exists
   - Returns nil when event exists but status is closed
   - Returns nil when event exists but status is expired
   - Returns nil when event exists but profile doesn't match
   - Returns nil when event is past ExpiresAt
   - Returns error when store returns error
   - Returns first match when multiple events exist

2. RemainingDuration:
   - Returns positive duration for future expiry
   - Returns 0 for past expiry
   - Returns 0 for zero ExpiresAt

3. isBreakGlassValid:
   - Returns true for active + not expired
   - Returns false for closed status
   - Returns false for expired status
   - Returns false for past ExpiresAt

Use mock store pattern from breakglass/dynamodb_test.go.
  </action>
  <verify>go test ./breakglass/... -run Checker -v passes</verify>
  <done>All checker tests pass with 8+ test cases</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./breakglass/... succeeds
- [ ] go test ./breakglass/... passes
- [ ] FindActiveBreakGlass follows request/checker.go pattern
</verification>

<success_criteria>

- All tasks completed
- FindActiveBreakGlass, RemainingDuration functions implemented
- Comprehensive test coverage for all edge cases
- Pattern matches request/checker.go for consistency
  </success_criteria>

<output>
After completion, create `.planning/phases/30-time-bounded-sessions/30-01-SUMMARY.md`
</output>
