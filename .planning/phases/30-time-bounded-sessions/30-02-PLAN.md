---
phase: 30-time-bounded-sessions
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified: [cli/credentials.go, cli/sentinel_exec.go, cli/credentials_test.go, cli/sentinel_exec_test.go, logging/decision.go]
autonomous: true
---

<objective>
Integrate break-glass access into credential issuance with session duration capping.

Purpose: Enable break-glass events to grant credentials like approved requests, with automatic duration limiting to remaining break-glass time.
Output: credentials and exec commands check break-glass, cap duration, log break-glass event ID.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan - checker function
@.planning/phases/30-time-bounded-sessions/30-01-SUMMARY.md

# Pattern reference - approved request integration
@cli/credentials.go
@cli/sentinel_exec.go
@logging/decision.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BreakGlassEventID to credential logging fields</name>
  <files>logging/decision.go</files>
  <action>
Extend CredentialIssuanceFields struct:

1. Add field to CredentialIssuanceFields:
   ```go
   BreakGlassEventID string `json:"break_glass_event_id,omitempty"`
   ```

2. Use omitempty so field only appears when break-glass was used (same pattern as ApprovedRequestID).

This enables CloudTrail correlation between Sentinel logs and break-glass events.
  </action>
  <verify>go build ./logging/... succeeds</verify>
  <done>BreakGlassEventID field exists in CredentialIssuanceFields</done>
</task>

<task type="auto">
  <name>Task 2: Integrate break-glass into credentials command</name>
  <files>cli/credentials.go, cli/credentials_test.go</files>
  <action>
Modify CredentialsCommand to check break-glass after approved request check:

1. Add BreakGlassStore field to CredentialsCommandInput:
   ```go
   BreakGlassStore breakglass.Store // Optional: for break-glass checking (nil = no checking)
   ```

2. After checking for approved request (step 7), if still denied:
   ```go
   var activeBreakGlass *breakglass.BreakGlassEvent
   if approvedReq == nil && input.BreakGlassStore != nil {
       activeBreakGlass, err = breakglass.FindActiveBreakGlass(ctx, input.BreakGlassStore, username, input.ProfileName)
       if err != nil {
           log.Printf("Warning: failed to check break-glass: %v", err)
       }
   }

   if approvedReq == nil && activeBreakGlass == nil {
       // No approved request and no active break-glass - deny
       // ... existing deny logic
   }
   ```

3. Cap session duration to remaining break-glass time:
   ```go
   if activeBreakGlass != nil {
       remainingTime := breakglass.RemainingDuration(activeBreakGlass)
       if input.SessionDuration == 0 || input.SessionDuration > remainingTime {
           input.SessionDuration = remainingTime
           log.Printf("Capping session duration to break-glass remaining time: %v", remainingTime)
       }
   }
   ```

4. Include break-glass event ID in credential logging:
   ```go
   if activeBreakGlass != nil {
       credFields.BreakGlassEventID = activeBreakGlass.ID
   }
   ```

5. Add tests in credentials_test.go:
   - Test credentials issued via break-glass when policy denies
   - Test session duration capped to remaining break-glass time
   - Test BreakGlassEventID appears in log output
   - Test nil BreakGlassStore works (backward compatible)
  </action>
  <verify>go test ./cli/... -run Credentials -v passes</verify>
  <done>credentials command checks break-glass and caps duration</done>
</task>

<task type="auto">
  <name>Task 3: Integrate break-glass into exec command</name>
  <files>cli/sentinel_exec.go, cli/sentinel_exec_test.go</files>
  <action>
Modify SentinelExecCommand with same break-glass integration pattern:

1. Add BreakGlassStore field to SentinelExecCommandInput:
   ```go
   BreakGlassStore breakglass.Store // Optional: for break-glass checking (nil = no checking)
   ```

2. After approved request check (step 8), if still denied:
   - Check for active break-glass via FindActiveBreakGlass
   - If found, proceed to credential issuance
   - If not found, deny access (existing logic)

3. Cap session duration (same as credentials command):
   - If break-glass active, cap duration to RemainingDuration(activeBreakGlass)
   - Log the capping if duration was reduced

4. Include break-glass event ID in credential logging:
   - Add BreakGlassEventID to credFields if activeBreakGlass != nil

5. Add tests in sentinel_exec_test.go:
   - Test exec proceeds via break-glass when policy denies
   - Test session duration capped to remaining break-glass time
   - Test BreakGlassEventID in logs
   - Test nil BreakGlassStore works (backward compatible)
  </action>
  <verify>go test ./cli/... -run SentinelExec -v passes</verify>
  <done>exec command checks break-glass and caps duration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./... succeeds
- [ ] go test ./... passes
- [ ] credentials and exec commands check break-glass
- [ ] Session duration capped to remaining break-glass time
- [ ] Break-glass event ID logged for CloudTrail correlation
</verification>

<success_criteria>

- All tasks completed
- Break-glass access enables credential issuance when policy denies
- Session duration automatically capped to remaining break-glass time
- BreakGlassEventID included in decision logs
- Backward compatible (nil stores work)
  </success_criteria>

<output>
After completion, create `.planning/phases/30-time-bounded-sessions/30-02-SUMMARY.md`
</output>
