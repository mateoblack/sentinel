---
phase: 82-server-mode-enforcement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [policy/types.go, policy/evaluate.go, policy/validate.go, policy/evaluate_test.go]
autonomous: true
---

<objective>
Add `require_server` effect to policy schema for explicit server mode enforcement.

Purpose: Enable policies to require server mode for sensitive profiles with clear error messaging, following the `require_approval` pattern for new effects.
Output: New `EffectRequireServer` effect type with evaluation logic and validation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/79-server-policy-integration/79-01-SUMMARY.md

# Key source files
@policy/types.go
@policy/evaluate.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EffectRequireServer constant to policy schema</name>
  <files>policy/types.go</files>
  <action>
Add new effect constant `EffectRequireServer Effect = "require_server"` after `EffectRequireApproval`.

Update `IsValid()` method on Effect type to include `EffectRequireServer` in the valid values check.

Doc comment for the constant: "EffectRequireServer allows access only when credentials are requested via server mode. If the request mode is not 'server', access is denied with a clear error indicating server mode is required."

This follows the existing pattern - effects are string constants with IsValid() validation.
  </action>
  <verify>grep -n "EffectRequireServer" policy/types.go shows the new constant and IsValid check</verify>
  <done>EffectRequireServer constant defined with IsValid() support</done>
</task>

<task type="auto">
  <name>Task 2: Add RequiresServerMode field to Decision struct</name>
  <files>policy/evaluate.go</files>
  <action>
Add a new boolean field to the Decision struct:
```go
RequiresServerMode bool // True when EffectRequireServer matched but mode was not server
```

This field indicates to callers (CLI, server) that the denial was specifically due to server mode requirement, enabling targeted error messages.

Place after EvaluatedAt for logical grouping of metadata fields.
  </action>
  <verify>grep -n "RequiresServerMode" policy/evaluate.go shows the new field</verify>
  <done>RequiresServerMode field added to Decision struct</done>
</task>

<task type="auto">
  <name>Task 3: Implement require_server evaluation logic in Evaluate function</name>
  <files>policy/evaluate.go</files>
  <action>
Modify the Evaluate function to handle EffectRequireServer:

After the matchesConditions check succeeds and before returning the Decision:
1. If `rule.Effect == EffectRequireServer`:
   - If `req.Mode == ModeServer`: treat as allow (set Effect to EffectAllow in decision)
   - Else: treat as deny (set Effect to EffectDeny) AND set RequiresServerMode=true

The logic should be:
```go
if matchesConditions(&rule.Conditions, req) {
    conditionsCopy := rule.Conditions

    // Handle require_server effect - allow only in server mode
    effect := rule.Effect
    requiresServerMode := false
    if rule.Effect == EffectRequireServer {
        if req.Mode == ModeServer {
            effect = EffectAllow
        } else {
            effect = EffectDeny
            requiresServerMode = true
        }
    }

    return Decision{
        Effect:             effect,
        MatchedRule:        rule.Name,
        Reason:             rule.Reason,
        RuleIndex:          i,
        Conditions:         &conditionsCopy,
        EvaluatedAt:        evaluatedAt,
        MaxServerDuration:  rule.MaxServerDuration,
        RequiresServerMode: requiresServerMode,
    }
}
```

This preserves the original rule name and reason in the decision while converting the effect appropriately.
  </action>
  <verify>grep -n "EffectRequireServer" policy/evaluate.go shows the evaluation logic</verify>
  <done>Evaluate function handles require_server effect correctly</done>
</task>

<task type="auto">
  <name>Task 4: Add tests for require_server effect</name>
  <files>policy/evaluate_test.go</files>
  <action>
Add comprehensive tests for the require_server effect:

```go
func TestEvaluate_RequireServerEffect(t *testing.T) {
    tests := []struct {
        name               string
        mode               CredentialMode
        wantEffect         Effect
        wantRequiresServer bool
    }{
        {
            name:               "server mode allowed",
            mode:               ModeServer,
            wantEffect:         EffectAllow,
            wantRequiresServer: false,
        },
        {
            name:               "cli mode denied",
            mode:               ModeCLI,
            wantEffect:         EffectDeny,
            wantRequiresServer: true,
        },
        {
            name:               "credential_process mode denied",
            mode:               ModeCredentialProcess,
            wantEffect:         EffectDeny,
            wantRequiresServer: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            policy := &Policy{
                Version: "1",
                Rules: []Rule{
                    {
                        Name:   "require-server",
                        Effect: EffectRequireServer,
                        Conditions: Condition{
                            Profiles: []string{"production"},
                        },
                    },
                },
            }

            req := &Request{
                User:    "alice",
                Profile: "production",
                Time:    time.Now(),
                Mode:    tt.mode,
            }

            decision := Evaluate(policy, req)

            if decision.Effect != tt.wantEffect {
                t.Errorf("Effect = %v, want %v", decision.Effect, tt.wantEffect)
            }
            if decision.RequiresServerMode != tt.wantRequiresServer {
                t.Errorf("RequiresServerMode = %v, want %v", decision.RequiresServerMode, tt.wantRequiresServer)
            }
            if decision.MatchedRule != "require-server" {
                t.Errorf("MatchedRule = %v, want require-server", decision.MatchedRule)
            }
        })
    }
}
```

Also add test for Effect.IsValid() to include require_server:
```go
func TestEffectRequireServer_IsValid(t *testing.T) {
    if !EffectRequireServer.IsValid() {
        t.Error("EffectRequireServer.IsValid() = false, want true")
    }
}
```
  </action>
  <verify>go test ./policy/... -run TestEvaluate_RequireServer -v passes</verify>
  <done>Tests verify require_server allows server mode and denies non-server modes with RequiresServerMode flag</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./policy/...` passes all tests
- [ ] `gofmt -l .` shows no formatting issues
- [ ] grep confirms EffectRequireServer in types.go and evaluate.go
</verification>

<success_criteria>
- EffectRequireServer constant defined in policy/types.go
- Effect.IsValid() recognizes require_server
- Evaluate() converts require_server to allow (server mode) or deny (non-server)
- Decision.RequiresServerMode flag indicates denial was due to mode requirement
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/82-server-mode-enforcement/82-01-SUMMARY.md`
</output>
