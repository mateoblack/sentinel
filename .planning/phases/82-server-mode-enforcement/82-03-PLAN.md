---
phase: 82-server-mode-enforcement
plan: 03
type: execute
wave: 2
depends_on: ["82-01"]
files_modified: [sentinel/server.go, sentinel/server_test.go]
autonomous: true
---

<objective>
Add require_server handling to SentinelServer and comprehensive integration tests.

Purpose: Ensure server mode properly allows require_server rules and test the complete enforcement flow.
Output: Server handles require_server correctly; integration tests verify enforcement behavior.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/82-server-mode-enforcement/82-01-SUMMARY.md

# Key source files
@sentinel/server.go
@sentinel/server_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify server handles require_server as allow</name>
  <files>sentinel/server.go</files>
  <action>
The server already sets Mode: policy.ModeServer in the policy request (line 220). When Evaluate() processes a require_server rule, it converts it to EffectAllow for server mode requests.

Verify the current DefaultRoute denial handling correctly processes the converted decision. The existing code:
```go
if decision.Effect == policy.EffectDeny {
    // ... check approved request, break-glass, etc.
}
```

This should work correctly because Evaluate() returns EffectAllow (not EffectDeny) when require_server matches in server mode.

Add a comment above the deny handling block explaining this:
```go
// Handle deny decision - check for approved request or break-glass first
// Note: require_server rules return EffectAllow in server mode (handled by Evaluate),
// so they never reach this deny block when accessed via SentinelServer.
```

This documents the behavior for future maintainers.
  </action>
  <verify>grep -n "require_server" sentinel/server.go shows the explanatory comment</verify>
  <done>Server code documented to clarify require_server handling</done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for require_server in server mode</name>
  <files>sentinel/server_test.go</files>
  <action>
Add a test function to verify require_server allows access in server mode:

```go
func TestSentinelServer_RequireServerEffect_Allowed(t *testing.T) {
    // Create policy with require_server effect
    requireServerPolicy := &policy.Policy{
        Version: "1",
        Rules: []policy.Rule{
            {
                Name:   "prod-requires-server",
                Effect: policy.EffectRequireServer,
                Conditions: policy.Condition{
                    Profiles: []string{"production"},
                },
                Reason: "Production requires server mode",
            },
        },
    }

    mockLoader := &MockPolicyLoader{
        Policy: requireServerPolicy,
    }

    mockProvider := &MockCredentialProvider{
        Credentials: &CredentialResult{
            AccessKeyID:     "AKIAIOSFODNN7EXAMPLE",
            SecretAccessKey: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
            SessionToken:    "token",
            Expiration:      time.Now().Add(15 * time.Minute),
            CanExpire:       true,
            SourceIdentity:  "sentinel:testuser:abc123",
            RoleARN:         "arn:aws:iam::123456789012:role/TestRole",
        },
    }

    config := SentinelServerConfig{
        ProfileName:        "production",
        PolicyParameter:    "/sentinel/test",
        User:               "testuser",
        PolicyLoader:       mockLoader,
        CredentialProvider: mockProvider,
        LazyLoad:           true,
    }

    server, err := NewSentinelServer(context.Background(), config, "test-token", 0)
    if err != nil {
        t.Fatalf("Failed to create server: %v", err)
    }
    defer server.Shutdown(context.Background())

    // Make request
    req := httptest.NewRequest("GET", "/", nil)
    req.Header.Set("Authorization", "test-token")
    rec := httptest.NewRecorder()

    server.DefaultRoute(rec, req)

    // Should allow - server mode satisfies require_server
    if rec.Code != http.StatusOK {
        t.Errorf("Status = %d, want %d. Body: %s", rec.Code, http.StatusOK, rec.Body.String())
    }

    // Verify credentials returned
    var creds map[string]string
    if err := json.NewDecoder(rec.Body).Decode(&creds); err != nil {
        t.Fatalf("Failed to decode response: %v", err)
    }
    if creds["AccessKeyId"] != "AKIAIOSFODNN7EXAMPLE" {
        t.Errorf("AccessKeyId = %v, want AKIAIOSFODNN7EXAMPLE", creds["AccessKeyId"])
    }
}
```

This test verifies that server mode correctly allows require_server rules.
  </action>
  <verify>go test ./sentinel/... -run TestSentinelServer_RequireServerEffect -v passes</verify>
  <done>Integration test verifies require_server allows server mode access</done>
</task>

<task type="auto">
  <name>Task 3: Add test for require_server logging behavior</name>
  <files>sentinel/server_test.go</files>
  <action>
Add a test to verify that require_server decisions are logged correctly:

```go
func TestSentinelServer_RequireServerEffect_Logging(t *testing.T) {
    // Create policy with require_server effect
    requireServerPolicy := &policy.Policy{
        Version: "1",
        Rules: []policy.Rule{
            {
                Name:   "prod-requires-server",
                Effect: policy.EffectRequireServer,
                Conditions: policy.Condition{
                    Profiles: []string{"production"},
                },
                Reason: "Production requires server mode",
            },
        },
    }

    mockLoader := &MockPolicyLoader{
        Policy: requireServerPolicy,
    }

    mockProvider := &MockCredentialProvider{
        Credentials: &CredentialResult{
            AccessKeyID:     "AKIAIOSFODNN7EXAMPLE",
            SecretAccessKey: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
            SessionToken:    "token",
            Expiration:      time.Now().Add(15 * time.Minute),
            CanExpire:       true,
            SourceIdentity:  "sentinel:testuser:abc123",
            RoleARN:         "arn:aws:iam::123456789012:role/TestRole",
        },
    }

    mockLogger := &MockLogger{}

    config := SentinelServerConfig{
        ProfileName:        "production",
        PolicyParameter:    "/sentinel/test",
        User:               "testuser",
        PolicyLoader:       mockLoader,
        CredentialProvider: mockProvider,
        Logger:             mockLogger,
        LazyLoad:           true,
    }

    server, err := NewSentinelServer(context.Background(), config, "test-token", 0)
    if err != nil {
        t.Fatalf("Failed to create server: %v", err)
    }
    defer server.Shutdown(context.Background())

    // Make request
    req := httptest.NewRequest("GET", "/", nil)
    req.Header.Set("Authorization", "test-token")
    rec := httptest.NewRecorder()

    server.DefaultRoute(rec, req)

    // Verify logging occurred
    if len(mockLogger.Entries) != 1 {
        t.Fatalf("Expected 1 log entry, got %d", len(mockLogger.Entries))
    }

    // The logged effect should be "allow" (converted from require_server)
    entry := mockLogger.Entries[0]
    if entry.Effect != "allow" {
        t.Errorf("Logged effect = %v, want allow", entry.Effect)
    }
    if entry.MatchedRule != "prod-requires-server" {
        t.Errorf("MatchedRule = %v, want prod-requires-server", entry.MatchedRule)
    }
}
```

This ensures audit logs correctly show the allow decision with the original rule name.

Note: Assumes MockLogger exists in server_test.go. If not, add it following the existing mock patterns.
  </action>
  <verify>go test ./sentinel/... -run TestSentinelServer_RequireServerEffect_Logging -v passes</verify>
  <done>Test verifies require_server logging shows allow effect with rule name</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./sentinel/...` passes all tests
- [ ] New tests verify require_server allows server mode
- [ ] Logging test verifies correct effect in audit trail
</verification>

<success_criteria>
- Server code has explanatory comment about require_server handling
- Integration test verifies server mode allows require_server
- Logging test verifies audit trail shows correct effect and rule
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/82-server-mode-enforcement/82-03-SUMMARY.md`
</output>
