---
phase: 104-device-fingerprint-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [device/types.go, device/types_test.go, policy/types.go, policy/device.go, policy/device_test.go, logging/decision.go, logging/decision_test.go]
autonomous: true
---

<objective>
Define device posture data model with device ID, attestation claims, and policy binding for v1.15 Device Posture milestone.

Purpose: Establish foundational types that later phases will use for device collection, policy evaluation, and decision logging.
Output: New device/ package with posture types, policy condition extensions, and enhanced decision log fields.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow:
@policy/types.go
@session/types.go
@logging/decision.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create device posture types package</name>
  <files>device/types.go, device/types_test.go</files>
  <action>
Create new `device/` package with device posture types following existing patterns from session/types.go and policy/types.go:

1. **DeviceID type** - String type alias for device identifier:
   - 32-character lowercase hex string (128 bits entropy from crypto/rand)
   - NewDeviceID() function generates new random ID
   - ValidateDeviceID() validates format
   - Regex validation pattern like session/types.go

2. **PostureStatus enum** - String type with constants:
   - `compliant` - Device meets all requirements
   - `non_compliant` - Device fails one or more requirements
   - `unknown` - Posture cannot be determined
   - IsValid() and String() methods

3. **DevicePosture struct** - Core posture claims:
   ```go
   type DevicePosture struct {
       DeviceID         string        `json:"device_id"`
       Status           PostureStatus `json:"status"`
       DiskEncrypted    *bool         `json:"disk_encrypted,omitempty"`
       FirewallEnabled  *bool         `json:"firewall_enabled,omitempty"`
       OSVersion        string        `json:"os_version,omitempty"`
       OSType           string        `json:"os_type,omitempty"`  // darwin, windows, linux
       MDMEnrolled      *bool         `json:"mdm_enrolled,omitempty"`
       MDMCompliant     *bool         `json:"mdm_compliant,omitempty"`
       CollectedAt      time.Time     `json:"collected_at"`
       CollectorVersion string        `json:"collector_version,omitempty"`
   }
   ```
   Use pointer bools for optional fields (nil = not checked, vs false = explicitly false).

4. **DevicePosture methods**:
   - Validate() error - checks DeviceID format and required fields
   - IsCompliant() bool - returns true if Status == compliant
   - HasDiskEncryption() bool - returns true if DiskEncrypted is non-nil and true

5. Package doc comment explaining purpose and relationship to v1.15 Device Posture.

Write comprehensive tests in device/types_test.go:
- TestNewDeviceID generates valid IDs
- TestValidateDeviceID accepts valid, rejects invalid
- TestPostureStatus_IsValid for all values
- TestDevicePosture_Validate edge cases
- Table-driven tests following existing test patterns
  </action>
  <verify>go test ./device/... -v passes with all tests green</verify>
  <done>device/ package exists with DeviceID, PostureStatus, DevicePosture types, validation methods, and comprehensive tests</done>
</task>

<task type="auto">
  <name>Task 2: Add device conditions to policy schema</name>
  <files>policy/types.go, policy/device.go, policy/device_test.go</files>
  <action>
Extend policy schema to support device posture conditions:

1. **In policy/types.go** - Add Device field to Condition struct:
   ```go
   type Condition struct {
       Profiles []string         `yaml:"profiles,omitempty" json:"profiles,omitempty"`
       Users    []string         `yaml:"users,omitempty" json:"users,omitempty"`
       Time     *TimeWindow      `yaml:"time,omitempty" json:"time,omitempty"`
       Mode     []CredentialMode `yaml:"mode,omitempty" json:"mode,omitempty"`
       Device   *DeviceCondition `yaml:"device,omitempty" json:"device,omitempty"`  // NEW
   }
   ```

2. **Create policy/device.go** - Device condition types:
   ```go
   // DeviceCondition defines device posture requirements for a rule.
   type DeviceCondition struct {
       // RequireEncryption requires disk encryption to be enabled.
       RequireEncryption bool `yaml:"require_encryption,omitempty" json:"require_encryption,omitempty"`

       // RequireMDM requires device to be MDM enrolled.
       RequireMDM bool `yaml:"require_mdm,omitempty" json:"require_mdm,omitempty"`

       // RequireMDMCompliant requires device to be MDM compliant (implies RequireMDM).
       RequireMDMCompliant bool `yaml:"require_mdm_compliant,omitempty" json:"require_mdm_compliant,omitempty"`

       // RequireFirewall requires firewall to be enabled.
       RequireFirewall bool `yaml:"require_firewall,omitempty" json:"require_firewall,omitempty"`

       // MinOSVersion specifies minimum OS version (semver format).
       MinOSVersion string `yaml:"min_os_version,omitempty" json:"min_os_version,omitempty"`

       // AllowedOSTypes restricts to specific OS types (darwin, windows, linux).
       // Empty list means any OS type allowed.
       AllowedOSTypes []string `yaml:"allowed_os_types,omitempty" json:"allowed_os_types,omitempty"`
   }
   ```

3. **DeviceCondition methods**:
   - Validate() error - validates MinOSVersion is valid semver if set, AllowedOSTypes are known values
   - IsEmpty() bool - returns true if no requirements set
   - Matches(posture *device.DevicePosture) bool - checks if posture meets all requirements

4. **Matches() logic**:
   - If RequireEncryption && (posture.DiskEncrypted == nil || !*posture.DiskEncrypted) → false
   - If RequireMDM && (posture.MDMEnrolled == nil || !*posture.MDMEnrolled) → false
   - If RequireMDMCompliant && (posture.MDMCompliant == nil || !*posture.MDMCompliant) → false
   - If RequireFirewall && (posture.FirewallEnabled == nil || !*posture.FirewallEnabled) → false
   - If MinOSVersion set, compare semver (use golang.org/x/mod/semver or simple string compare if not available in go.mod)
   - If AllowedOSTypes non-empty, check posture.OSType is in list
   - All conditions AND'd together

5. Write tests in policy/device_test.go:
   - TestDeviceCondition_Validate
   - TestDeviceCondition_IsEmpty
   - TestDeviceCondition_Matches with table-driven tests for all conditions

Note: Do NOT modify policy/evaluate.go in this task - that's Phase 108 (Device Attestation Flow).
  </action>
  <verify>go test ./policy/... -v passes including new device tests</verify>
  <done>DeviceCondition type exists in policy/device.go with Validate, IsEmpty, Matches methods; Condition.Device field added to policy/types.go</done>
</task>

<task type="auto">
  <name>Task 3: Add device context to decision logs</name>
  <files>logging/decision.go, logging/decision_test.go</files>
  <action>
Extend decision logging to include device posture context for forensic analysis:

1. **In logging/decision.go** - Add device fields to DecisionLogEntry:
   ```go
   type DecisionLogEntry struct {
       // ... existing fields ...

       // Device posture context (populated when device posture is evaluated)
       DeviceID          string `json:"device_id,omitempty"`           // Device identifier
       DeviceStatus      string `json:"device_status,omitempty"`       // compliant, non_compliant, unknown
       DeviceDiskEncrypt bool   `json:"device_disk_encrypted,omitempty"` // Disk encryption status
       DeviceMDMEnrolled bool   `json:"device_mdm_enrolled,omitempty"`   // MDM enrollment status
       DeviceOSType      string `json:"device_os_type,omitempty"`        // darwin, windows, linux
       DeviceOSVersion   string `json:"device_os_version,omitempty"`     // OS version string
   }
   ```

2. **Add device fields to CredentialIssuanceFields**:
   ```go
   type CredentialIssuanceFields struct {
       // ... existing fields ...

       // Device posture (nil if not evaluated)
       DevicePosture *device.DevicePosture
   }
   ```

3. **Update NewEnhancedDecisionLogEntry** to populate device fields:
   ```go
   if creds != nil && creds.DevicePosture != nil {
       entry.DeviceID = creds.DevicePosture.DeviceID
       entry.DeviceStatus = string(creds.DevicePosture.Status)
       if creds.DevicePosture.DiskEncrypted != nil {
           entry.DeviceDiskEncrypt = *creds.DevicePosture.DiskEncrypted
       }
       if creds.DevicePosture.MDMEnrolled != nil {
           entry.DeviceMDMEnrolled = *creds.DevicePosture.MDMEnrolled
       }
       entry.DeviceOSType = creds.DevicePosture.OSType
       entry.DeviceOSVersion = creds.DevicePosture.OSVersion
   }
   ```

4. Add import for device package in logging/decision.go.

5. Write tests in logging/decision_test.go:
   - TestNewEnhancedDecisionLogEntry_WithDevicePosture - verify device fields populated
   - TestNewEnhancedDecisionLogEntry_WithoutDevicePosture - verify nil device doesn't break
   - TestNewEnhancedDecisionLogEntry_PartialDevicePosture - verify optional fields handled

Use omitempty on all device fields so existing log consumers aren't impacted (backward compatibility).
  </action>
  <verify>go test ./logging/... -v passes including new device log tests</verify>
  <done>DecisionLogEntry has device context fields; CredentialIssuanceFields has DevicePosture; NewEnhancedDecisionLogEntry populates device fields</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./device/... ./policy/... ./logging/...` passes all tests
- [ ] `go vet ./device/... ./policy/... ./logging/...` reports no issues
- [ ] New types follow existing patterns (string type aliases with IsValid/String methods)
- [ ] All new fields use omitempty for backward compatibility
</verification>

<success_criteria>
- device/ package exists with DeviceID, PostureStatus, DevicePosture types
- policy/device.go has DeviceCondition type with Matches method
- policy/types.go Condition struct has Device field
- logging/decision.go has device context fields in DecisionLogEntry
- All tests pass
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/104-device-fingerprint-schema/104-01-SUMMARY.md`
</output>
