---
phase: 145-deployment-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - deploy/audit.go
  - deploy/audit_test.go
  - deploy/scp.go
  - deploy/scp_test.go
  - cli/deploy.go
  - cli/deploy_test.go
  - testutil/mock_aws.go
autonomous: true
---

<objective>
Implement deployment validation command for auditing Sentinel infrastructure security posture.

Purpose: Enable users to audit their complete Sentinel deployment for security misconfigurations including missing SCP enforcement, unprotected DynamoDB tables, unversioned SSM parameters, and unconfigured KMS monitoring. Generates actionable remediation commands.

Output: New `sentinel deploy validate` command with infrastructure auditing rules, risk classification, and remediation report generation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summary (trust validation patterns)
@.planning/phases/144-trust-policy-validation/144-01-SUMMARY.md

# Existing infrastructure checking
@bootstrap/status.go

# Existing advisor pattern
@enforce/advisor.go
@enforce/validate.go

# CLI patterns
@cli/trust.go
@cli/status.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deploy/audit.go with infrastructure audit checks</name>
  <files>deploy/audit.go, deploy/audit_test.go</files>
  <action>
Create new deploy/ package with infrastructure auditing capabilities:

1. Define DeploymentFinding struct (reuse pattern from enforce/validate.go):
   - CheckID string (DEPLOY-01, DEPLOY-02, etc.)
   - Category string (SCP, DynamoDB, SSM, KMS)
   - RiskLevel string (HIGH, MEDIUM, LOW)
   - Resource string (resource identifier)
   - Message string (description of issue)
   - Remediation string (specific command to fix)

2. Define DeploymentAuditResult struct:
   - Findings []DeploymentFinding
   - CheckedResources int
   - RiskSummary map[string]int (count per risk level)
   - HasCriticalIssues bool (true if any HIGH findings)

3. Define auditable resource interfaces:
   ```go
   // dynamodbAuditAPI for deletion protection and PITR checks
   type dynamodbAuditAPI interface {
       DescribeTable(ctx context.Context, params *dynamodb.DescribeTableInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DescribeTableOutput, error)
       DescribeContinuousBackups(ctx context.Context, params *dynamodb.DescribeContinuousBackupsInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DescribeContinuousBackupsOutput, error)
   }

   // ssmAuditAPI for parameter versioning checks
   type ssmAuditAPI interface {
       GetParameter(ctx context.Context, params *ssm.GetParameterInput, optFns ...func(*ssm.Options)) (*ssm.GetParameterOutput, error)
       GetParametersByPath(ctx context.Context, params *ssm.GetParametersByPathInput, optFns ...func(*ssm.Options)) (*ssm.GetParametersByPathOutput, error)
   }

   // kmsAuditAPI for key monitoring checks
   type kmsAuditAPI interface {
       DescribeKey(ctx context.Context, params *kms.DescribeKeyInput, optFns ...func(*kms.Options)) (*kms.DescribeKeyOutput, error)
   }

   // cloudwatchAuditAPI for alarm checks
   type cloudwatchAuditAPI interface {
       DescribeAlarms(ctx context.Context, params *cloudwatch.DescribeAlarmsInput, optFns ...func(*cloudwatch.Options)) (*cloudwatch.DescribeAlarmsOutput, error)
   }
   ```

4. Implement Auditor struct with methods:
   - AuditDynamoDBTables(ctx, tableNames []string) []DeploymentFinding
     - Check deletion protection (DeletionProtectionEnabled)
     - Check PITR status via DescribeContinuousBackups
     - DEPLOY-02: HIGH if deletion protection disabled
     - Generate remediation: `aws dynamodb update-table --table-name {name} --deletion-protection-enabled`

   - AuditSSMParameters(ctx, policyRoot string) []DeploymentFinding
     - List parameters under policyRoot
     - Check versioning (version > 1 means versioning is working)
     - Note: SSM versioning is automatic, but check if parameters are properly configured
     - DEPLOY-03: MEDIUM if parameter has only version 1 (may not be intentionally versioned)

   - AuditKMSKey(ctx, keyId string) []DeploymentFinding
     - Check key exists and is enabled
     - DEPLOY-04: HIGH if key is disabled or pending deletion

5. Create tests covering:
   - DynamoDB with deletion protection enabled/disabled
   - DynamoDB with PITR enabled/disabled
   - SSM parameters with various version numbers
   - KMS key in various states (enabled, disabled, pending deletion)
  </action>
  <verify>go test ./deploy/... -run TestAudit -v passes</verify>
  <done>Auditor checks DynamoDB protection, SSM versioning, KMS status and returns findings with remediation commands</done>
</task>

<task type="auto">
  <name>Task 2: Add SCP enforcement checking</name>
  <files>deploy/scp.go, deploy/scp_test.go</files>
  <action>
Add AWS Organizations SCP checking to deploy package:

1. Define organizationsAuditAPI interface:
   ```go
   type organizationsAuditAPI interface {
       ListPolicies(ctx context.Context, params *organizations.ListPoliciesInput, optFns ...func(*organizations.Options)) (*organizations.ListPoliciesOutput, error)
       DescribePolicy(ctx context.Context, params *organizations.DescribePolicyInput, optFns ...func(*organizations.Options)) (*organizations.DescribePolicyOutput, error)
       ListTargetsForPolicy(ctx context.Context, params *organizations.ListTargetsForPolicyInput, optFns ...func(*organizations.Options)) (*organizations.ListTargetsForPolicyOutput, error)
   }
   ```

2. Implement AuditSCPEnforcement method:
   - List all SCPs in the organization
   - Check if any SCP contains SourceIdentity requirement for AssumeRole
   - Look for policy content matching: `"sts:SourceIdentity"` condition
   - DEPLOY-01: HIGH if no SCP enforces SourceIdentity on protected roles
   - Generate remediation: `sentinel scp deploy --dry-run` (phase 146 command)

3. Define expected SCP pattern for Sentinel:
   ```go
   // sentinelSCPPattern checks if an SCP enforces SourceIdentity
   func isSentinelSCP(policyContent string) bool {
       // Check for Deny on sts:AssumeRole without sts:SourceIdentity condition
       return strings.Contains(policyContent, "sts:SourceIdentity") &&
              strings.Contains(policyContent, "sts:AssumeRole")
   }
   ```

4. Handle graceful degradation:
   - If Organizations API returns AccessDeniedException, report as UNKNOWN (not an error)
   - Common case: running outside management account

5. Create tests:
   - SCP exists with SourceIdentity enforcement (pass)
   - No SCP with SourceIdentity (fail - HIGH finding)
   - SCP exists but wrong pattern (fail)
   - Access denied (graceful - UNKNOWN status)
  </action>
  <verify>go test ./deploy/... -run TestSCP -v passes</verify>
  <done>AuditSCPEnforcement detects missing SourceIdentity SCP and returns appropriate findings</done>
</task>

<task type="auto">
  <name>Task 3: Add deploy validate CLI command</name>
  <files>cli/deploy.go, cli/deploy_test.go, testutil/mock_aws.go</files>
  <action>
Create cli/deploy.go with DeployValidateCommand:

1. DeployValidateCommandInput struct:
   - Region string
   - PolicyRoot string (default: /sentinel/policies)
   - Tables []string (default: sentinel-requests, sentinel-breakglass, sentinel-sessions)
   - SigningKeyID string (KMS key alias or ARN)
   - CheckSCP bool (default: true, requires management account)
   - JSONOutput bool
   - AWSProfile string
   - MinRisk string (filter findings by minimum risk level)
   - Auditor *deploy.Auditor (for testing)
   - Stdout, Stderr *os.File

2. ConfigureDeployValidateCommand:
   - Create "deploy" command group under app
   - Add "validate" subcommand: `sentinel deploy validate`
   - Flags: --region, --policy-root, --table (repeatable), --signing-key, --no-scp, --json, --aws-profile, --min-risk

3. DeployValidateCommand logic:
   - Create Auditor with AWS clients
   - Run all audit checks (conditionally skip SCP if --no-scp)
   - Aggregate findings from all checks
   - Filter by MinRisk
   - Output in human-readable or JSON format

4. Human-readable output format (follow trust validate pattern):
   ```
   Deployment Security Audit
   =========================

   Region: us-east-1
   Policy Root: /sentinel/policies

   DynamoDB Tables
   ---------------

     [HIGH] DEPLOY-02: Deletion protection disabled
       Table: sentinel-requests
       Remediation: aws dynamodb update-table --table-name sentinel-requests --deletion-protection-enabled

     [MEDIUM] DEPLOY-02: Point-in-time recovery disabled
       Table: sentinel-sessions
       Remediation: aws dynamodb update-continuous-backups --table-name sentinel-sessions --point-in-time-recovery-specification PointInTimeRecoveryEnabled=true

   SCP Enforcement
   ---------------

     [HIGH] DEPLOY-01: No SCP enforces SourceIdentity for AssumeRole
       Remediation: Run 'sentinel scp deploy --dry-run' to preview recommended SCP

   Summary
   -------
   Resources checked: 5
   Issues found:      3 (2 HIGH, 1 MEDIUM)

   Remediation Report
   ------------------

   # DynamoDB Hardening
   aws dynamodb update-table --table-name sentinel-requests --deletion-protection-enabled
   aws dynamodb update-continuous-backups --table-name sentinel-sessions --point-in-time-recovery-specification PointInTimeRecoveryEnabled=true

   # SCP Deployment
   sentinel scp deploy --dry-run
   ```

5. Exit codes (consistent with trust validate):
   - 0: All checks pass (no HIGH or MEDIUM findings)
   - 1: HIGH findings exist
   - 2: MEDIUM findings but no HIGH

6. Update testutil/mock_aws.go:
   - Add MockDynamoDBClient with DescribeTable, DescribeContinuousBackups
   - Add MockOrganizationsClient with ListPolicies, DescribePolicy, ListTargetsForPolicy
   - Add MockKMSClient (if not exists) with DescribeKey
   - Add MockCloudWatchClient with DescribeAlarms

7. Create cli/deploy_test.go with tests:
   - Healthy deployment (no findings)
   - DynamoDB issues detected
   - SCP missing (when --no-scp not specified)
   - JSON output format
   - MinRisk filtering
   - Exit codes based on findings
  </action>
  <verify>go test ./cli/... -run TestDeployValidate -v passes</verify>
  <done>sentinel deploy validate command audits infrastructure and outputs findings with remediation commands</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go test ./deploy/... -v passes
- [ ] go test ./cli/... -run Deploy -v passes
- [ ] gofmt -l . shows no formatting issues
- [ ] No new lint warnings introduced
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Auditor implements all 4 infrastructure checks (DynamoDB protection, DynamoDB PITR, SSM versioning, KMS status)
- SCP enforcement check with graceful degradation for non-management accounts
- CLI command outputs findings with risk levels and specific remediation commands
- Exit codes reflect finding severity (0=pass, 1=HIGH, 2=MEDIUM only)
- Remediation report provides copy-paste ready commands
</success_criteria>

<output>
After completion, create `.planning/phases/145-deployment-validation/145-01-SUMMARY.md`
</output>
