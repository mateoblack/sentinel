---
phase: 107-mdm-api-integration
plan: 02
type: execute
wave: 2
depends_on: ["107-01"]
files_modified: [mdm/jamf.go, mdm/jamf_test.go]
autonomous: true
---

<objective>
Implement Jamf Pro MDM provider for server-side device posture verification.

Purpose: Enable Lambda TVM to query Jamf Pro API for device compliance status, preventing clients from faking posture claims.
Output: JamfProvider implementing MDM Provider interface with Jamf Pro API integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/CONSTRAINTS.md

# Required - MDM interface from Plan 01:
@.planning/phases/107-mdm-api-integration/107-01-SUMMARY.md

# Reference for HTTP client patterns:
@notification/webhook.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Jamf Pro API client types</name>
  <files>mdm/jamf.go</files>
  <action>
Create JamfProvider implementing Provider interface:

1. JamfProvider struct:
   - httpClient *http.Client
   - baseURL string (Jamf Pro server URL)
   - apiToken string (Bearer token for authentication)
   - timeout time.Duration

2. NewJamfProvider(cfg *MDMConfig) (*JamfProvider, error):
   - Validate required config: BaseURL, APIToken
   - Set default timeout (10s) if not specified
   - Return configured provider

3. Name() returns "jamf"

4. LookupDevice(ctx context.Context, deviceID string) (*MDMDeviceInfo, error):

   Jamf Pro API v1 device lookup strategy:
   - Jamf uses hardware UDID or serial number, not our HMAC-SHA256 device ID
   - For MVP, assume deviceID is stored as "Extension Attribute" in Jamf
   - Search via: GET /api/v1/computers-inventory?filter=extensionAttributes.SentinelDeviceID=={deviceID}

   Alternative (documented limitation):
   - If extension attribute not configured, try matching by serial number
   - GET /api/v1/computers-inventory?filter=hardware.serialNumber=={deviceID}
   - This requires device ID mapping in production (Phase 107.1 enhancement)

   API Response parsing:
   - Check device.general.managed = true (MDM enrolled)
   - Check device.general.managementStatus for compliance
   - Extract device.hardware.osVersion
   - Extract device.general.lastContactTime

   Error handling:
   - 401/403 → ErrMDMAuthFailed
   - 404 or empty results → ErrDeviceNotFound
   - Network/timeout → ErrMDMUnavailable

5. jamfAPI interface for testing:
   ```go
   type jamfAPI interface {
       Do(req *http.Request) (*http.Response, error)
   }
   ```

Follow notification/webhook.go patterns for HTTP client usage. Use context for timeouts.
Document that production deployment requires Jamf Extension Attribute configuration.
  </action>
  <verify>gofmt -l mdm/jamf.go returns empty</verify>
  <done>mdm/jamf.go implements JamfProvider with Jamf Pro API integration</done>
</task>

<task type="auto">
  <name>Task 2: Implement Jamf API response parsing</name>
  <files>mdm/jamf.go</files>
  <action>
Add Jamf API response types and parsing logic:

1. JamfComputerResponse struct matching Jamf Pro API v1 schema:
   ```go
   type JamfComputerResponse struct {
       TotalCount int                 `json:"totalCount"`
       Results    []JamfComputerEntry `json:"results"`
   }

   type JamfComputerEntry struct {
       ID      string              `json:"id"`
       General JamfComputerGeneral `json:"general"`
       Hardware JamfComputerHardware `json:"hardware,omitempty"`
   }

   type JamfComputerGeneral struct {
       Name             string `json:"name"`
       LastContactTime  string `json:"lastContactTime"` // ISO8601
       Managed          bool   `json:"managed"`
       ManagementStatus string `json:"managementStatus"` // "managed", "unmanaged", etc.
   }

   type JamfComputerHardware struct {
       SerialNumber string `json:"serialNumber"`
       OsVersion    string `json:"osVersion"`
   }
   ```

2. parseJamfResponse(body []byte) (*MDMDeviceInfo, error):
   - Unmarshal JSON response
   - Return ErrDeviceNotFound if TotalCount == 0
   - Map first result to MDMDeviceInfo:
     * DeviceID = Results[0].ID
     * Enrolled = Results[0].General.Managed
     * Compliant = (ManagementStatus == "managed" && Managed == true)
     * OSVersion = Results[0].Hardware.OsVersion
     * DeviceName = Results[0].General.Name
     * MDMProvider = "jamf"
     * Parse LastContactTime to time.Time

3. buildJamfRequest(ctx context.Context, deviceID string) (*http.Request, error):
   - Build URL with filter query parameter
   - URL-encode deviceID
   - Set headers: Authorization: Bearer {token}, Accept: application/json
   - Attach context for timeout/cancellation

Handle JSON parsing errors gracefully with ErrMDMUnavailable.
  </action>
  <verify>gofmt -l mdm/jamf.go returns empty</verify>
  <done>Jamf API response types defined and parsing logic implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add Jamf provider tests</name>
  <files>mdm/jamf_test.go</files>
  <action>
Create comprehensive tests with mock HTTP server:

1. TestNewJamfProvider:
   - Valid config creates provider
   - Missing BaseURL returns error
   - Missing APIToken returns error
   - Default timeout applied when not specified

2. TestJamfProvider_LookupDevice_Success:
   - Mock HTTP server returns valid Jamf response
   - MDMDeviceInfo populated correctly
   - Enrolled and Compliant flags set correctly

3. TestJamfProvider_LookupDevice_NotFound:
   - Mock returns empty results (TotalCount: 0)
   - Returns ErrDeviceNotFound

4. TestJamfProvider_LookupDevice_AuthFailed:
   - Mock returns 401
   - Returns ErrMDMAuthFailed

5. TestJamfProvider_LookupDevice_Timeout:
   - Mock delays response beyond timeout
   - Context cancelled, returns ErrMDMUnavailable

6. TestParseJamfResponse:
   - Valid JSON parses correctly
   - Invalid JSON returns error
   - Empty results returns ErrDeviceNotFound
   - Missing fields handled gracefully

Use httptest.NewServer for mock HTTP responses. Follow existing test patterns.
  </action>
  <verify>gofmt -l mdm/jamf_test.go returns empty</verify>
  <done>mdm/jamf_test.go exists with comprehensive test coverage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] gofmt -l mdm/ returns empty
- [ ] mdm/jamf.go compiles without errors
- [ ] mdm/jamf_test.go compiles without errors
- [ ] JamfProvider implements Provider interface
- [ ] Error handling uses sentinel errors from Plan 01
- [ ] HTTP client follows notification/webhook.go patterns
</verification>

<success_criteria>

- All tasks completed
- JamfProvider implements Provider interface
- Jamf Pro API v1 integration working (mocked in tests)
- Error handling covers auth, not found, and unavailable cases
- Production deployment notes documented (Extension Attribute requirement)
</success_criteria>

<output>
After completion, create `.planning/phases/107-mdm-api-integration/107-02-SUMMARY.md`
</output>
