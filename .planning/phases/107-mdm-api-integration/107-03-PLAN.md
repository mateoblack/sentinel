---
phase: 107-mdm-api-integration
plan: 03
type: execute
wave: 3
depends_on: ["107-01", "107-02"]
files_modified: [lambda/config.go, lambda/handler.go, lambda/mdm_integration.go, lambda/mdm_integration_test.go]
autonomous: true
---

<objective>
Integrate MDM provider into Lambda TVM handler for server-verified device posture.

Purpose: Wire MDM provider into credential vending flow so TVM queries MDM for device compliance before issuing credentials.
Output: Lambda handler receives device ID from client, queries MDM, and includes verified posture in policy evaluation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/CONSTRAINTS.md

# Required - MDM interface and Jamf provider:
@.planning/phases/107-mdm-api-integration/107-01-SUMMARY.md
@.planning/phases/107-mdm-api-integration/107-02-SUMMARY.md

# Lambda handler to integrate with:
@lambda/handler.go
@lambda/config.go
@lambda/types.go

# Device types:
@device/types.go
@device/identity.go

# Policy types for device conditions:
@policy/device.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MDM provider to TVMConfig</name>
  <files>lambda/config.go</files>
  <action>
Extend TVMConfig and LoadConfigFromEnv for MDM support:

1. Add to TVMConfig struct:
   ```go
   // MDMProvider queries MDM for device posture verification.
   // If nil, device posture checking is disabled (credentials issued without device verification).
   MDMProvider mdm.Provider

   // RequireDevicePosture when true, rejects credentials if MDM lookup fails.
   // When false (default), MDM failure is logged but credentials are issued.
   RequireDevicePosture bool
   ```

2. Add environment variables:
   ```go
   const (
       EnvMDMProvider     = "SENTINEL_MDM_PROVIDER"     // "jamf", "intune", "kandji", "none"
       EnvMDMBaseURL      = "SENTINEL_MDM_BASE_URL"     // Jamf Pro server URL
       EnvMDMAPIToken     = "SENTINEL_MDM_API_TOKEN"    // Bearer token (from Secrets Manager)
       EnvRequireDevice   = "SENTINEL_REQUIRE_DEVICE"   // "true" to require device verification
   )
   ```

3. Update LoadConfigFromEnv:
   - Parse SENTINEL_MDM_PROVIDER (default: "none")
   - If "jamf": create JamfProvider with BaseURL and APIToken
   - If "intune": log "not yet implemented" warning, use NoopProvider
   - If "kandji": log "not yet implemented" warning, use NoopProvider
   - If "none" or empty: MDMProvider = nil (device checking disabled)
   - Parse SENTINEL_REQUIRE_DEVICE (default: false)

4. Note for production:
   - API tokens should come from AWS Secrets Manager, not environment
   - Document this as Phase 107.1 enhancement
   - For MVP, environment variable token is acceptable (Lambda env encryption)

Follow existing LoadConfigFromEnv patterns for new fields.
  </action>
  <verify>gofmt -l lambda/config.go returns empty</verify>
  <done>TVMConfig extended with MDMProvider, environment loading implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create MDM integration helpers</name>
  <files>lambda/mdm_integration.go</files>
  <action>
Create helpers for MDM integration in handler:

1. extractDeviceID(req events.APIGatewayV2HTTPRequest) string:
   - Extract device_id from query parameter: ?device_id=<64-char-hex>
   - Validate format with device.ValidateDeviceIdentifier()
   - Return empty string if missing or invalid (optional parameter)

2. queryDevicePosture(ctx context.Context, provider mdm.Provider, deviceID string) (*device.DevicePosture, error):
   - Call provider.LookupDevice(ctx, deviceID)
   - Map MDMDeviceInfo to device.DevicePosture:
     * DeviceID = deviceID (the Sentinel device ID we looked up)
     * Status = compliant if MDMDeviceInfo.Compliant, else non_compliant
     * MDMEnrolled = MDMDeviceInfo.Enrolled
     * MDMCompliant = MDMDeviceInfo.Compliant
     * OSVersion = MDMDeviceInfo.OSVersion
     * CollectedAt = time.Now() (when TVM queried)
   - Return nil, error if lookup fails

3. logMDMResult(deviceID string, posture *device.DevicePosture, err error):
   - Log INFO on success with device posture summary
   - Log WARNING on ErrDeviceNotFound (device not in MDM)
   - Log ERROR on ErrMDMUnavailable/ErrMDMAuthFailed

4. MDMResult struct for handler use:
   ```go
   type MDMResult struct {
       DeviceID string
       Posture  *device.DevicePosture // nil if lookup failed
       Error    error                  // nil if successful
       Skipped  bool                   // true if no MDM configured or no device_id provided
   }
   ```

Follow lambda/vend.go patterns for helper function structure.
  </action>
  <verify>gofmt -l lambda/mdm_integration.go returns empty</verify>
  <done>lambda/mdm_integration.go created with device posture query helpers</done>
</task>

<task type="auto">
  <name>Task 3: Wire MDM into handler and add tests</name>
  <files>lambda/handler.go, lambda/mdm_integration_test.go</files>
  <action>
Update Handler.HandleRequest to query MDM:

1. In HandleRequest, after extracting caller identity and profile:
   ```go
   // Extract device ID from request (optional)
   deviceID := extractDeviceID(req)

   // Query MDM for device posture if configured and device ID provided
   var mdmResult *MDMResult
   if h.Config.MDMProvider != nil && deviceID != "" {
       posture, err := queryDevicePosture(ctx, h.Config.MDMProvider, deviceID)
       mdmResult = &MDMResult{
           DeviceID: deviceID,
           Posture:  posture,
           Error:    err,
       }
       logMDMResult(deviceID, posture, err)

       // If RequireDevicePosture and lookup failed, deny
       if h.Config.RequireDevicePosture && err != nil {
           return errorResponse(http.StatusForbidden, "DEVICE_VERIFICATION_FAILED",
               fmt.Sprintf("Device verification failed: %v", err))
       }
   } else if deviceID != "" && h.Config.MDMProvider == nil {
       log.Printf("INFO: Device ID provided but MDM not configured, skipping verification")
       mdmResult = &MDMResult{DeviceID: deviceID, Skipped: true}
   }
   ```

2. Add device posture to policy request (for Phase 108 integration):
   - policyRequest.DevicePosture = mdmResult.Posture (if available)
   - This enables device.DeviceCondition.Matches() in policy evaluation

3. Add device context to decision log:
   - If mdmResult != nil && mdmResult.Posture != nil:
     * credFields.DeviceID = deviceID
     * credFields.DeviceMDMEnrolled = posture.HasMDMEnrollment()
     * credFields.DeviceMDMCompliant = posture.HasMDMCompliance()

4. Create mdm_integration_test.go:
   - TestExtractDeviceID: valid, invalid, missing
   - TestQueryDevicePosture_Success: mock provider returns info
   - TestQueryDevicePosture_NotFound: mock returns ErrDeviceNotFound
   - TestHandler_MDMIntegration: full handler test with mock MDM
   - TestHandler_RequireDevice_Failure: RequireDevicePosture=true, MDM fails â†’ deny

Use existing lambda/*_test.go patterns for handler testing with mock providers.
  </action>
  <verify>gofmt -l lambda/handler.go lambda/mdm_integration.go lambda/mdm_integration_test.go returns empty</verify>
  <done>Handler queries MDM on credential requests, tests verify integration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] gofmt -l lambda/ returns empty
- [ ] lambda/config.go compiles without errors
- [ ] lambda/handler.go compiles without errors
- [ ] lambda/mdm_integration.go compiles without errors
- [ ] lambda/mdm_integration_test.go compiles without errors
- [ ] TVMConfig properly initializes MDM provider from environment
- [ ] Handler extracts device_id and queries MDM provider
- [ ] RequireDevicePosture flag controls fail-open vs fail-closed behavior
</verification>

<success_criteria>

- All tasks completed
- Lambda TVM queries MDM for device posture (server-verified, not client claims)
- Device ID passed as query parameter from CLI
- Fail-open by default (MDM failure logged but credentials issued)
- Optional RequireDevicePosture for fail-closed enforcement
- Device posture available for Phase 108 policy evaluation
- Tests cover success, failure, and configuration cases
</success_criteria>

<output>
After completion, create `.planning/phases/107-mdm-api-integration/107-03-SUMMARY.md`
</output>
