---
phase: 58-security-regression-suite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - policy/security_regression_test.go
  - breakglass/security_regression_test.go
  - request/security_regression_test.go
autonomous: true
---

<objective>
Create security regression tests for credential denial paths.

Purpose: Ensure all credential denial mechanisms (policy deny, expired requests, closed break-glass) remain effective and cannot be bypassed. These tests serve as regression guards against future code changes that might inadvertently weaken security.

Output: Security regression test files covering denial path integrity across policy, break-glass, and request modules.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@policy/evaluate.go
@policy/types.go
@breakglass/checker.go
@breakglass/types.go
@request/checker.go
@request/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Policy denial regression tests</name>
  <files>policy/security_regression_test.go</files>
  <action>
Create security regression tests for policy evaluation denial paths:

1. **Default deny enforcement:**
   - Empty policy returns deny
   - Nil policy returns deny
   - No matching rules returns deny
   - Ensure no code path can return allow without explicit rule match

2. **Rule bypass prevention:**
   - Case-sensitive user matching (user "Admin" must NOT match rule for "admin")
   - Case-sensitive profile matching (profile "Prod" must NOT match rule for "prod")
   - Partial string matching rejection (user "alice" must NOT match if rule specifies "alice@example.com")
   - Empty user/profile in request still evaluates correctly (does not match wildcard)

3. **Time window bypass prevention:**
   - Requests at 1 nanosecond before window start are denied
   - Requests at 1 nanosecond after window end are denied
   - Weekend requests denied when only weekdays allowed (test boundary at midnight)
   - Time zone edge cases (23:59 vs 00:00 boundaries)

4. **Effect isolation:**
   - EffectDeny stops evaluation (first match wins)
   - EffectRequireApproval returns that effect, not EffectAllow
   - Invalid effect strings cannot be injected to produce allow

Use table-driven tests with descriptive names prefixed with "TestSecurityRegression_".
  </action>
  <verify>go test -v ./policy/... -run "TestSecurityRegression" passes all tests</verify>
  <done>Policy denial paths have regression tests ensuring bypasses are impossible</done>
</task>

<task type="auto">
  <name>Task 2: Break-glass denial regression tests</name>
  <files>breakglass/security_regression_test.go</files>
  <action>
Create security regression tests for break-glass denial paths:

1. **Expired event rejection:**
   - Event with Status=Active but ExpiresAt in past is rejected
   - Event at exactly ExpiresAt is rejected (strictly less than)
   - Event with Status=Expired is rejected even if ExpiresAt is future
   - Event with Status=Closed is rejected even if ExpiresAt is future

2. **Rate limit enforcement:**
   - Cooldown enforced at exactly 1 nanosecond before expiry
   - User quota enforced at exactly MaxPerUser (>= check, not >)
   - Profile quota enforced at exactly MaxPerProfile (>= check, not >)
   - Zero quota means no limit (not "deny all")
   - Check order is strictly: cooldown -> user quota -> profile quota -> escalation

3. **Profile/user isolation:**
   - Break-glass for profile "prod" does NOT authorize profile "production"
   - Break-glass by user "alice" does NOT authorize user "alice@company.com"
   - Case-sensitive profile matching enforced

4. **Status manipulation prevention:**
   - Cannot transition Closed -> Active
   - Cannot transition Expired -> Active
   - Invalid status strings are rejected

Use table-driven tests with descriptive names prefixed with "TestSecurityRegression_".
  </action>
  <verify>go test -v ./breakglass/... -run "TestSecurityRegression" passes all tests</verify>
  <done>Break-glass denial paths have regression tests ensuring bypasses are impossible</done>
</task>

<task type="auto">
  <name>Task 3: Request approval denial regression tests</name>
  <files>request/security_regression_test.go</files>
  <action>
Create security regression tests for request approval denial paths:

1. **Status-based denial:**
   - Pending request does NOT grant credentials
   - Denied request does NOT grant credentials (even if expires_at is future)
   - Expired request does NOT grant credentials
   - Cancelled request does NOT grant credentials
   - Only StatusApproved grants credentials

2. **Expiration enforcement:**
   - Request with Status=Approved but ExpiresAt in past is rejected
   - Request at exactly ExpiresAt is rejected (strictly less than)
   - Access window end (CreatedAt + Duration) is strictly enforced
   - Requests cannot extend their own duration

3. **Profile/user isolation:**
   - Approval for profile "staging" does NOT authorize profile "production"
   - Approval for user "bob" does NOT authorize user "bobby"
   - Case-sensitive matching for both profile and user

4. **State transition security:**
   - Cannot transition Approved -> Pending
   - Cannot transition Denied -> Approved without new request
   - Cannot transition Expired -> Approved
   - Self-approval checks (if applicable based on policy)

Use table-driven tests with descriptive names prefixed with "TestSecurityRegression_".
  </action>
  <verify>go test -v ./request/... -run "TestSecurityRegression" passes all tests</verify>
  <done>Request approval denial paths have regression tests ensuring bypasses are impossible</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test -v ./policy/... -run "TestSecurityRegression"` passes
- [ ] `go test -v ./breakglass/... -run "TestSecurityRegression"` passes
- [ ] `go test -v ./request/... -run "TestSecurityRegression"` passes
- [ ] `go test -race ./...` passes (no race conditions in security paths)
- [ ] All denial scenarios documented with clear test names
</verification>

<success_criteria>
- All tasks completed
- Security regression tests cover all credential denial paths
- Tests are clearly named to describe security property being tested
- No existing tests broken
- Tests document security invariants via test names
</success_criteria>

<output>
After completion, create `.planning/phases/58-security-regression-suite/58-01-SUMMARY.md`
</output>
