---
phase: 34-break-glass-policies
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - breakglass/policy.go
  - breakglass/policy_test.go
autonomous: true
---

<objective>
Create break-glass policy types with authorization rules and condition matching.

Purpose: Define policy rules that control who can invoke break-glass and under what conditions, completing the break-glass access control framework.
Output: BreakGlassPolicy type with BreakGlassPolicyRule, validation, and matching functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase patterns to follow
@policy/approval.go
@breakglass/ratelimit.go
@breakglass/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create break-glass policy types with validation</name>
  <files>breakglass/policy.go</files>
  <action>
Create BreakGlassPolicy type following the ApprovalPolicy pattern from policy/approval.go:

1. **BreakGlassPolicy struct** - Top-level container:
   - Version string
   - Rules []BreakGlassPolicyRule

2. **BreakGlassPolicyRule struct** - Who can invoke for which profiles:
   - Name string (rule identifier)
   - Profiles []string (empty = wildcard matches all)
   - Users []string (authorized to invoke break-glass for matching profiles)
   - AllowedReasonCodes []ReasonCode (optional - restrict reason codes, empty = all allowed)
   - Time *TimeWindow (optional - time window when break-glass allowed, nil = any time)
   - MaxDuration time.Duration (optional - cap duration for this rule, 0 = use system default)

3. **Validation methods**:
   - `(p *BreakGlassPolicy) Validate() error` - Validates all rules exist and are valid
   - `(r *BreakGlassPolicyRule) validate(index int) error` - Validates rule has name, at least one user

4. **Import TimeWindow from policy package** - Reuse existing type for time constraints

Pattern notes:
- Follow ApprovalPolicy validation patterns exactly
- Use same error message formatting ("rule at index %d missing name")
- Empty Users list is invalid (someone must be authorized)
- Empty Profiles list = wildcard (rule applies to all profiles)
- Empty AllowedReasonCodes = all reason codes allowed
  </action>
  <verify>go build ./breakglass/... compiles without errors</verify>
  <done>BreakGlassPolicy and BreakGlassPolicyRule types with Validate() methods</done>
</task>

<task type="auto">
  <name>Task 2: Add policy matching and authorization functions</name>
  <files>breakglass/policy.go</files>
  <action>
Add matching and authorization functions following ApprovalPolicy patterns:

1. **FindBreakGlassPolicyRule(policy *BreakGlassPolicy, profile string) *BreakGlassPolicyRule**
   - Returns first rule matching profile (or empty profiles = wildcard)
   - Returns nil if no rule matches or policy is nil
   - Pattern: identical to FindApprovalRule and FindRateLimitRule

2. **CanInvokeBreakGlass(rule *BreakGlassPolicyRule, user string) bool**
   - Returns true if user is in rule.Users list
   - Returns false if rule is nil or user not found
   - Pattern: identical to CanApprove

3. **IsBreakGlassAllowed(rule *BreakGlassPolicyRule, user string, reasonCode ReasonCode, requestTime time.Time, duration time.Duration) bool**
   - Comprehensive check combining all conditions:
     - User must be in rule.Users (via CanInvokeBreakGlass)
     - ReasonCode must be in AllowedReasonCodes (empty = all allowed)
     - requestTime must fall within Time window (nil = any time)
     - duration must be <= MaxDuration (0 = no cap)
   - Returns false if rule is nil

4. **Helper functions**:
   - Use containsOrEmpty from ratelimit.go (already exists)
   - Import matchesTimeWindow from policy package (or duplicate helper)
  </action>
  <verify>go build ./breakglass/... compiles without errors</verify>
  <done>FindBreakGlassPolicyRule, CanInvokeBreakGlass, IsBreakGlassAllowed functions</done>
</task>

<task type="auto">
  <name>Task 3: Comprehensive tests for break-glass policy</name>
  <files>breakglass/policy_test.go</files>
  <action>
Create comprehensive tests following existing test patterns:

1. **Validation tests**:
   - TestBreakGlassPolicyValidate: valid policy, empty rules, missing name, empty users
   - TestBreakGlassPolicyRule_validate: individual rule validation scenarios
   - Test AllowedReasonCodes validation (invalid reason codes)
   - Test MaxDuration validation (negative, exceeds system max)

2. **Matching tests**:
   - TestFindBreakGlassPolicyRule: nil policy, no match, exact match, wildcard match, first-match-wins
   - TestCanInvokeBreakGlass: nil rule, user in list, user not in list
   - TestIsBreakGlassAllowed: comprehensive scenarios
     - User not authorized
     - User authorized, reason code allowed
     - User authorized, reason code not in allowed list
     - Time window restriction (allowed/denied)
     - Duration cap enforcement

3. **Table-driven tests** - Use same patterns as approval_test.go and ratelimit_test.go

Target: 30+ test cases covering all validation and matching scenarios
  </action>
  <verify>go test ./breakglass/... -v -run Policy passes with all tests</verify>
  <done>All policy validation and matching tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./breakglass/... succeeds
- [ ] go test ./breakglass/... -v -run Policy passes
- [ ] No new linter warnings: golangci-lint run ./breakglass/...
</verification>

<success_criteria>

- BreakGlassPolicy type with BreakGlassPolicyRule defined
- Validate() methods on policy and rule
- FindBreakGlassPolicyRule, CanInvokeBreakGlass, IsBreakGlassAllowed functions
- 30+ tests covering validation and matching
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/34-break-glass-policies/34-01-SUMMARY.md`
</output>
