---
phase: 97-foundation
plan: 02
type: execute
wave: 2
depends_on: ["97-01"]
files_modified: [cmd/lambda-tvm/main.go, lambda/handler.go, lambda/handler_test.go, lambda/types_test.go]
autonomous: true
---

<objective>
Implement Lambda handler with API Gateway request parsing and credential response formatting.

Purpose: Create the executable Lambda entry point that parses requests and returns credentials in the correct format. Actual STS AssumeRole will be added in Phase 98.
Output: Working Lambda handler binary with unit tests for request parsing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/97-foundation/97-01-SUMMARY.md
@sentinel/server.go
@lambda/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Lambda handler</name>
  <files>lambda/handler.go, cmd/lambda-tvm/main.go</files>
  <action>
1. Create `lambda/handler.go` with the core handler logic:

```go
// Package lambda provides the Lambda handler for the Token Vending Machine (TVM).
package lambda

import (
    "context"
    "encoding/json"
    "fmt"
    "net/http"
    "time"

    "github.com/aws/aws-lambda-go/events"
)

// Handler handles API Gateway v2 HTTP requests for credential vending.
type Handler struct {
    // CredentialProvider will be added in Phase 98 for actual STS calls
    // For now, returns mock credentials for testing
}

// NewHandler creates a new TVM handler.
func NewHandler() *Handler {
    return &Handler{}
}

// HandleRequest processes an API Gateway v2 HTTP request.
// Returns credentials in AWS container credentials format.
func (h *Handler) HandleRequest(ctx context.Context, req events.APIGatewayV2HTTPRequest) (events.APIGatewayV2HTTPResponse, error) {
    // Extract caller identity from IAM authorizer context
    caller, err := ExtractCallerIdentity(req)
    if err != nil {
        return errorResponse(http.StatusForbidden, "IAM_AUTH_REQUIRED",
            fmt.Sprintf("IAM authorization required: %v", err))
    }

    // Parse request body for profile (optional query param: ?profile=xxx)
    profile := req.QueryStringParameters["profile"]
    if profile == "" {
        return errorResponse(http.StatusBadRequest, "MISSING_PROFILE",
            "Missing required 'profile' query parameter")
    }

    // TODO: Phase 98 will add actual STS AssumeRole call
    // For now, return mock response to validate request/response format
    _ = caller // Will be used for SourceIdentity in Phase 98

    // Return mock credentials (validates response format works with AWS SDKs)
    mockResponse := &TVMResponse{
        AccessKeyId:     "MOCK_ACCESS_KEY_ID",
        SecretAccessKey: "MOCK_SECRET_ACCESS_KEY",
        Token:           "MOCK_SESSION_TOKEN",
        Expiration:      time.Now().Add(15 * time.Minute).UTC().Format(time.RFC3339),
    }

    return successResponse(mockResponse)
}

// successResponse creates a successful credential response.
func successResponse(creds *TVMResponse) (events.APIGatewayV2HTTPResponse, error) {
    body, err := json.Marshal(creds)
    if err != nil {
        return errorResponse(http.StatusInternalServerError, "MARSHAL_ERROR",
            fmt.Sprintf("Failed to marshal credentials: %v", err))
    }

    return events.APIGatewayV2HTTPResponse{
        StatusCode: http.StatusOK,
        Headers: map[string]string{
            "Content-Type": "application/json; charset=utf-8",
        },
        Body: string(body),
    }, nil
}

// errorResponse creates an error response.
func errorResponse(statusCode int, code, message string) (events.APIGatewayV2HTTPResponse, error) {
    errResp := &TVMError{
        Code:    code,
        Message: message,
    }
    body, _ := json.Marshal(errResp)

    return events.APIGatewayV2HTTPResponse{
        StatusCode: statusCode,
        Headers: map[string]string{
            "Content-Type": "application/json; charset=utf-8",
        },
        Body: string(body),
    }, nil
}
```

2. Create `cmd/lambda-tvm/main.go`:

```go
// Package main is the entry point for the Lambda TVM.
package main

import (
    "github.com/aws/aws-lambda-go/lambda"
    tvmhandler "github.com/byteness/aws-vault/v7/lambda"
)

// Version is set at build time via ldflags
var Version = "dev"

func main() {
    handler := tvmhandler.NewHandler()
    lambda.Start(handler.HandleRequest)
}
```

Note: Using tvmhandler alias to avoid conflict with github.com/aws/aws-lambda-go/lambda package name.
  </action>
  <verify>
  - `go build ./cmd/lambda-tvm/` compiles successfully
  - `go build ./lambda/` compiles successfully
  </verify>
  <done>
  - lambda/handler.go exists with HandleRequest function
  - cmd/lambda-tvm/main.go exists as Lambda entry point
  - Both compile without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for request parsing and response formatting</name>
  <files>lambda/types_test.go, lambda/handler_test.go</files>
  <action>
1. Create `lambda/types_test.go` to test ExtractCallerIdentity:

```go
package lambda

import (
    "testing"

    "github.com/aws/aws-lambda-go/events"
)

func TestExtractCallerIdentity(t *testing.T) {
    tests := []struct {
        name    string
        req     events.APIGatewayV2HTTPRequest
        want    *CallerIdentity
        wantErr bool
    }{
        {
            name: "valid IAM context",
            req: events.APIGatewayV2HTTPRequest{
                RequestContext: events.APIGatewayV2HTTPRequestContext{
                    Authorizer: &events.APIGatewayV2HTTPRequestContextAuthorizerDescription{
                        IAM: &events.APIGatewayV2HTTPRequestContextAuthorizerIAMDescription{
                            AccountID: "123456789012",
                            UserARN:   "arn:aws:iam::123456789012:user/testuser",
                            UserID:    "AIDAEXAMPLE",
                            AccessKey: "AKIAEXAMPLE",
                        },
                    },
                },
            },
            want: &CallerIdentity{
                AccountID: "123456789012",
                UserARN:   "arn:aws:iam::123456789012:user/testuser",
                UserID:    "AIDAEXAMPLE",
                AccessKey: "AKIAEXAMPLE",
            },
            wantErr: false,
        },
        {
            name: "missing IAM authorizer",
            req: events.APIGatewayV2HTTPRequest{
                RequestContext: events.APIGatewayV2HTTPRequestContext{
                    Authorizer: nil,
                },
            },
            want:    nil,
            wantErr: true,
        },
        {
            name: "nil IAM field",
            req: events.APIGatewayV2HTTPRequest{
                RequestContext: events.APIGatewayV2HTTPRequestContext{
                    Authorizer: &events.APIGatewayV2HTTPRequestContextAuthorizerDescription{
                        IAM: nil,
                    },
                },
            },
            want:    nil,
            wantErr: true,
        },
        {
            name: "missing required AccountID",
            req: events.APIGatewayV2HTTPRequest{
                RequestContext: events.APIGatewayV2HTTPRequestContext{
                    Authorizer: &events.APIGatewayV2HTTPRequestContextAuthorizerDescription{
                        IAM: &events.APIGatewayV2HTTPRequestContextAuthorizerIAMDescription{
                            UserARN: "arn:aws:iam::123456789012:user/testuser",
                        },
                    },
                },
            },
            want:    nil,
            wantErr: true,
        },
        {
            name: "with PrincipalOrgID",
            req: events.APIGatewayV2HTTPRequest{
                RequestContext: events.APIGatewayV2HTTPRequestContext{
                    Authorizer: &events.APIGatewayV2HTTPRequestContextAuthorizerDescription{
                        IAM: &events.APIGatewayV2HTTPRequestContextAuthorizerIAMDescription{
                            AccountID:      "123456789012",
                            UserARN:        "arn:aws:iam::123456789012:user/testuser",
                            UserID:         "AIDAEXAMPLE",
                            PrincipalOrgID: "o-exampleorgid",
                        },
                    },
                },
            },
            want: &CallerIdentity{
                AccountID:      "123456789012",
                UserARN:        "arn:aws:iam::123456789012:user/testuser",
                UserID:         "AIDAEXAMPLE",
                PrincipalOrgID: "o-exampleorgid",
            },
            wantErr: false,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := ExtractCallerIdentity(tt.req)
            if (err != nil) != tt.wantErr {
                t.Errorf("ExtractCallerIdentity() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if tt.wantErr {
                return
            }
            if got.AccountID != tt.want.AccountID ||
                got.UserARN != tt.want.UserARN ||
                got.UserID != tt.want.UserID ||
                got.AccessKey != tt.want.AccessKey ||
                got.PrincipalOrgID != tt.want.PrincipalOrgID {
                t.Errorf("ExtractCallerIdentity() = %+v, want %+v", got, tt.want)
            }
        })
    }
}
```

2. Create `lambda/handler_test.go` to test the handler:

```go
package lambda

import (
    "context"
    "encoding/json"
    "net/http"
    "testing"
    "time"

    "github.com/aws/aws-lambda-go/events"
)

func TestHandler_HandleRequest(t *testing.T) {
    handler := NewHandler()
    ctx := context.Background()

    tests := []struct {
        name           string
        req            events.APIGatewayV2HTTPRequest
        wantStatusCode int
        wantErrorCode  string
    }{
        {
            name: "successful request",
            req: events.APIGatewayV2HTTPRequest{
                QueryStringParameters: map[string]string{
                    "profile": "prod",
                },
                RequestContext: events.APIGatewayV2HTTPRequestContext{
                    Authorizer: &events.APIGatewayV2HTTPRequestContextAuthorizerDescription{
                        IAM: &events.APIGatewayV2HTTPRequestContextAuthorizerIAMDescription{
                            AccountID: "123456789012",
                            UserARN:   "arn:aws:iam::123456789012:user/testuser",
                            UserID:    "AIDAEXAMPLE",
                        },
                    },
                },
            },
            wantStatusCode: http.StatusOK,
        },
        {
            name: "missing IAM auth",
            req: events.APIGatewayV2HTTPRequest{
                QueryStringParameters: map[string]string{
                    "profile": "prod",
                },
                RequestContext: events.APIGatewayV2HTTPRequestContext{
                    Authorizer: nil,
                },
            },
            wantStatusCode: http.StatusForbidden,
            wantErrorCode:  "IAM_AUTH_REQUIRED",
        },
        {
            name: "missing profile parameter",
            req: events.APIGatewayV2HTTPRequest{
                QueryStringParameters: map[string]string{},
                RequestContext: events.APIGatewayV2HTTPRequestContext{
                    Authorizer: &events.APIGatewayV2HTTPRequestContextAuthorizerDescription{
                        IAM: &events.APIGatewayV2HTTPRequestContextAuthorizerIAMDescription{
                            AccountID: "123456789012",
                            UserARN:   "arn:aws:iam::123456789012:user/testuser",
                        },
                    },
                },
            },
            wantStatusCode: http.StatusBadRequest,
            wantErrorCode:  "MISSING_PROFILE",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            resp, err := handler.HandleRequest(ctx, tt.req)
            if err != nil {
                t.Fatalf("HandleRequest() unexpected error: %v", err)
            }
            if resp.StatusCode != tt.wantStatusCode {
                t.Errorf("HandleRequest() statusCode = %d, want %d", resp.StatusCode, tt.wantStatusCode)
            }

            if tt.wantErrorCode != "" {
                var errResp TVMError
                if err := json.Unmarshal([]byte(resp.Body), &errResp); err != nil {
                    t.Fatalf("Failed to unmarshal error response: %v", err)
                }
                if errResp.Code != tt.wantErrorCode {
                    t.Errorf("HandleRequest() error code = %s, want %s", errResp.Code, tt.wantErrorCode)
                }
            }

            if tt.wantStatusCode == http.StatusOK {
                var creds TVMResponse
                if err := json.Unmarshal([]byte(resp.Body), &creds); err != nil {
                    t.Fatalf("Failed to unmarshal credentials response: %v", err)
                }
                // Verify response has required fields
                if creds.AccessKeyId == "" {
                    t.Error("AccessKeyId should not be empty")
                }
                if creds.SecretAccessKey == "" {
                    t.Error("SecretAccessKey should not be empty")
                }
                if creds.Token == "" {
                    t.Error("Token should not be empty")
                }
                if creds.Expiration == "" {
                    t.Error("Expiration should not be empty")
                }
                // Verify expiration is valid RFC3339
                _, err := time.Parse(time.RFC3339, creds.Expiration)
                if err != nil {
                    t.Errorf("Expiration should be RFC3339 format: %v", err)
                }
            }
        })
    }
}

func TestCredentialResponseFormat(t *testing.T) {
    // Test that credential response matches AWS container credentials format
    handler := NewHandler()
    ctx := context.Background()

    req := events.APIGatewayV2HTTPRequest{
        QueryStringParameters: map[string]string{
            "profile": "test-profile",
        },
        RequestContext: events.APIGatewayV2HTTPRequestContext{
            Authorizer: &events.APIGatewayV2HTTPRequestContextAuthorizerDescription{
                IAM: &events.APIGatewayV2HTTPRequestContextAuthorizerIAMDescription{
                    AccountID: "123456789012",
                    UserARN:   "arn:aws:iam::123456789012:user/testuser",
                },
            },
        },
    }

    resp, err := handler.HandleRequest(ctx, req)
    if err != nil {
        t.Fatalf("HandleRequest() error: %v", err)
    }

    // Verify Content-Type header
    if resp.Headers["Content-Type"] != "application/json; charset=utf-8" {
        t.Errorf("Content-Type = %s, want application/json; charset=utf-8", resp.Headers["Content-Type"])
    }

    // Verify JSON field names match AWS SDK expectations exactly
    var raw map[string]interface{}
    if err := json.Unmarshal([]byte(resp.Body), &raw); err != nil {
        t.Fatalf("Failed to unmarshal response: %v", err)
    }

    // AWS SDKs expect these exact field names (case-sensitive)
    requiredFields := []string{"AccessKeyId", "SecretAccessKey", "Token", "Expiration"}
    for _, field := range requiredFields {
        if _, ok := raw[field]; !ok {
            t.Errorf("Missing required field: %s", field)
        }
    }
}
```
  </action>
  <verify>
  - `go test ./lambda/...` passes all tests
  - `go test -v ./lambda/...` shows test cases running
  </verify>
  <done>
  - lambda/types_test.go exists with ExtractCallerIdentity tests
  - lambda/handler_test.go exists with handler tests
  - All tests pass
  - Credential response format validated against AWS SDK expectations
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify Lambda binary builds</name>
  <files>None (validation only)</files>
  <action>
Build the Lambda binary to verify the entire pipeline works:

```bash
make lambda-tvm-linux-amd64
```

Verify:
1. Binary is created at `./lambda-tvm-linux-amd64`
2. Binary is a Linux ELF executable
3. File size is reasonable (should be a few MB)

Clean up after verification:
```bash
rm ./lambda-tvm-linux-amd64
```
  </action>
  <verify>
  - `make lambda-tvm-linux-amd64` succeeds
  - `file lambda-tvm-linux-amd64` shows "ELF 64-bit LSB executable"
  </verify>
  <done>
  - Lambda binary builds successfully
  - Binary is valid Linux amd64 executable
  - Build pipeline is complete
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./lambda/...` passes
- [ ] `make lambda-tvm-linux-amd64` succeeds
- [ ] `go build ./cmd/lambda-tvm/` compiles
- [ ] Handler returns credentials in AWS container credentials format
</verification>

<success_criteria>

- Lambda handler parses API Gateway v2 HTTP request
- Handler extracts IAM caller identity from authorizer context
- Handler returns credentials in AWS container credentials format (AccessKeyId, SecretAccessKey, Token, Expiration)
- Unit tests verify request parsing logic
- Lambda binary builds for Linux amd64
</success_criteria>

<output>
After completion, create `.planning/phases/97-foundation/97-02-SUMMARY.md`
</output>
