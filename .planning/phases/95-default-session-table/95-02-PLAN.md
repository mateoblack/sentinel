---
phase: 95-default-session-table
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [policy/evaluate.go, policy/evaluate_test.go, cli/sentinel_exec.go, cli/sentinel_exec_test.go]
autonomous: true
---

<objective>
Enable policy rules to specify session_table name that overrides CLI/env configuration.

Purpose: Allow policies to enforce specific session tables per profile, enabling multi-table architectures.
Output: SessionTableName returned from policy evaluation when rule specifies session_table field.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/94-require-server-session/94-01-SUMMARY.md

@policy/types.go
@policy/evaluate.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Return SessionTableName from policy evaluation when rule specifies session_table</name>
  <files>policy/evaluate.go</files>
  <action>
  Modify the Evaluate function to populate Decision.SessionTableName from the matched rule's SessionTable field.

  In the Evaluate function, after setting other decision fields from the matched rule (~line 60-80):
  1. Add: `decision.SessionTableName = rule.SessionTable`
  2. This applies to all effects, but is most relevant for require_server_session

  The SessionTable field was added to Rule in 94-01 (policy/types.go line 29).
  The SessionTableName field already exists on Decision struct.

  This enables policy-specified session tables:
  ```yaml
  policies:
    - match:
        profile: prod
      effect: require_server_session
      session_table: prod-sentinel-sessions  # Policy can specify table
  ```

  The CLI will use this value to override the --session-table/SENTINEL_SESSION_TABLE value.
  </action>
  <verify>go build ./policy/... succeeds</verify>
  <done>Decision.SessionTableName populated from matched rule's SessionTable field</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for policy session_table field propagation</name>
  <files>policy/evaluate_test.go</files>
  <action>
  Add test cases to verify SessionTableName propagation in evaluate_test.go.

  Test cases to add in TestEvaluate or new TestEvaluate_SessionTablePropagation:

  1. Test require_server_session with session_table specified:
     - Rule: effect=require_server_session, session_table="policy-table"
     - Request: Mode=ModeServer, SessionTableName="cli-table"
     - Verify: Decision.SessionTableName == "policy-table"

  2. Test require_server_session without session_table:
     - Rule: effect=require_server_session, session_table="" (empty)
     - Verify: Decision.SessionTableName == "" (empty, CLI value used)

  3. Test allow effect with session_table:
     - Rule: effect=allow, session_table="audit-table"
     - Verify: Decision.SessionTableName == "audit-table" (session_table can be used with any effect)

  Follow existing test patterns in the file.
  </action>
  <verify>go test ./policy/... -run TestEvaluate -v passes</verify>
  <done>Tests verify SessionTableName propagated from rule to decision for all effects</done>
</task>

<task type="auto">
  <name>Task 3: Use policy-specified session table in exec command</name>
  <files>cli/sentinel_exec.go</files>
  <action>
  After policy evaluation, check if the decision specifies a session table and override the CLI/env value.

  In SentinelExecCommand, after the policy evaluation returns a decision (~line 200-220):
  1. If decision.SessionTableName is not empty AND input.StartServer is true:
     - Override input.SessionTableName with decision.SessionTableName
     - Log: `log.Printf("Using session table from policy: %s", decision.SessionTableName)`
  2. This happens AFTER the initial env var lookup (from 95-01) but BEFORE server startup

  Precedence order (highest to lowest):
  1. Policy session_table field (from matched rule)
  2. --session-table CLI flag
  3. SENTINEL_SESSION_TABLE env var
  4. Empty (no session tracking)

  Note: Policy can OVERRIDE CLI flag because policy is the source of truth for security requirements.
  If policy says "use this table", the policy wins.
  </action>
  <verify>go build ./cli/... succeeds</verify>
  <done>Policy-specified session_table overrides CLI/env values in server mode</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./... succeeds without errors
- [ ] go test ./policy/... -run TestEvaluate -v passes
- [ ] go vet ./... reports no issues
</verification>

<success_criteria>
- All tasks completed
- Decision.SessionTableName populated from matched rule
- Policy session_table field overrides CLI/env values
- Tests cover propagation for different effects
</success_criteria>

<output>
After completion, create `.planning/phases/95-default-session-table/95-02-SUMMARY.md`
</output>
