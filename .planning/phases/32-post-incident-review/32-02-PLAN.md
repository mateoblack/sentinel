---
phase: 32-post-incident-review
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [cli/breakglass_close.go, cli/breakglass_close_test.go]
autonomous: true
---

<objective>
Implement CLI command to close active break-glass events as part of post-incident review workflow.

Purpose: Enable invokers and security teams to close break-glass events early with documented reason, triggering notifications and audit logging.
Output: `sentinel breakglass-close` command that transitions events from active to closed state.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior summaries for break-glass and notification context
@.planning/phases/27-break-glass-schema/27-01-SUMMARY.md
@.planning/phases/28-break-glass-command/28-02-SUMMARY.md
@.planning/phases/29-elevated-audit/29-01-SUMMARY.md
@.planning/phases/31-notification-blast/31-02-SUMMARY.md

# Pattern references
@cli/approve.go
@cli/deny.go
@breakglass/types.go
@breakglass/validate.go
@breakglass/store.go
@notification/breakglass_notifier.go
@notification/breakglass_types.go
@logging/breakglass.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create breakglass-close CLI command</name>
  <files>cli/breakglass_close.go, cli/breakglass_close_test.go</files>
  <action>
Create `sentinel breakglass-close` command following cli/approve.go pattern for state transition.

**Input struct (BreakGlassCloseCommandInput):**
- EventID string (required argument)
- Reason string (required flag - why closing early)
- BreakGlassTable string (required flag)
- Region string (optional)
- Store breakglass.Store (optional, for testing)
- Notifier notification.BreakGlassNotifier (optional, for notifications)
- Logger logging.Logger (optional, for audit logging)

**Output struct (BreakGlassCloseCommandOutput):**
- ID string `json:"id"`
- Profile string `json:"profile"`
- Status string `json:"status"`
- ClosedBy string `json:"closed_by"`
- ClosedReason string `json:"closed_reason"`
- UpdatedAt time.Time `json:"updated_at"`

**Logic:**
1. Validate event ID format using breakglass.ValidateBreakGlassID()
2. Validate reason is non-empty (required for audit trail)
3. Get current user as closer identity
4. Create or use provided Store
5. Fetch event using store.Get(), handle ErrEventNotFound
6. Check transition validity: event.CanTransitionTo(StatusClosed)
7. Update event fields:
   - Status = breakglass.StatusClosed
   - ClosedBy = current user
   - ClosedReason = input reason
   - UpdatedAt = time.Now()
8. Call store.Update(), handle ErrConcurrentModification
9. If Logger provided: log break-glass close event
   - Use logging.NewBreakGlassLogEntry(logging.BreakGlassEventClosed, event)
   - Call Logger.LogBreakGlass(entry)
10. If Notifier provided (best-effort, errors logged but don't fail):
    - Create notification.BreakGlassEvent with EventBreakGlassClosed type
    - Actor = closer username
    - Call Notifier.NotifyBreakGlass()
11. Output success JSON

**ConfigureBreakGlassCloseCommand:**
- Register as "breakglass-close" subcommand
- Arg: event-id (required)
- Flags: --reason (required), --breakglass-table (required), --region

**Tests (cli/breakglass_close_test.go):**
- Create mockBreakGlassStore implementing breakglass.Store (or extend existing mock if present)
- Test cases:
  - Successful close of active event
  - Event not found
  - Invalid event ID format
  - Invalid state transition (already closed)
  - Invalid state transition (expired)
  - Concurrent modification error
  - Missing reason (validation error)
  - With Logger (verify LogBreakGlass called)
  - With Notifier (verify NotifyBreakGlass called)
  - Notifier error doesn't fail command (best-effort)
  </action>
  <verify>go test ./cli/... -run TestBreakGlassClose -v passes</verify>
  <done>breakglass-close command transitions active events to closed with logging and notifications</done>
</task>

<task type="auto">
  <name>Task 2: Wire commands into sentinel CLI</name>
  <files>cli/sentinel.go</files>
  <action>
Register all three break-glass review commands in the Sentinel CLI application.

**In ConfigureSentinelCommands (or equivalent):**
1. Add ConfigureBreakGlassListCommand(app, s)
2. Add ConfigureBreakGlassCheckCommand(app, s)
3. Add ConfigureBreakGlassCloseCommand(app, s)

Verify the commands appear in CLI help output.

**Note:** If commands are auto-registered via the Configure* pattern already used by breakglass.go, this may just be verification. Check how cli/breakglass.go is wired in.
  </action>
  <verify>go build ./... && ./sentinel --help shows breakglass-list, breakglass-check, breakglass-close</verify>
  <done>All three break-glass review commands available in sentinel CLI</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./cli/... -run TestBreakGlassClose -v` passes all tests
- [ ] `./sentinel --help` shows breakglass-list, breakglass-check, breakglass-close commands
- [ ] Commands follow existing CLI patterns for consistency
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- breakglass-close transitions active â†’ closed with audit trail
- Notifications fire on close (best-effort)
- Logger records close events
- All break-glass review commands registered in CLI
</success_criteria>

<output>
After completion, create `.planning/phases/32-post-incident-review/32-02-SUMMARY.md`
</output>
