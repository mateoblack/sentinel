---
phase: 25-approval-policies
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified: [policy/approval.go, policy/approval_test.go]
autonomous: true
---

<objective>
Add validation and evaluation logic for approval policies.

Purpose: Enable validation of approval policy structure and evaluation of who can approve requests.
Output: Validate methods for approval types, CanApprove and ShouldAutoApprove functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/25-approval-policies/25-01-SUMMARY.md

@policy/types.go
@policy/validate.go
@policy/evaluate.go
@policy/approval.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ApprovalPolicy validation</name>
  <files>policy/approval.go</files>
  <action>
Add Validate methods following existing validation patterns in policy/validate.go.

Methods to add:

1. `func (p *ApprovalPolicy) Validate() error` - validate entire policy
   - At least one rule required
   - Each rule must be valid

2. `func (r *ApprovalRule) validate(index int) error` - validate individual rule
   - Name required
   - At least one profile OR empty (wildcard)
   - At least one approver required
   - If AutoApprove set, validate it

3. `func (a *AutoApproveCondition) validate(ruleName string) error` - validate auto-approve
   - At least one condition required (users, time, or max_duration)
   - If Time set, validate using existing TimeWindow.validate()
   - If MaxDuration set, must be positive and <= request.MaxDuration (8h)

Error messages should follow existing pattern: include rule name/index for context.

Example:
```go
func (p *ApprovalPolicy) Validate() error {
    if len(p.Rules) == 0 {
        return fmt.Errorf("approval policy must have at least one rule")
    }
    for i, rule := range p.Rules {
        if err := rule.validate(i); err != nil {
            return err
        }
    }
    return nil
}
```
  </action>
  <verify>go build ./... succeeds</verify>
  <done>Validate methods exist for ApprovalPolicy, ApprovalRule, AutoApproveCondition</done>
</task>

<task type="auto">
  <name>Task 2: Add approval evaluation functions</name>
  <files>policy/approval.go</files>
  <action>
Add evaluation functions for approval policies.

Functions to add:

1. `func FindApprovalRule(policy *ApprovalPolicy, profile string) *ApprovalRule`
   - Returns the first rule matching the profile
   - Empty profiles list in rule = wildcard (matches any profile)
   - Returns nil if no rule matches

2. `func CanApprove(rule *ApprovalRule, approver string) bool`
   - Returns true if approver is in the rule's Approvers list
   - Returns false if rule is nil

3. `func ShouldAutoApprove(rule *ApprovalRule, requester string, requestTime time.Time, duration time.Duration) bool`
   - Returns true if all auto-approve conditions match:
     - rule.AutoApprove is not nil
     - requester is in AutoApprove.Users (or Users is empty = any user)
     - requestTime matches AutoApprove.Time window (or Time is nil = any time)
     - duration <= AutoApprove.MaxDuration (or MaxDuration is 0 = no cap)
   - Returns false if any condition fails or AutoApprove is nil

4. `func GetApprovers(policy *ApprovalPolicy, profile string) []string`
   - Convenience function to get approvers list for a profile
   - Returns nil if no matching rule

Use existing matchesTimeWindow from evaluate.go for time matching (may need to reuse or call it).

Example:
```go
func FindApprovalRule(policy *ApprovalPolicy, profile string) *ApprovalRule {
    if policy == nil {
        return nil
    }
    for i := range policy.Rules {
        rule := &policy.Rules[i]
        if containsOrEmpty(rule.Profiles, profile) {
            return rule
        }
    }
    return nil
}
```
  </action>
  <verify>go build ./... succeeds</verify>
  <done>FindApprovalRule, CanApprove, ShouldAutoApprove, GetApprovers functions implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for approval policy logic</name>
  <files>policy/approval_test.go</files>
  <action>
Create comprehensive tests for approval policy validation and evaluation.

Test cases for validation:
- Empty policy fails validation
- Rule without name fails
- Rule without approvers fails
- AutoApprove with no conditions fails
- AutoApprove with invalid time window fails
- AutoApprove with MaxDuration > 8h fails
- Valid policy passes validation

Test cases for FindApprovalRule:
- Returns nil for nil policy
- Returns nil when no rule matches profile
- Returns first matching rule
- Wildcard rule (empty profiles) matches any profile

Test cases for CanApprove:
- Returns false for nil rule
- Returns true when approver in list
- Returns false when approver not in list

Test cases for ShouldAutoApprove:
- Returns false when AutoApprove is nil
- Returns true when all conditions match
- Returns false when user not in list
- Returns false when outside time window
- Returns false when duration exceeds MaxDuration
- Empty Users list means any user can auto-approve
- MaxDuration 0 means no cap

Use table-driven tests following Go conventions.
  </action>
  <verify>go test ./policy/... -v passes</verify>
  <done>All test cases pass, coverage includes validation and evaluation functions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./policy/...` passes
- [ ] `go vet ./...` passes
- [ ] All evaluation functions handle nil inputs safely
</verification>

<success_criteria>

- All tasks completed
- Validation catches invalid approval policies
- Evaluation functions correctly match profiles, approvers, and auto-approve conditions
- Unit tests cover all edge cases
- No build errors or test failures
  </success_criteria>

<output>
After completion, create `.planning/phases/25-approval-policies/25-02-SUMMARY.md`
</output>
