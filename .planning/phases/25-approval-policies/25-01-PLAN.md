---
phase: 25-approval-policies
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [policy/types.go, policy/approval.go]
autonomous: true
---

<objective>
Define approval policy schema extending existing policy types.

Purpose: Enable policy rules to specify which profiles require approval and who can approve them.
Output: New Effect constant (`require_approval`) and ApprovalPolicy types for approval routing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@policy/types.go
@policy/validate.go
@request/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add require_approval Effect constant</name>
  <files>policy/types.go</files>
  <action>
Add a new Effect constant `EffectRequireApproval` with value "require_approval" to the existing Effect type.

Update the `IsValid()` method to include the new constant.

This effect means: when a rule matches with this effect, the request needs approval workflow instead of direct credential issuance.

Follow existing pattern:
```go
const (
    EffectAllow Effect = "allow"
    EffectDeny Effect = "deny"
    EffectRequireApproval Effect = "require_approval"
)
```

Update IsValid:
```go
func (e Effect) IsValid() bool {
    return e == EffectAllow || e == EffectDeny || e == EffectRequireApproval
}
```
  </action>
  <verify>go build ./... succeeds</verify>
  <done>EffectRequireApproval constant exists and IsValid() returns true for it</done>
</task>

<task type="auto">
  <name>Task 2: Create ApprovalPolicy types</name>
  <files>policy/approval.go</files>
  <action>
Create `policy/approval.go` with types for approval policies.

ApprovalPolicy defines:
1. Which profiles require approval (handled by rules with `require_approval` effect)
2. Who can approve requests for specific profiles
3. Auto-approve conditions (when approval can be granted automatically)

Types to create:

```go
// ApprovalPolicy defines approval routing and auto-approve rules.
type ApprovalPolicy struct {
    Version string           `yaml:"version" json:"version"`
    Rules   []ApprovalRule   `yaml:"rules" json:"rules"`
}

// ApprovalRule defines who can approve requests for matching profiles.
type ApprovalRule struct {
    Name       string           `yaml:"name" json:"name"`
    Profiles   []string         `yaml:"profiles,omitempty" json:"profiles,omitempty"`
    Approvers  []string         `yaml:"approvers" json:"approvers"`
    AutoApprove *AutoApproveCondition `yaml:"auto_approve,omitempty" json:"auto_approve,omitempty"`
}

// AutoApproveCondition defines when requests can be auto-approved.
// If conditions match, the request is automatically approved without
// requiring an explicit approver action.
type AutoApproveCondition struct {
    // Users who can self-approve (empty = no self-approval)
    Users []string `yaml:"users,omitempty" json:"users,omitempty"`
    // Time window when auto-approve is allowed (nil = any time)
    Time *TimeWindow `yaml:"time,omitempty" json:"time,omitempty"`
    // MaxDuration caps auto-approved request duration (0 = no cap)
    MaxDuration time.Duration `yaml:"max_duration,omitempty" json:"max_duration,omitempty"`
}
```

Include package doc comment explaining the approval workflow:
- Access policy rules determine if profile needs approval (effect: require_approval)
- Approval policy rules determine who can approve and auto-approve conditions
- Separation allows access policy to be simple (allow/deny/require_approval) while
  approval routing can be complex (different approvers per profile, time-based auto-approve)

Import time package for Duration.
  </action>
  <verify>go build ./... succeeds</verify>
  <done>ApprovalPolicy, ApprovalRule, and AutoApproveCondition types defined with YAML/JSON tags</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go vet ./...` passes
- [ ] EffectRequireApproval constant is accessible from policy package
- [ ] ApprovalPolicy types are accessible from policy package
</verification>

<success_criteria>

- All tasks completed
- EffectRequireApproval extends Effect type
- ApprovalPolicy, ApprovalRule, AutoApproveCondition types defined
- All types have YAML and JSON struct tags
- No build errors or warnings
  </success_criteria>

<output>
After completion, create `.planning/phases/25-approval-policies/25-01-SUMMARY.md`
</output>
