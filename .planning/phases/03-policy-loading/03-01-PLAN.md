---
phase: 03-policy-loading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [policy/loader.go, policy/loader_test.go, go.mod]
autonomous: true
---

<objective>
Create SSM Parameter Store client and policy loader that fetches policy documents from AWS.

Purpose: Enable sentinel to load policies from a centralized, IAM-protected parameter store.
Output: Loader type that fetches and parses policies from SSM parameters.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-policy-loading/03-RESEARCH.md

# Phase 2 provides ParsePolicy function we'll use
@policy/parse.go
@policy/types.go

# AWS SDK patterns from existing codebase
@vault/vault.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SSM dependency and create Loader type</name>
  <files>go.mod, policy/loader.go</files>
  <action>
1. Add SSM dependency:
   ```
   go get github.com/aws/aws-sdk-go-v2/service/ssm
   ```

2. Create policy/loader.go with:
   - Package comment explaining SSM policy loading
   - Import: context, errors, fmt, aws, ssm, ssm/types
   - ErrPolicyNotFound sentinel error (var ErrPolicyNotFound = errors.New("policy not found"))
   - Loader struct with ssm.Client field
   - NewLoader(cfg aws.Config) *Loader function that creates SSM client using ssm.NewFromConfig(cfg)

Follow vault/vault.go pattern for client creation (line 58: sts.NewFromConfig(cfg)).
Do NOT use config.LoadDefaultConfig here - caller provides aws.Config.
  </action>
  <verify>go build ./policy/... compiles without errors</verify>
  <done>Loader type exists with NewLoader constructor, SSM dependency added to go.mod</done>
</task>

<task type="auto">
  <name>Task 2: Implement Load method with error handling</name>
  <files>policy/loader.go, policy/loader_test.go</files>
  <action>
1. Add Load method to Loader:
   ```go
   func (l *Loader) Load(ctx context.Context, parameterName string) (*Policy, error)
   ```

   Implementation:
   - Call l.client.GetParameter with:
     - Name: aws.String(parameterName)
     - WithDecryption: aws.Bool(true) (handles SecureString, ignored for String)
   - Handle errors:
     - Use errors.As to check for *types.ParameterNotFound
     - If ParameterNotFound: return nil, fmt.Errorf("%s: %w", parameterName, ErrPolicyNotFound)
     - Other errors: return nil, fmt.Errorf("ssm GetParameter: %w", err)
   - On success: call ParsePolicy([]byte(*output.Parameter.Value))
   - Return parsed policy

2. Create policy/loader_test.go with:
   - Package policy_test (external test package)
   - Test that ErrPolicyNotFound is exported and usable with errors.Is
   - Test NewLoader creates non-nil Loader (basic smoke test)

Note: Full integration tests require AWS credentials; unit tests mock the SSM client interface.
Skip mocking for now - integration testing happens in Phase 5.
  </action>
  <verify>go test ./policy/... passes</verify>
  <done>Load method fetches from SSM, parses YAML, handles ParameterNotFound error correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./policy/...` passes
- [ ] `go vet ./policy/...` reports no issues
- [ ] Loader type has NewLoader constructor and Load method
- [ ] ErrPolicyNotFound is exported for error checking
</verification>

<success_criteria>
- All tasks completed
- SSM dependency added to go.mod
- Loader type can fetch policy from SSM parameter
- ParameterNotFound error wrapped with ErrPolicyNotFound sentinel
- Code follows existing codebase conventions (import order, error wrapping)
</success_criteria>

<output>
After completion, create `.planning/phases/03-policy-loading/03-01-SUMMARY.md`
</output>
