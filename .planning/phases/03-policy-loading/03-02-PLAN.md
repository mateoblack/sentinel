---
phase: 03-policy-loading
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified: [policy/cache.go, policy/cache_test.go]
autonomous: true
---

<objective>
Add TTL-based caching layer around the policy loader to avoid repeated SSM calls.

Purpose: Reduce SSM API calls and latency for repeated credential requests within short time windows.
Output: CachedLoader type that wraps Loader with in-memory TTL cache.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-policy-loading/03-RESEARCH.md
@.planning/phases/03-policy-loading/03-01-SUMMARY.md

# Loader type from previous plan
@policy/loader.go
@policy/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CachedLoader with TTL</name>
  <files>policy/cache.go</files>
  <action>
1. Create policy/cache.go with:
   - Package comment explaining caching purpose
   - Import: context, sync, time

2. Define PolicyLoader interface:
   ```go
   // PolicyLoader loads policies from a source.
   type PolicyLoader interface {
       Load(ctx context.Context, parameterName string) (*Policy, error)
   }
   ```
   This allows CachedLoader to wrap any loader implementation.

3. Define cacheEntry struct (unexported):
   ```go
   type cacheEntry struct {
       policy *Policy
       expiry time.Time
   }
   ```

4. Define CachedLoader struct:
   ```go
   type CachedLoader struct {
       loader PolicyLoader
       mu     sync.RWMutex
       cache  map[string]*cacheEntry
       ttl    time.Duration
   }
   ```

5. Implement NewCachedLoader:
   ```go
   func NewCachedLoader(loader PolicyLoader, ttl time.Duration) *CachedLoader
   ```
   Initialize cache map, store loader and ttl.

6. Implement Load method with double-checked locking:
   - RLock, check if entry exists and not expired, RUnlock and return if hit
   - Lock (write), double-check after acquiring lock
   - On miss/expired: call l.loader.Load(ctx, name)
   - On error: return error (don't cache errors)
   - On success: store in cache with expiry = now + ttl
   - Unlock and return

Follow pattern from 03-RESEARCH.md code examples section.
Do NOT use external caching library - simple mutex+map is sufficient per research.
  </action>
  <verify>go build ./policy/... compiles without errors</verify>
  <done>CachedLoader wraps PolicyLoader with TTL-based caching, thread-safe</done>
</task>

<task type="auto">
  <name>Task 2: Add cache tests</name>
  <files>policy/cache_test.go</files>
  <action>
1. Create policy/cache_test.go with package policy_test

2. Create mockLoader for testing:
   ```go
   type mockLoader struct {
       policy    *Policy
       err       error
       callCount int
   }
   func (m *mockLoader) Load(ctx context.Context, name string) (*Policy, error) {
       m.callCount++
       return m.policy, m.err
   }
   ```

3. Test cases:
   a) TestCachedLoader_CacheHit:
      - Create mock returning valid policy
      - Create CachedLoader with 1-minute TTL
      - Call Load twice with same parameter name
      - Assert mock.callCount == 1 (second call hit cache)
      - Assert both returns are same policy pointer

   b) TestCachedLoader_CacheExpiry:
      - Create mock returning valid policy
      - Create CachedLoader with 1ms TTL (very short for test)
      - Call Load, sleep 5ms, call Load again
      - Assert mock.callCount == 2 (cache expired)

   c) TestCachedLoader_ErrorNotCached:
      - Create mock returning error
      - Create CachedLoader with 1-minute TTL
      - Call Load twice
      - Assert mock.callCount == 2 (errors not cached)

   d) TestCachedLoader_DifferentParameters:
      - Create mock returning valid policy
      - Create CachedLoader with 1-minute TTL
      - Call Load with "param1", then "param2"
      - Assert mock.callCount == 2 (different cache keys)

Use time.Sleep sparingly (only for expiry test with very short TTL).
  </action>
  <verify>go test ./policy/... -v passes all cache tests</verify>
  <done>Cache behavior verified: hits, expiry, error handling, parameter isolation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./policy/...` passes (including new cache tests)
- [ ] `go vet ./policy/...` reports no issues
- [ ] CachedLoader implements PolicyLoader interface
- [ ] Cache hits avoid calling underlying loader
- [ ] Expired entries trigger fresh load
- [ ] Errors are not cached
</verification>

<success_criteria>
- All tasks completed
- CachedLoader provides TTL-based caching
- Tests verify cache hit/miss/expiry behavior
- Thread-safe implementation with sync.RWMutex
- No external dependencies added (stdlib only)
</success_criteria>

<output>
After completion, create `.planning/phases/03-policy-loading/03-02-SUMMARY.md`
</output>
