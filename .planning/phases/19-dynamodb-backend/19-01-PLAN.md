---
phase: 19-dynamodb-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [request/store.go, request/dynamodb.go, request/dynamodb_test.go]
autonomous: true
---

<objective>
Create request storage abstraction with DynamoDB implementation for CRUD operations.

Purpose: Enable persistent storage of approval requests with atomic operations and DynamoDB as the backend. Follows the existing loader pattern from policy/loader.go.
Output: Store interface + DynamoDB implementation with basic CRUD operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 18 output - Request types we're storing:
@request/types.go
@request/validate.go

# Existing AWS service integration pattern:
@policy/loader.go

# Codebase conventions:
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Store interface and error types</name>
  <files>request/store.go</files>
  <action>
Create the storage abstraction for approval requests:

**Store interface:**
```go
type Store interface {
    // Create stores a new request. Returns error if ID already exists.
    Create(ctx context.Context, req *Request) error

    // Get retrieves a request by ID. Returns ErrRequestNotFound if not exists.
    Get(ctx context.Context, id string) (*Request, error)

    // Update modifies an existing request. Returns ErrRequestNotFound if not exists.
    // Uses optimistic locking via UpdatedAt to prevent concurrent modification.
    Update(ctx context.Context, req *Request) error

    // Delete removes a request by ID. No-op if not exists.
    Delete(ctx context.Context, id string) error
}
```

**Error types:**
- `ErrRequestNotFound` - sentinel error for missing requests
- `ErrRequestExists` - sentinel error for duplicate ID on create
- `ErrConcurrentModification` - optimistic locking failure

Follow existing pattern from `policy/loader.go` for error handling with `errors.Is()` support.
  </action>
  <verify>go build ./request/...</verify>
  <done>Store interface defined with Create/Get/Update/Delete methods and sentinel errors</done>
</task>

<task type="auto">
  <name>Task 2: Implement DynamoDB store with CRUD operations</name>
  <files>request/dynamodb.go</files>
  <action>
Create DynamoDB implementation of Store interface:

**DynamoDBStore struct:**
```go
type DynamoDBStore struct {
    client    *dynamodb.Client
    tableName string
}

func NewDynamoDBStore(cfg aws.Config, tableName string) *DynamoDBStore
```

**Table schema assumptions (created externally via Terraform/CloudFormation):**
- Table name: configurable via constructor
- Partition key: `id` (String)
- TTL attribute: `ttl` (Number, Unix timestamp from ExpiresAt)
- All Request fields stored as attributes

**Implementation details:**

1. **Create**: Use PutItem with condition `attribute_not_exists(id)` to prevent overwrites
2. **Get**: Use GetItem, return ErrRequestNotFound if item nil
3. **Update**: Use PutItem with condition `updated_at = :old_updated_at` for optimistic locking
4. **Delete**: Use DeleteItem (no condition, idempotent)

**Marshaling:**
- Use `attributevalue.MarshalMap` for Request -> DynamoDB item
- Use `attributevalue.UnmarshalMap` for DynamoDB item -> Request
- Store time.Duration as int64 nanoseconds
- Store time.Time as RFC3339 string
- Add `ttl` attribute as Unix timestamp for DynamoDB TTL feature

**Error mapping:**
- `ConditionalCheckFailedException` on Create -> `ErrRequestExists`
- `ConditionalCheckFailedException` on Update -> `ErrConcurrentModification`
- Item not found on Get -> `ErrRequestNotFound`

Import `github.com/aws/aws-sdk-go-v2/service/dynamodb` and `github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue`.
  </action>
  <verify>go build ./request/...</verify>
  <done>DynamoDBStore implements Store interface with Create/Get/Update/Delete using DynamoDB operations</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests with mock DynamoDB client</name>
  <files>request/dynamodb_test.go</files>
  <action>
Create comprehensive unit tests for DynamoDBStore:

**Test approach:**
- Define a mock DynamoDB client interface for testing
- Test each CRUD operation in isolation
- Test error conditions (not found, duplicate, concurrent mod)

**Tests to implement:**

1. **TestDynamoDBStore_Create_Success** - creates request, verifies PutItem called with correct condition
2. **TestDynamoDBStore_Create_AlreadyExists** - returns ErrRequestExists when condition fails
3. **TestDynamoDBStore_Get_Success** - retrieves request, unmarshals correctly
4. **TestDynamoDBStore_Get_NotFound** - returns ErrRequestNotFound when item nil
5. **TestDynamoDBStore_Update_Success** - updates with optimistic locking condition
6. **TestDynamoDBStore_Update_NotFound** - returns ErrRequestNotFound when item doesn't exist
7. **TestDynamoDBStore_Update_ConcurrentModification** - returns ErrConcurrentModification when condition fails
8. **TestDynamoDBStore_Delete_Success** - deletes item (idempotent)
9. **TestDynamoDBStore_Marshaling** - round-trip test: Request -> DynamoDB -> Request preserves all fields

**Mock interface pattern:**
```go
type dynamoDBAPI interface {
    PutItem(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error)
    GetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)
    DeleteItem(ctx context.Context, params *dynamodb.DeleteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error)
}
```

Use table-driven tests where appropriate. Follow existing test patterns in request/types_test.go and request/validate_test.go.
  </action>
  <verify>go test ./request/... -v</verify>
  <done>All CRUD operations tested including error cases, marshaling verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./request/...` succeeds
- [ ] `go test ./request/...` passes all tests
- [ ] `go vet ./request/...` reports no issues
- [ ] Store interface is clean and matches existing patterns
- [ ] DynamoDB operations use proper condition expressions
- [ ] Error types support errors.Is() checking
</verification>

<success_criteria>

- Store interface defined with CRUD methods
- DynamoDBStore implements Store
- All CRUD operations work with proper error handling
- Optimistic locking prevents concurrent modification
- TTL attribute set for DynamoDB auto-cleanup
- Unit tests cover success and error paths
</success_criteria>

<output>
After completion, create `.planning/phases/19-dynamodb-backend/19-01-SUMMARY.md`
</output>
