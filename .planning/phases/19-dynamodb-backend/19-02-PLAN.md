---
phase: 19-dynamodb-backend
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified: [request/store.go, request/dynamodb.go, request/dynamodb_test.go]
autonomous: true
---

<objective>
Add query operations to Store interface for listing requests by requester, status, and profile.

Purpose: Enable approval workflow commands to list pending requests, check user's own requests, and find requests for specific profiles.
Output: Extended Store interface with query methods backed by DynamoDB GSIs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan output (wait for SUMMARY):
@.planning/phases/19-dynamodb-backend/19-01-SUMMARY.md

# Request types:
@request/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Store interface with query methods</name>
  <files>request/store.go</files>
  <action>
Add query methods to the Store interface:

```go
// ListByRequester returns all requests from a specific user, ordered by created_at desc.
// Returns empty slice if no requests found.
ListByRequester(ctx context.Context, requester string, limit int) ([]*Request, error)

// ListByStatus returns all requests with a specific status, ordered by created_at desc.
// Commonly used to list pending requests for approvers.
ListByStatus(ctx context.Context, status RequestStatus, limit int) ([]*Request, error)

// ListByProfile returns all requests for a specific AWS profile, ordered by created_at desc.
// Useful for viewing request history for a profile.
ListByProfile(ctx context.Context, profile string, limit int) ([]*Request, error)
```

**Design notes:**
- All query methods return newest first (created_at descending)
- Limit parameter caps results (0 = use default, e.g., 100)
- Empty slice returned for no results (not error)
- These queries require GSIs on DynamoDB table

**Add constants for query defaults:**
```go
const (
    DefaultQueryLimit = 100
    MaxQueryLimit     = 1000
)
```
  </action>
  <verify>go build ./request/...</verify>
  <done>Store interface extended with ListByRequester, ListByStatus, ListByProfile methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement GSI queries in DynamoDB store</name>
  <files>request/dynamodb.go</files>
  <action>
Implement query methods using DynamoDB Global Secondary Indexes:

**GSI design (table created externally):**
- GSI-Requester: PK=`requester`, SK=`created_at` (String, RFC3339)
- GSI-Status: PK=`status`, SK=`created_at`
- GSI-Profile: PK=`profile`, SK=`created_at`

**Add GSI name constants:**
```go
const (
    GSIRequester = "gsi-requester"
    GSIStatus    = "gsi-status"
    GSIProfile   = "gsi-profile"
)
```

**Implementation for each query:**

1. **ListByRequester:**
   - Query GSI-Requester with KeyConditionExpression `requester = :r`
   - ScanIndexForward: false (newest first)
   - Limit: apply limit parameter

2. **ListByStatus:**
   - Query GSI-Status with KeyConditionExpression `status = :s`
   - ScanIndexForward: false
   - Limit: apply limit parameter

3. **ListByProfile:**
   - Query GSI-Profile with KeyConditionExpression `profile = :p`
   - ScanIndexForward: false
   - Limit: apply limit parameter

**Helper function:**
```go
func (s *DynamoDBStore) queryByIndex(ctx context.Context, indexName, keyAttr, keyValue string, limit int) ([]*Request, error)
```

Use `dynamodb.QueryInput` with IndexName, KeyConditionExpression, ExpressionAttributeValues.

Handle limit: if 0 use DefaultQueryLimit, cap at MaxQueryLimit.
  </action>
  <verify>go build ./request/...</verify>
  <done>Query methods implemented using DynamoDB GSI queries with proper pagination</done>
</task>

<task type="auto">
  <name>Task 3: Add query tests</name>
  <files>request/dynamodb_test.go</files>
  <action>
Add unit tests for query operations:

**Extend mock interface:**
```go
Query(ctx context.Context, params *dynamodb.QueryInput, optFns ...func(*dynamodb.Options)) (*dynamodb.QueryOutput, error)
```

**Tests to implement:**

1. **TestDynamoDBStore_ListByRequester_Success** - returns requests for user, newest first
2. **TestDynamoDBStore_ListByRequester_Empty** - returns empty slice for unknown user
3. **TestDynamoDBStore_ListByStatus_Pending** - returns pending requests for approver view
4. **TestDynamoDBStore_ListByStatus_Empty** - returns empty slice when no matching status
5. **TestDynamoDBStore_ListByProfile_Success** - returns requests for profile
6. **TestDynamoDBStore_ListByProfile_Empty** - returns empty slice for unused profile
7. **TestDynamoDBStore_QueryLimit** - respects limit parameter, caps at MaxQueryLimit

**Verify each query:**
- Uses correct GSI name
- Has correct KeyConditionExpression
- Sets ScanIndexForward=false for descending order
- Applies limit correctly

Use table-driven tests for the three query types to reduce duplication.
  </action>
  <verify>go test ./request/... -v</verify>
  <done>Query operations fully tested including empty results and limit handling</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./request/...` succeeds
- [ ] `go test ./request/...` passes all tests (including Plan 01 tests)
- [ ] `go vet ./request/...` reports no issues
- [ ] Query methods use correct GSI names
- [ ] Results ordered by created_at descending
- [ ] Limit parameter handled correctly
</verification>

<success_criteria>

- Store interface has ListByRequester, ListByStatus, ListByProfile methods
- DynamoDBStore implements all query methods using GSIs
- Queries return newest first
- Limit parameter respected with sensible defaults
- All query paths tested
</success_criteria>

<output>
After completion, create `.planning/phases/19-dynamodb-backend/19-02-SUMMARY.md`
</output>
