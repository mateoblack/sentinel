---
phase: 27-break-glass-schema
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [breakglass/types.go, breakglass/validate.go, breakglass/types_test.go, breakglass/validate_test.go]
autonomous: true
---

<objective>
Define break-glass event data model with reason codes, status state machine, and validation.

Purpose: Establish the foundation for emergency access bypass with mandatory justification and audit trail.
Output: BreakGlassEvent type with state machine, ReasonCode enum, and comprehensive validation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Pattern reference - follow these exactly:
@request/types.go
@request/validate.go
@policy/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create break-glass types with state machine</name>
  <files>breakglass/types.go, breakglass/types_test.go</files>
  <action>
Create new `breakglass` package following the `request` package pattern exactly:

**breakglass/types.go:**

1. Package doc comment explaining break-glass concept and state machine
2. Constants:
   - `DefaultBreakGlassTTL = 4 * time.Hour` (shorter than approval requests - emergency access should be brief)
   - `MaxJustificationLength = 1000` (longer than approval - incidents need detail)
   - `MinJustificationLength = 20` (require meaningful explanation)
   - `BreakGlassIDLength = 16` (same as request ID)
   - `MaxDuration = 4 * time.Hour` (cap emergency access)

3. `BreakGlassStatus` type (string) with constants:
   - `StatusActive` = "active" (emergency access in use)
   - `StatusClosed` = "closed" (manually closed by invoker or security)
   - `StatusExpired` = "expired" (TTL elapsed)
   - Methods: `IsValid()`, `String()`, `IsTerminal()`

4. `ReasonCode` type (string) with constants - predefined reason categories:
   - `ReasonIncident` = "incident" (production incident response)
   - `ReasonMaintenance` = "maintenance" (emergency maintenance)
   - `ReasonSecurity` = "security" (security incident response)
   - `ReasonRecovery` = "recovery" (disaster recovery)
   - `ReasonOther` = "other" (requires detailed justification)
   - Methods: `IsValid()`, `String()`

5. `BreakGlassEvent` struct:
   - `ID` string (16 hex chars)
   - `Invoker` string (who invoked break-glass)
   - `Profile` string (AWS profile accessed)
   - `ReasonCode` ReasonCode (predefined category)
   - `Justification` string (detailed explanation)
   - `Duration` time.Duration (requested access duration)
   - `Status` BreakGlassStatus
   - `CreatedAt` time.Time (when invoked)
   - `UpdatedAt` time.Time (last modification)
   - `ExpiresAt` time.Time (when access expires)
   - `ClosedBy` string (who closed it, empty if expired)
   - `ClosedReason` string (why it was closed early)
   - `RequestID` string (Sentinel request ID for CloudTrail correlation)
   - All fields with yaml and json tags, optional fields with omitempty

6. `NewBreakGlassID()` function using crypto/rand (same pattern as NewRequestID)
7. `ValidateBreakGlassID(id string) bool` function with regex validation

**breakglass/types_test.go:**

Table-driven tests for:
- `BreakGlassStatus.IsValid()` - all valid values and invalid
- `BreakGlassStatus.IsTerminal()` - active is false, closed/expired are true
- `ReasonCode.IsValid()` - all valid values and invalid
- `NewBreakGlassID()` - format, length, uniqueness
- `ValidateBreakGlassID()` - valid and invalid IDs
  </action>
  <verify>go test ./breakglass/... -run "TestBreakGlassStatus|TestReasonCode|TestNewBreakGlassID|TestValidateBreakGlassID" -v</verify>
  <done>BreakGlassEvent type with state machine, ReasonCode enum, ID generation all working with tests passing</done>
</task>

<task type="auto">
  <name>Task 2: Implement validation with comprehensive tests</name>
  <files>breakglass/validate.go, breakglass/validate_test.go</files>
  <action>
Create validation following the `request/validate.go` pattern:

**breakglass/validate.go:**

1. `Validate()` method on `*BreakGlassEvent`:
   - Validate ID format (16 lowercase hex chars)
   - Validate Invoker non-empty
   - Validate Profile non-empty
   - Validate ReasonCode is valid
   - Validate Justification length (min 20, max 1000)
   - Validate Status is valid
   - Validate Duration positive and <= MaxDuration
   - Validate timestamps non-zero (CreatedAt, UpdatedAt, ExpiresAt)
   - Return descriptive error messages

2. `CanTransitionTo(newStatus BreakGlassStatus) bool` method:
   - Only active status can transition
   - Can only transition to closed or expired
   - Terminal states cannot transition

**breakglass/validate_test.go:**

Table-driven tests for:
- `Validate()`:
  - Valid event passes
  - Invalid ID fails
  - Empty invoker fails
  - Empty profile fails
  - Invalid reason code fails
  - Justification too short fails
  - Justification too long fails
  - Invalid status fails
  - Zero/negative duration fails
  - Duration exceeds max fails
  - Zero timestamps fail
  - Boundary tests (exactly min/max lengths)

- `CanTransitionTo()`:
  - active -> closed: true
  - active -> expired: true
  - active -> active: false
  - closed -> anything: false
  - expired -> anything: false
  </action>
  <verify>go test ./breakglass/... -v</verify>
  <done>All validation tests pass, comprehensive coverage for all fields and state transitions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./breakglass/...` passes all tests
- [ ] `go vet ./breakglass/...` reports no issues
- [ ] Types follow established patterns from request/ package
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- BreakGlassEvent type ready for storage (Phase 28 dependency)
- ReasonCode provides predefined categories for audit
- State machine enables active -> closed/expired transitions
</success_criteria>

<output>
After completion, create `.planning/phases/27-break-glass-schema/27-01-SUMMARY.md`
</output>
