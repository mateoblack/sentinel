---
phase: 121-policy-schema-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [policy/types.go, policy/validate.go, policy/parse.go, policy/marshal.go, policy/types_test.go, policy/validate_test.go, policy/parse_test.go, policy/marshal_test.go]
autonomous: true
---

<objective>
Extend policy schema with version validation and YAML helpers for policy developer tooling.

Purpose: Enable Phase 122-125 policy commands (pull, push, diff, validate) with proper schema version handling and YAML serialization.
Output: Enhanced policy package with version validation, YAML marshal helper, and exported validation functions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@policy/types.go
@policy/validate.go
@policy/parse.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schema version constants and validation</name>
  <files>policy/types.go, policy/validate.go, policy/types_test.go, policy/validate_test.go</files>
  <action>
  1. In policy/types.go, add version constants:
     - SchemaVersion1 = "1" (current implicit version)
     - CurrentSchemaVersion = SchemaVersion1
     - SupportedVersions = []string{"1"} for future extensibility

  2. Add Version type alias with IsValid() and IsCurrent() methods:
     - type Version string
     - func (v Version) IsValid() bool - checks against SupportedVersions
     - func (v Version) IsCurrent() bool - checks v == CurrentSchemaVersion

  3. Update Policy struct's Version field to use Version type instead of string:
     - Version Version `yaml:"version" json:"version"`

  4. In policy/validate.go, add version validation to Policy.Validate():
     - Return error if Version.IsValid() returns false
     - Error message: "unsupported policy version '%s', supported versions: %v"

  5. Add tests in policy/types_test.go:
     - TestVersion_IsValid - valid "1", invalid "2", empty ""
     - TestVersion_IsCurrent - "1" is current

  6. Add tests in policy/validate_test.go:
     - TestPolicy_Validate_UnsupportedVersion - version "99" fails validation
     - TestPolicy_Validate_ValidVersion - version "1" passes

  Note: Keep backward compatibility - policies with version "1" continue to work.
  </action>
  <verify>go test ./policy/... -run "Version|Validate" -v passes</verify>
  <done>Version type with validation, SupportedVersions constant, and version validation in Policy.Validate()</done>
</task>

<task type="auto">
  <name>Task 2: Add YAML marshal helper for policy serialization</name>
  <files>policy/marshal.go, policy/marshal_test.go</files>
  <action>
  1. Create policy/marshal.go with MarshalPolicy function:
     ```go
     // MarshalPolicy serializes a Policy to YAML bytes.
     // Returns the YAML representation suitable for storage or display.
     func MarshalPolicy(p *Policy) ([]byte, error) {
         return yaml.Marshal(p)
     }
     ```

  2. Add MarshalPolicyToWriter helper:
     ```go
     // MarshalPolicyToWriter serializes a Policy to YAML and writes to w.
     func MarshalPolicyToWriter(p *Policy, w io.Writer) error {
         data, err := MarshalPolicy(p)
         if err != nil {
             return fmt.Errorf("failed to marshal policy: %w", err)
         }
         _, err = w.Write(data)
         return err
     }
     ```

  3. Create policy/marshal_test.go with tests:
     - TestMarshalPolicy_RoundTrip - marshal then parse produces equivalent policy
     - TestMarshalPolicy_Format - output contains expected YAML structure (version, rules)
     - TestMarshalPolicyToWriter - writes to buffer correctly

  Note: Use gopkg.in/yaml.v3 like parse.go for consistency.
  </action>
  <verify>go test ./policy/... -run "Marshal" -v passes</verify>
  <done>MarshalPolicy and MarshalPolicyToWriter functions with tests</done>
</task>

<task type="auto">
  <name>Task 3: Export ValidatePolicy helper for CLI commands</name>
  <files>policy/validate.go, policy/validate_test.go</files>
  <action>
  1. Add exported ValidatePolicy function in policy/validate.go:
     ```go
     // ValidatePolicy validates a policy from raw YAML bytes.
     // Returns a detailed error if validation fails, nil if valid.
     // This is the entry point for CLI validation commands.
     func ValidatePolicy(data []byte) error {
         p, err := ParsePolicy(data)
         if err != nil {
             return fmt.Errorf("parse error: %w", err)
         }
         if err := p.Validate(); err != nil {
             return fmt.Errorf("validation error: %w", err)
         }
         return nil
     }
     ```

  2. Add ValidatePolicyFromReader helper:
     ```go
     // ValidatePolicyFromReader validates a policy from an io.Reader.
     // Convenient for validating files.
     func ValidatePolicyFromReader(r io.Reader) error {
         data, err := io.ReadAll(r)
         if err != nil {
             return fmt.Errorf("failed to read policy: %w", err)
         }
         return ValidatePolicy(data)
     }
     ```

  3. Add tests in policy/validate_test.go:
     - TestValidatePolicy_Valid - valid YAML passes
     - TestValidatePolicy_InvalidYAML - malformed YAML fails with parse error
     - TestValidatePolicy_InvalidSchema - valid YAML but missing name fails with validation error
     - TestValidatePolicyFromReader - reader version works correctly

  Note: Error messages distinguish parse errors from validation errors for CLI UX.
  </action>
  <verify>go test ./policy/... -run "ValidatePolicy" -v passes</verify>
  <done>ValidatePolicy and ValidatePolicyFromReader functions exported for CLI use</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./policy/... -v` passes all tests
- [ ] `go build ./...` succeeds without errors
- [ ] `go vet ./policy/...` reports no issues
- [ ] Version validation works (valid "1", rejects "2")
- [ ] MarshalPolicy round-trips correctly
- [ ] ValidatePolicy exported and usable
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Version type with validation constants added
- MarshalPolicy helper ready for policy push command
- ValidatePolicy helper ready for policy validate command
</success_criteria>

<output>
After completion, create `.planning/phases/121-policy-schema-enhancements/121-01-SUMMARY.md`
</output>
