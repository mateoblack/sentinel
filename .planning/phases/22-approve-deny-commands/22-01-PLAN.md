---
phase: 22-approve-deny-commands
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [cli/approve.go, cli/deny.go, cli/approve_test.go, cli/deny_test.go, cmd/sentinel/main.go]
autonomous: true
---

<objective>
Implement `sentinel approve` and `sentinel deny` commands for approver actions on pending requests.

Purpose: Enable approvers to action pending access requests, completing the request/approve workflow.
Output: Two CLI commands that transition requests from pending to approved/denied with approver identity.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Codebase patterns:
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md

Prior phase context (request types and store interface):
@request/types.go
@request/validate.go
@request/store.go

CLI command patterns to follow:
@cli/check.go
@cli/request.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create approve command with CLI configuration</name>
  <files>cli/approve.go</files>
  <action>
Create approve command following check command pattern:

1. ApproveCommandInput struct:
   - RequestID string (positional arg)
   - Comment string (optional --comment flag)
   - RequestTable string (--request-table, required)
   - Region string (--region, optional)
   - Store request.Store (for testing injection)

2. ApproveCommandOutput struct (JSON output):
   - ID, Profile, Status, Approver, ApproverComment (omitempty), UpdatedAt

3. ConfigureApproveCommand:
   - app.Command("approve", "Approve a pending access request")
   - Positional arg "request-id" (required)
   - Flags: --comment (optional), --request-table (required), --region (optional)
   - Action calls ApproveCommand

4. ApproveCommand logic:
   a. Validate request ID format using request.ValidateRequestID
   b. Get current user via os/user.Current() for approver identity
   c. Create or use injected store
   d. Get request from store (handle ErrRequestNotFound)
   e. Check request.CanTransitionTo(request.StatusApproved) - fail if not pending
   f. Update request: Status=StatusApproved, Approver=username, ApproverComment=input.Comment, UpdatedAt=time.Now()
   g. Call store.Update (handle ErrConcurrentModification)
   h. Output JSON to stdout

Error messages to stderr, return error on failure.
  </action>
  <verify>go build ./cli compiles without errors</verify>
  <done>cli/approve.go exists with ApproveCommand function following check command patterns</done>
</task>

<task type="auto">
  <name>Task 2: Create deny command with CLI configuration</name>
  <files>cli/deny.go</files>
  <action>
Create deny command identical to approve except for status transition:

1. DenyCommandInput struct - same as ApproveCommandInput

2. DenyCommandOutput struct - same as ApproveCommandOutput

3. ConfigureDenyCommand:
   - app.Command("deny", "Deny a pending access request")
   - Same args and flags as approve

4. DenyCommand logic:
   - Same as ApproveCommand but transitions to StatusDenied
   - All error handling identical

Note: The two commands are intentionally similar - they differ only in target status.
Keep implementations parallel for maintainability.
  </action>
  <verify>go build ./cli compiles without errors</verify>
  <done>cli/deny.go exists with DenyCommand function mirroring approve command</done>
</task>

<task type="auto">
  <name>Task 3: Wire commands in main.go and add unit tests</name>
  <files>cmd/sentinel/main.go, cli/approve_test.go, cli/deny_test.go</files>
  <action>
1. Wire in main.go:
   - Add cli.ConfigureApproveCommand(sentinelCmd, sentinel) after ConfigureCheckCommand
   - Add cli.ConfigureDenyCommand(sentinelCmd, sentinel) after ConfigureApproveCommand

2. Create cli/approve_test.go with test cases:
   - TestApproveCommand_Success: mock store returns pending request, Update called, JSON output verified
   - TestApproveCommand_WithComment: verify comment flows to ApproverComment field
   - TestApproveCommand_NotFound: mock store returns ErrRequestNotFound
   - TestApproveCommand_InvalidID: test with invalid request ID format
   - TestApproveCommand_AlreadyApproved: mock store returns already-approved request, CanTransitionTo fails
   - TestApproveCommand_AlreadyDenied: mock store returns denied request, CanTransitionTo fails
   - TestApproveCommand_StoreError: mock store returns generic error

3. Create cli/deny_test.go with same test structure:
   - Mirror approve tests for deny command
   - Verify transitions to StatusDenied

Reuse mockStore pattern from cli/request_test.go and cli/check_test.go.
Use table-driven tests where appropriate.
  </action>
  <verify>go test ./cli -run "Approve|Deny" -v passes all tests</verify>
  <done>Commands wired in main.go, 14+ test cases pass for approve and deny commands</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./... succeeds without errors
- [ ] go test ./cli -run "Approve|Deny" -v passes all tests
- [ ] sentinel approve --help shows correct usage
- [ ] sentinel deny --help shows correct usage
</verification>

<success_criteria>

- All tasks completed
- Both commands follow established CLI patterns
- State machine transitions properly validated
- Approver identity captured from current user
- Optional comment supported
- JSON output format consistent with other commands
- Comprehensive test coverage including edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/22-approve-deny-commands/22-01-SUMMARY.md`
</output>
