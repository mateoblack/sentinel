---
phase: 108-policy-device-conditions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - policy/evaluate.go
  - policy/evaluate_test.go
  - lambda/handler.go
  - lambda/handler_test.go
autonomous: true
---

<objective>
Wire device posture into policy evaluation so device conditions affect access decisions.

Purpose: Enable policies with `device:` conditions (require_mdm, require_encryption, etc.) to actually evaluate against device posture from MDM. Currently DeviceCondition.Matches() exists but isn't called during policy evaluation.

Output: Policy evaluation checks device conditions, Lambda handler passes MDM result to policy.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (device posture foundation)
@.planning/phases/104-device-fingerprint-schema/104-01-SUMMARY.md
@.planning/phases/105-device-collector-interface/105-01-SUMMARY.md
@.planning/phases/107-mdm-api-integration/107-03-SUMMARY.md

# Source files being modified
@policy/evaluate.go
@policy/device.go
@lambda/handler.go
@lambda/mdm_integration.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DevicePosture to policy.Request and wire into matchesConditions</name>
  <files>policy/evaluate.go, policy/evaluate_test.go</files>
  <action>
1. Add `DevicePosture *device.DevicePosture` field to `policy.Request` struct (after SessionTableName)
   - Import "github.com/byteness/aws-vault/v7/device"
   - Field is pointer to allow nil (no device info available)

2. Update `matchesConditions()` to check device conditions:
   - After mode check (line ~125), add device condition check
   - If `c.Device != nil` (device conditions specified in rule):
     - Call `c.Device.Matches(req.DevicePosture)` which already handles nil posture
     - Return false if device conditions not met
   - If `c.Device == nil` or `c.Device.IsEmpty()`: no device requirement, continue

3. Add comprehensive tests in policy/evaluate_test.go:
   - Test: rule with device conditions, posture matches → allow
   - Test: rule with device conditions, posture fails → rule not matched, falls through
   - Test: rule with device conditions, nil posture → rule not matched (empty condition matches)
   - Test: rule without device conditions, any posture → matches (backward compatible)
   - Test: multiple rules, first has device condition that fails, second allows → second matches

Note: Device conditions affect RULE MATCHING, not the effect. If device fails, the rule doesn't match and evaluation continues to next rule (first-match-wins). This is consistent with how other conditions (users, profiles, time) work.
  </action>
  <verify>go test ./policy/... -run "Device" -v passes all device-related tests</verify>
  <done>policy.Request accepts DevicePosture, matchesConditions() evaluates device conditions, tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Wire MDM posture into Lambda policy evaluation</name>
  <files>lambda/handler.go, lambda/handler_test.go</files>
  <action>
1. In HandleRequest(), after MDM query (line ~102), pass posture to policy request:
   - Before building policyRequest (~line 112), check mdmResult
   - If mdmResult != nil && mdmResult.Posture != nil, set DevicePosture field

   ```go
   policyRequest := &policy.Request{
       User:             username,
       Profile:          profile,
       Time:             time.Now(),
       Mode:             policy.ModeServer,
       SessionTableName: h.Config.SessionTableName,
       DevicePosture:    nil, // default
   }

   // Add device posture if MDM query succeeded
   if mdmResult != nil && mdmResult.Posture != nil {
       policyRequest.DevicePosture = mdmResult.Posture
   }
   ```

2. Add integration tests in lambda/handler_test.go:
   - Test: policy with require_mdm, device is enrolled → allow
   - Test: policy with require_mdm, device not enrolled → deny (rule not matched, default deny)
   - Test: policy with require_mdm, no device_id provided → deny (nil posture fails condition)
   - Test: policy without device conditions, MDM result ignored → allow
   - Ensure mdmResult.Posture nil (MDM error with fail-open) doesn't crash
  </action>
  <verify>go test ./lambda/... -run "Device\|MDM" -v passes</verify>
  <done>Lambda handler passes MDM posture to policy evaluation, device conditions enforced</done>
</task>

<task type="auto">
  <name>Task 3: Add decision logging for device posture evaluation</name>
  <files>lambda/handler.go</files>
  <action>
1. Enhance credential vending logs to include device posture evaluation outcome:
   - In the decision logging section (~line 180+), if mdmResult != nil:
     - Log device_id
     - Log device_posture_status (compliant/non_compliant/unknown or "not_provided")
     - Log mdm_enrolled and mdm_compliant booleans

2. This is logging enhancement only - the evaluation happens in Task 1/2.
   Uses existing log.Printf pattern from logMDMResult but in decision context.

3. Example log line format:
   ```
   INFO: Credential decision user=%s profile=%s effect=%s device_id=%s device_status=%s mdm_enrolled=%v
   ```
  </action>
  <verify>go test ./lambda/... -v shows device fields in test log output</verify>
  <done>Decision logs include device posture evaluation context</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./policy/... -v` passes all tests
- [ ] `go test ./lambda/... -v` passes all tests
- [ ] `go test ./... -race` passes race detector
- [ ] Policy with device conditions evaluates correctly:
  - require_mdm: true → only matches if MDMEnrolled=true
  - require_mdm_compliant: true → only matches if MDMCompliant=true
  - require_encryption: true → only matches if DiskEncrypted=true (when posture available)
</verification>

<success_criteria>

- policy.Request includes DevicePosture field
- matchesConditions() checks device conditions against posture
- Lambda handler wires MDM result into policy evaluation
- Device conditions affect rule matching (fail condition → rule doesn't match → try next)
- Nil posture fails non-empty device conditions (security: no posture = no match)
- Empty device conditions always match (backward compatible)
- All tests pass including new device condition tests
</success_criteria>

<output>
After completion, create `.planning/phases/108-policy-device-conditions/108-01-SUMMARY.md`
</output>
