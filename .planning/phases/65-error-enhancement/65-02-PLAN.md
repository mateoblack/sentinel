---
phase: 65-error-enhancement
plan: 02
type: execute
wave: 2
depends_on: ["65-01"]
files_modified:
  - policy/loader.go
  - cli/sentinel_exec.go
  - cli/credentials.go
  - request/dynamodb.go
  - permissions/checker.go
autonomous: true
---

<objective>
Integrate structured errors into critical paths for better user feedback.

Purpose: Replace generic error messages in high-impact code paths with structured errors that provide specific fix suggestions.

Output: Updated CLI and library code that returns SentinelErrors, with stderr output showing both error and suggestion.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/65-error-enhancement/65-01-PLAN.md

@errors/types.go
@errors/suggestions.go
@policy/loader.go
@cli/sentinel_exec.go
@cli/credentials.go
@request/dynamodb.go
@permissions/checker.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate errors into policy loader and CLI exec</name>
  <files>policy/loader.go, cli/sentinel_exec.go</files>
  <action>
Update policy/loader.go to return structured errors:

**In Load() method:**
```go
func (l *Loader) Load(ctx context.Context, parameter string) (*Policy, error) {
    // ... existing code ...
    if err != nil {
        // Wrap SSM error with context
        return nil, sentinelerrors.WrapSSMError(err, parameter)
    }
    // ... rest of method ...
}
```

Import the errors package as `sentinelerrors` to avoid conflict with standard library errors.

**Update cli/sentinel_exec.go to display suggestions:**

Create helper function to format error output:
```go
// formatErrorWithSuggestion writes error to stderr with suggestion if available
func formatErrorWithSuggestion(err error) {
    sentErr, ok := sentinelerrors.IsSentinelError(err)
    if ok {
        fmt.Fprintf(os.Stderr, "Error: %s\n", sentErr.Error())
        if suggestion := sentErr.Suggestion(); suggestion != "" {
            fmt.Fprintf(os.Stderr, "\nSuggestion: %s\n", suggestion)
        }
        if ctx := sentErr.Context(); len(ctx) > 0 {
            fmt.Fprintf(os.Stderr, "\nDetails:\n")
            for k, v := range ctx {
                fmt.Fprintf(os.Stderr, "  %s: %s\n", k, v)
            }
        }
    } else {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
    }
}
```

Update error handling in SentinelExecCommand:
```go
// Policy load error (line ~144)
loadedPolicy, err := cachedLoader.Load(ctx, input.PolicyParameter)
if err != nil {
    formatErrorWithSuggestion(err)
    return 1, err
}

// Policy denial (line ~187) - use NewPolicyDeniedError
if decision.Effect == policy.EffectDeny {
    // ... existing approval/breakglass checks ...
    if approvedReq == nil && activeBreakGlass == nil {
        // Create structured error with context
        policyErr := sentinelerrors.NewPolicyDeniedError(
            username,
            input.ProfileName,
            decision.MatchedRule,
            input.Store != nil,           // hasApprovalWorkflow
            input.BreakGlassStore != nil, // hasBreakGlass
        )
        if logger != nil {
            entry := logging.NewDecisionLogEntry(policyRequest, decision, input.PolicyParameter)
            logger.LogDecision(entry)
        }
        formatErrorWithSuggestion(policyErr)
        return 1, policyErr
    }
}
```

**Update AWS config error handling:**
```go
// AWS config load error (line ~133)
awsCfg, err := config.LoadDefaultConfig(ctx, awsCfgOpts...)
if err != nil {
    configErr := sentinelerrors.New(
        sentinelerrors.ErrCodeConfigMissingCredentials,
        fmt.Sprintf("Failed to load AWS config: %v", err),
        sentinelerrors.GetSuggestion(sentinelerrors.ErrCodeConfigMissingCredentials),
        err,
    )
    formatErrorWithSuggestion(configErr)
    return 1, configErr
}
```
  </action>
  <verify>go build ./policy ./cli succeeds; go test ./policy ./cli -run TestSentinelExec -v passes</verify>
  <done>policy/loader.go returns structured SSM errors; cli/sentinel_exec.go displays suggestions for policy load, policy denial, and config errors</done>
</task>

<task type="auto">
  <name>Task 2: Integrate errors into DynamoDB stores and permissions checker</name>
  <files>request/dynamodb.go, permissions/checker.go</files>
  <action>
**Update request/dynamodb.go to wrap DynamoDB errors:**

Wrap errors in CRUD operations:
```go
func (s *DynamoDBStore) Get(ctx context.Context, id string) (*Request, error) {
    // ... existing code ...
    if err != nil {
        return nil, sentinelerrors.WrapDynamoDBError(err, s.tableName, "GetItem")
    }
    // ...
}

func (s *DynamoDBStore) Create(ctx context.Context, req *Request) error {
    // ... existing code ...
    if err != nil {
        // Special handling for conditional check failure (already handled as ErrRequestExists)
        var ccf *types.ConditionalCheckFailedException
        if errors.As(err, &ccf) {
            return ErrRequestExists
        }
        return sentinelerrors.WrapDynamoDBError(err, s.tableName, "PutItem")
    }
    // ...
}

// Same pattern for Update, ListByRequester, ListByStatus, ListByProfile
```

Apply same pattern to breakglass/store.go (DynamoDB operations):
- Wrap Get, Create, Update, List* method errors

**Update permissions/checker.go to wrap IAM errors:**

In Check() method:
```go
func (c *Checker) Check(ctx context.Context, features []Feature) (*CheckSummary, error) {
    // Get caller identity
    identity, err := c.stsClient.GetCallerIdentity(ctx, &sts.GetCallerIdentityInput{})
    if err != nil {
        return nil, sentinelerrors.WrapSTSError(err, "GetCallerIdentity")
    }

    // ... per-feature simulation ...
    output, err := c.iamClient.SimulatePrincipalPolicy(ctx, input)
    if err != nil {
        // Check if it's access denied
        if isAccessDeniedError(err) {
            result.Status = StatusError
            result.Message = sentinelerrors.GetSuggestion(sentinelerrors.ErrCodeIAMSimulateAccessDenied)
        } else {
            result.Status = StatusError
            result.Message = err.Error()
        }
        // Continue to next feature (don't fail entire check)
    }
    // ...
}
```

Add WrapSTSError to errors/suggestions.go:
```go
// WrapSTSError examines an STS error and returns a SentinelError
func WrapSTSError(err error, action string) SentinelError {
    if isAccessDenied(err) {
        return New(
            ErrCodeConfigMissingCredentials,
            fmt.Sprintf("STS %s failed: %v", action, err),
            "Ensure AWS credentials are configured. Check environment variables or ~/.aws/credentials",
            err,
        )
    }
    return New(
        "STS_ERROR",
        fmt.Sprintf("STS %s failed: %v", action, err),
        "",
        err,
    )
}
```
  </action>
  <verify>go build ./request ./permissions ./breakglass ./errors succeeds; go test ./request ./permissions -v passes</verify>
  <done>request/dynamodb.go wraps DynamoDB errors; breakglass/store.go wraps DynamoDB errors; permissions/checker.go provides better error messages for IAM simulation failures</done>
</task>

<task type="auto">
  <name>Task 3: Update credentials command and add CLI helper</name>
  <files>cli/credentials.go, cli/errors.go</files>
  <action>
**Create cli/errors.go with shared error formatting:**
```go
package cli

import (
    "fmt"
    "os"

    sentinelerrors "github.com/byteness/aws-vault/v7/errors"
)

// FormatErrorWithSuggestion writes error to stderr with suggestion if available.
// Returns the original error for chaining.
func FormatErrorWithSuggestion(err error) error {
    if err == nil {
        return nil
    }

    sentErr, ok := sentinelerrors.IsSentinelError(err)
    if ok {
        fmt.Fprintf(os.Stderr, "Error: %s\n", sentErr.Error())
        if suggestion := sentErr.Suggestion(); suggestion != "" {
            fmt.Fprintf(os.Stderr, "\nSuggestion: %s\n", suggestion)
        }
        if ctx := sentErr.Context(); len(ctx) > 0 {
            fmt.Fprintf(os.Stderr, "\nDetails:\n")
            for k, v := range ctx {
                fmt.Fprintf(os.Stderr, "  %s: %s\n", k, v)
            }
        }
    } else {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
    }
    return err
}

// FormatErrorWithSuggestionTo writes to a specific writer (for testing)
func FormatErrorWithSuggestionTo(w *os.File, err error) error {
    if err == nil {
        return nil
    }

    sentErr, ok := sentinelerrors.IsSentinelError(err)
    if ok {
        fmt.Fprintf(w, "Error: %s\n", sentErr.Error())
        if suggestion := sentErr.Suggestion(); suggestion != "" {
            fmt.Fprintf(w, "\nSuggestion: %s\n", suggestion)
        }
        if ctx := sentErr.Context(); len(ctx) > 0 {
            fmt.Fprintf(w, "\nDetails:\n")
            for k, v := range ctx {
                fmt.Fprintf(w, "  %s: %s\n", k, v)
            }
        }
    } else {
        fmt.Fprintf(w, "Error: %v\n", err)
    }
    return err
}
```

**Update cli/credentials.go to use structured errors:**

Similar to sentinel_exec.go, update error handling:
```go
// AWS config error
awsCfg, err := config.LoadDefaultConfig(ctx, awsCfgOpts...)
if err != nil {
    configErr := sentinelerrors.New(
        sentinelerrors.ErrCodeConfigMissingCredentials,
        fmt.Sprintf("Failed to load AWS config: %v", err),
        sentinelerrors.GetSuggestion(sentinelerrors.ErrCodeConfigMissingCredentials),
        err,
    )
    FormatErrorWithSuggestionTo(input.Stderr, configErr)
    return 1, configErr
}

// Policy load error
loadedPolicy, err := cachedLoader.Load(ctx, input.PolicyParameter)
if err != nil {
    FormatErrorWithSuggestionTo(input.Stderr, err)
    return 1, err
}

// Policy denial
if decision.Effect == policy.EffectDeny {
    // ... existing checks ...
    if approvedReq == nil && activeBreakGlass == nil {
        policyErr := sentinelerrors.NewPolicyDeniedError(
            username,
            input.ProfileName,
            decision.MatchedRule,
            input.Store != nil,
            input.BreakGlassStore != nil,
        )
        if logger != nil {
            entry := logging.NewDecisionLogEntry(policyRequest, decision, input.PolicyParameter)
            logger.LogDecision(entry)
        }
        FormatErrorWithSuggestionTo(input.Stderr, policyErr)
        return 1, policyErr
    }
}
```

**Update cli/sentinel_exec.go to use shared helper:**

Replace the local formatErrorWithSuggestion with FormatErrorWithSuggestion from cli/errors.go.
  </action>
  <verify>go build ./cli succeeds; go test ./cli -run TestCredentials -v passes; go test ./cli -run TestSentinelExec -v passes</verify>
  <done>cli/errors.go provides shared error formatting; cli/credentials.go uses structured errors; cli/sentinel_exec.go uses shared helper</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./errors -v` passes
- [ ] `go test ./policy -v` passes
- [ ] `go test ./cli -v` passes
- [ ] `go test ./request -v` passes
- [ ] `go test ./permissions -v` passes
- [ ] SSM access denied shows suggestion about ssm:GetParameter
- [ ] DynamoDB access denied shows suggestion about DynamoDB permissions
- [ ] Policy denial shows matched rule and available alternatives
</verification>

<success_criteria>
- All tasks completed
- Error handling integrated into policy loader
- Error handling integrated into DynamoDB stores
- Error handling integrated into permissions checker
- CLI commands display suggestions alongside errors
- Existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/65-error-enhancement/65-02-SUMMARY.md`
</output>
