---
phase: 133-rate-limit-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [ratelimit/dynamodb.go, ratelimit/dynamodb_test.go]
autonomous: true
---

<objective>
Implement DynamoDB-backed rate limiter for distributed rate limiting across Lambda instances.

Purpose: The current MemoryRateLimiter doesn't work across Lambda instances (each has its own memory). Lambda horizontal scaling and cold starts allow attackers to bypass rate limits by hitting different instances. DynamoDB provides shared state for consistent rate limiting.

Output: DynamoDBRateLimiter implementing the RateLimiter interface with atomic counters and TTL-based expiration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing rate limiter interface to implement
@ratelimit/types.go

# Reference: existing memory implementation (sliding window pattern)
@ratelimit/memory.go

# Reference: DynamoDB patterns from session store
@session/dynamodb.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DynamoDB rate limiter types and table schema</name>
  <files>ratelimit/dynamodb.go</files>
  <action>
Create DynamoDBRateLimiter implementing the RateLimiter interface:

```go
// DynamoDBRateLimiter implements RateLimiter using DynamoDB for distributed rate limiting.
// Uses atomic UpdateItem with ADD to increment counters safely across Lambda instances.
type DynamoDBRateLimiter struct {
    client    DynamoDBAPI  // Interface for testability
    tableName string
    config    Config
}

// DynamoDBAPI defines the DynamoDB operations needed for rate limiting.
type DynamoDBAPI interface {
    UpdateItem(ctx context.Context, params *dynamodb.UpdateItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.UpdateItemOutput, error)
}
```

Table schema (single-table design like session/breakglass):
- PK: "RL#" + key (e.g., "RL#arn:aws:iam::123456789012:user/alice")
- WindowStart: ISO8601 timestamp of current window start
- Count: Number of requests in current window
- TTL: Unix timestamp for DynamoDB TTL (window end + buffer)

The Allow() method:
1. Calculate current window start time (floor to window boundary)
2. Use UpdateItem with condition: IF WindowStart matches current window THEN ADD 1 TO Count ELSE SET Count=1, WindowStart=current
3. Check if returned Count > limit
4. Return (allowed, retryAfter, error)

Key implementation details:
- Use ADD expression for atomic increment (prevents race conditions)
- Use condition expression for window rollover
- Calculate TTL = window end + 1 hour buffer for cleanup
- Fail-open on DynamoDB errors (availability over strict limiting)
- Log warnings on errors but don't fail the request

Do NOT use transactions - single UpdateItem with conditions is sufficient and cheaper.
  </action>
  <verify>go build ./ratelimit/... compiles without errors</verify>
  <done>DynamoDBRateLimiter struct and NewDynamoDBRateLimiter constructor exist, implement RateLimiter interface</done>
</task>

<task type="auto">
  <name>Task 2: Implement Allow() with atomic DynamoDB operations</name>
  <files>ratelimit/dynamodb.go</files>
  <action>
Implement the Allow() method using UpdateItem with atomic ADD operation:

```go
func (r *DynamoDBRateLimiter) Allow(ctx context.Context, key string) (bool, time.Duration, error) {
    now := time.Now()
    windowStart := now.Truncate(r.config.Window)
    windowStartStr := windowStart.Format(time.RFC3339)
    ttl := windowStart.Add(r.config.Window).Add(time.Hour).Unix() // TTL = window end + 1 hour

    pk := "RL#" + key

    // Use UpdateItem with condition for atomic increment or window reset
    input := &dynamodb.UpdateItemInput{
        TableName: &r.tableName,
        Key: map[string]types.AttributeValue{
            "PK": &types.AttributeValueMemberS{Value: pk},
        },
        UpdateExpression: aws.String("SET #count = if_not_exists(#count, :zero) + :one, #ws = if_not_exists(#ws, :ws), #ttl = :ttl"),
        ConditionExpression: aws.String("attribute_not_exists(#ws) OR #ws = :ws"),
        ExpressionAttributeNames: map[string]string{
            "#count": "Count",
            "#ws":    "WindowStart",
            "#ttl":   "TTL",
        },
        ExpressionAttributeValues: map[string]types.AttributeValue{
            ":zero": &types.AttributeValueMemberN{Value: "0"},
            ":one":  &types.AttributeValueMemberN{Value: "1"},
            ":ws":   &types.AttributeValueMemberS{Value: windowStartStr},
            ":ttl":  &types.AttributeValueMemberN{Value: strconv.FormatInt(ttl, 10)},
        },
        ReturnValues: types.ReturnValueAllNew,
    }

    output, err := r.client.UpdateItem(ctx, input)
    if err != nil {
        // Check for condition check failure - means window rolled over
        var ccf *types.ConditionalCheckFailedException
        if errors.As(err, &ccf) {
            // Window changed - retry with new window (reset count to 1)
            return r.resetAndIncrement(ctx, key, now)
        }
        // Other DynamoDB error - fail open with warning
        return true, 0, err
    }

    // Parse count from response
    count := parseCount(output.Attributes["Count"])

    limit := r.config.EffectiveBurstSize()
    if count > limit {
        retryAfter := windowStart.Add(r.config.Window).Sub(now)
        return false, retryAfter, nil
    }

    return true, 0, nil
}
```

Handle the window rollover case with a separate resetAndIncrement() helper that unconditionally sets Count=1 with new WindowStart.

Ensure error handling follows fail-open pattern (log warning, return allowed=true).
  </action>
  <verify>go build ./ratelimit/... compiles; go vet ./ratelimit/... passes</verify>
  <done>Allow() method implements atomic increment with window handling and fail-open error policy</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests with mock DynamoDB client</name>
  <files>ratelimit/dynamodb_test.go</files>
  <action>
Create comprehensive unit tests using a mock DynamoDB client:

1. TestDynamoDBRateLimiter_AllowUnderLimit - first requests under limit are allowed
2. TestDynamoDBRateLimiter_AllowAtLimit - request at limit is denied
3. TestDynamoDBRateLimiter_WindowRollover - new window resets count
4. TestDynamoDBRateLimiter_FailOpenOnError - DynamoDB errors return allowed=true with error
5. TestDynamoDBRateLimiter_RetryAfterCalculation - verify retry-after is accurate
6. TestDynamoDBRateLimiter_ConcurrentRequests - verify atomic operations work (mock verifies UpdateItem called)
7. TestDynamoDBRateLimiter_KeyFormat - verify PK format is "RL#" + key
8. TestDynamoDBRateLimiter_TTLCalculation - verify TTL is set correctly

Create mockDynamoDBClient that implements DynamoDBAPI:
```go
type mockDynamoDBClient struct {
    updateItemFn func(ctx context.Context, input *dynamodb.UpdateItemInput) (*dynamodb.UpdateItemOutput, error)
    calls        []mockCall
}
```

Use the mock to simulate various DynamoDB responses and errors.
  </action>
  <verify>go test ./ratelimit/... -v -run DynamoDB passes all tests</verify>
  <done>Unit tests cover happy path, limit enforcement, window rollover, fail-open, and key format</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./ratelimit/...` succeeds
- [ ] `go test ./ratelimit/... -v` passes all tests
- [ ] `go vet ./ratelimit/...` passes
- [ ] DynamoDBRateLimiter implements RateLimiter interface (compiler verifies)
</verification>

<success_criteria>

- DynamoDBRateLimiter created with atomic UpdateItem operations
- Allow() implements sliding window with atomic increment
- Fail-open on DynamoDB errors (availability over strict limiting)
- Window rollover handled correctly
- Unit tests verify all behaviors
- No changes to existing MemoryRateLimiter (both implementations available)
</success_criteria>

<output>
After completion, create `.planning/phases/133-rate-limit-hardening/133-01-SUMMARY.md`
</output>
