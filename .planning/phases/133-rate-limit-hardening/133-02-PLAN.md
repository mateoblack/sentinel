---
phase: 133-rate-limit-hardening
plan: 02
type: execute
wave: 2
depends_on: ["133-01"]
files_modified: [lambda/config.go, lambda/handler_test.go, ratelimit/security_test.go]
autonomous: true
---

<objective>
Integrate DynamoDB rate limiter into Lambda TVM and add security regression tests.

Purpose: Replace in-memory rate limiter in Lambda with DynamoDB-backed implementation for consistent rate limiting across all Lambda instances. Add security tests to verify bypass attacks are prevented.

Output: Lambda TVM uses DynamoDB rate limiter when table is configured; security tests verify distributed rate limiting works.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan output
@.planning/phases/133-rate-limit-hardening/133-01-SUMMARY.md

# Lambda config to modify
@lambda/config.go

# Existing rate limiter integration
@lambda/handler.go

# Security test patterns
@ratelimit/security_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DynamoDB rate limiter configuration to Lambda</name>
  <files>lambda/config.go</files>
  <action>
Add environment variable and configuration for DynamoDB rate limiting:

1. Add new environment variable constant:
```go
const (
    // EnvRateLimitTable is the DynamoDB table for distributed rate limiting.
    // If set, uses DynamoDB instead of in-memory rate limiting.
    // Table must have PK (string), TTL attribute named "TTL".
    EnvRateLimitTable = "SENTINEL_RATE_LIMIT_TABLE"
)
```

2. Add field to TVMConfig:
```go
// RateLimitTableName is the DynamoDB table for distributed rate limiting.
// If set, uses DynamoDB rate limiter instead of in-memory.
// Required for consistent rate limiting across Lambda instances.
RateLimitTableName string
```

3. In LoadConfigFromEnv(), update rate limiter creation logic:
```go
// Configure rate limiting
rateLimitRequests := DefaultRateLimitRequests
// ... existing parsing ...

// Create rate limiter if enabled
if rateLimitRequests > 0 {
    rateLimitTable := os.Getenv(EnvRateLimitTable)
    if rateLimitTable != "" {
        // Use DynamoDB for distributed rate limiting
        cfg.RateLimitTableName = rateLimitTable
        limiter, err := ratelimit.NewDynamoDBRateLimiter(awsCfg, rateLimitTable, ratelimit.Config{
            RequestsPerWindow: rateLimitRequests,
            Window:            rateLimitWindow,
        })
        if err != nil {
            return nil, fmt.Errorf("failed to create DynamoDB rate limiter: %w", err)
        }
        cfg.RateLimiter = limiter
        log.Printf("INFO: Distributed rate limiting enabled: %d requests per %v (table: %s)",
            rateLimitRequests, rateLimitWindow, rateLimitTable)
    } else {
        // Fall back to in-memory (single instance only - NOT recommended for Lambda)
        limiter, err := ratelimit.NewMemoryRateLimiter(ratelimit.Config{...})
        // ... existing code ...
        log.Printf("WARNING: Using in-memory rate limiting - not effective across Lambda instances. Set %s for distributed rate limiting.",
            EnvRateLimitTable)
    }
}
```

Key: Log a WARNING when using in-memory rate limiting in Lambda, since it's ineffective for distributed scenarios.
  </action>
  <verify>go build ./lambda/... compiles without errors</verify>
  <done>Lambda config supports SENTINEL_RATE_LIMIT_TABLE for DynamoDB rate limiter, warns when using memory limiter</done>
</task>

<task type="auto">
  <name>Task 2: Add Lambda handler integration tests for distributed rate limiting</name>
  <files>lambda/handler_test.go</files>
  <action>
Add test cases that verify the Lambda handler correctly uses the rate limiter:

1. TestHandler_RateLimitWithDynamoDB - verify DynamoDB rate limiter is used when configured
2. TestHandler_RateLimitFallbackToMemory - verify memory rate limiter is used when table not configured

For test setup, inject a mock DynamoDB rate limiter via TVMConfig.RateLimiter:
```go
func TestHandler_RateLimitEnforced(t *testing.T) {
    // Create mock rate limiter that denies after N requests
    mockLimiter := &mockRateLimiter{
        allowedCount: 5,
        currentCount: 0,
    }

    cfg := &TVMConfig{
        RateLimiter: mockLimiter,
        // ... other config ...
    }

    handler := NewHandler(cfg)

    // First 5 requests should succeed
    for i := 0; i < 5; i++ {
        resp, _ := handler.HandleRequest(ctx, validRequest)
        if resp.StatusCode == http.StatusTooManyRequests {
            t.Errorf("Request %d should be allowed", i+1)
        }
    }

    // 6th request should be rate limited
    resp, _ := handler.HandleRequest(ctx, validRequest)
    if resp.StatusCode != http.StatusTooManyRequests {
        t.Errorf("Request 6 should be rate limited")
    }
}
```

Also test that the rate limiter key is the caller's IAM ARN (not IP), since IAM auth identifies the caller.
  </action>
  <verify>go test ./lambda/... -v -run RateLimit passes</verify>
  <done>Integration tests verify rate limiting is enforced in Lambda handler with correct key (IAM ARN)</done>
</task>

<task type="auto">
  <name>Task 3: Add security regression tests for distributed rate limiting</name>
  <files>ratelimit/security_test.go</files>
  <action>
Add security regression tests to verify distributed rate limiting prevents bypass attacks:

1. TestSecurityRegression_DynamoDBAtomicIncrement - verify UpdateItem with ADD is atomic
```go
// THREAT: Race condition in distributed increment could allow limit bypass.
// PREVENTION: Use DynamoDB atomic ADD operation, not read-modify-write.
func TestSecurityRegression_DynamoDBAtomicIncrement(t *testing.T) {
    // Verify that DynamoDBRateLimiter uses UpdateItem with ADD expression
    // (not GetItem/PutItem pattern which has race conditions)

    mock := &captureMockDynamoDB{}
    limiter := &DynamoDBRateLimiter{
        client:    mock,
        tableName: "test-table",
        config:    Config{RequestsPerWindow: 10, Window: time.Minute},
    }

    limiter.Allow(context.Background(), "test-key")

    // Verify UpdateItem was called (not GetItem + PutItem)
    if mock.updateItemCalled == 0 {
        t.Error("SECURITY VIOLATION: Must use UpdateItem for atomic increment")
    }
    if mock.getItemCalled > 0 || mock.putItemCalled > 0 {
        t.Error("SECURITY VIOLATION: Must NOT use GetItem/PutItem pattern (race condition)")
    }
}
```

2. TestSecurityRegression_DynamoDBFailOpen - verify fail-open doesn't block legitimate requests
```go
// THREAT: DynamoDB outage could block all credential requests.
// PREVENTION: Fail-open on DynamoDB errors (availability over strict limiting).
func TestSecurityRegression_DynamoDBFailOpen(t *testing.T) {
    mock := &errorMockDynamoDB{err: errors.New("DynamoDB unavailable")}
    limiter := &DynamoDBRateLimiter{...}

    allowed, _, err := limiter.Allow(context.Background(), "test-key")

    // Should return allowed=true with error (fail-open)
    if !allowed {
        t.Error("SECURITY VIOLATION: DynamoDB errors must fail-open, not block requests")
    }
    if err == nil {
        t.Error("Error should be returned for logging (but allowed=true)")
    }
}
```

3. TestSecurityRegression_KeyIsolation - verify different ARNs have separate limits
```go
// THREAT: Shared rate limit buckets could cause DoS across users.
// PREVENTION: Rate limit key includes full IAM ARN for isolation.
func TestSecurityRegression_KeyIsolation(t *testing.T) {
    // Two different users should have independent rate limits
    // Verify key format includes unique identifier
}
```

Follow existing security test patterns in ratelimit/security_test.go (TestSecurity_* prefix for functional tests, TestSecurityRegression_* for attack prevention tests).
  </action>
  <verify>go test ./ratelimit/... -v -run SecurityRegression passes</verify>
  <done>Security regression tests verify atomic operations, fail-open behavior, and key isolation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./lambda/... ./ratelimit/...` succeeds
- [ ] `go test ./lambda/... -v` passes all tests
- [ ] `go test ./ratelimit/... -v` passes all tests including security regression
- [ ] `go vet ./lambda/... ./ratelimit/...` passes
</verification>

<success_criteria>

- Lambda TVM uses DynamoDB rate limiter when SENTINEL_RATE_LIMIT_TABLE is set
- Warning logged when using in-memory rate limiter (ineffective for Lambda)
- Integration tests verify rate limiting is enforced in Lambda handler
- Security regression tests verify:
  - Atomic increment operations (no read-modify-write race)
  - Fail-open on DynamoDB errors
  - Key isolation between different IAM ARNs
</success_criteria>

<output>
After completion, create `.planning/phases/133-rate-limit-hardening/133-02-SUMMARY.md`
</output>
