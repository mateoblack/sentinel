---
phase: 67-quick-start-templates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [config/template.go, config/template_test.go, cli/config.go, cli/config_test.go]
autonomous: true
---

<objective>
Create pre-built configuration templates (basic, approvals, full) with CLI command to generate complete Sentinel configs for common use cases.

Purpose: Enable users to quickly bootstrap Sentinel with production-ready configurations instead of building from scratch.
Output: Template generator package and `sentinel config generate --template X` CLI command.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 66 established config validation patterns
@config/types.go
@config/validator.go

# Existing generator pattern from bootstrap
@bootstrap/generator.go

# CLI config command to extend
@cli/config.go

# Policy types for template generation
@policy/types.go
@policy/approval.go
@breakglass/policy.go
@breakglass/ratelimit.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template types and generators</name>
  <files>config/template.go, config/template_test.go</files>
  <action>
Create template package with:

1. **TemplateID type** (string alias):
   - TemplateBasic = "basic"
   - TemplateApprovals = "approvals"
   - TemplateFull = "full"
   - IsValid() and String() methods
   - AllTemplateIDs() function

2. **Template struct**:
   ```go
   type Template struct {
       ID          TemplateID
       Name        string
       Description string
       Features    []string  // Features this template requires (for permissions)
   }
   ```

3. **Template registry**:
   - GetTemplate(id TemplateID) (Template, bool)
   - AllTemplates() []Template

4. **TemplateOutput struct**:
   ```go
   type TemplateOutput struct {
       Policy      string // Access policy YAML
       Approval    string // Approval policy YAML (empty for basic)
       BreakGlass  string // Break-glass policy YAML (empty for basic/approvals)
       RateLimit   string // Rate limit policy YAML (empty for basic/approvals)
   }
   ```

5. **Generator function**:
   - GenerateTemplate(id TemplateID, profiles []string, users []string) (*TemplateOutput, error)
   - Validates inputs (at least one profile, at least one user for approval/full)
   - Generates valid YAML for each config type

**Template contents:**

**basic** - Simple allow policy:
```yaml
version: "1"
rules:
  - name: allow-configured-profiles
    effect: allow
    conditions:
      profiles: [profile1, profile2]
    reason: Access allowed for configured profiles
  - name: default-deny
    effect: deny
    reason: Profile not configured for Sentinel access
```

**approvals** - Policy with require_approval + approval policy:
- Access policy: effect=require_approval for listed profiles, default deny
- Approval policy: users as approvers, business hours auto-approve

**full** - Complete enterprise setup:
- Access policy: require_approval
- Approval policy: with auto-approve during business hours
- Break-glass policy: users authorized for emergency access
- Rate limit policy: 30m cooldown, 3/user/24h, 10/profile/24h

Use yaml.v3 encoder with 2-space indent. Include header comments with profile names and generation timestamp (follow bootstrap/generator.go pattern).
  </action>
  <verify>go test ./config/... -run Template -v passes all tests</verify>
  <done>TemplateID type, Template registry, GenerateTemplate function producing valid YAML for all three template types</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI config generate command</name>
  <files>cli/config.go, cli/config_test.go</files>
  <action>
Extend cli/config.go to add `generate` subcommand under existing `config` command:

1. **ConfigGenerateCommandInput struct**:
   ```go
   type ConfigGenerateCommandInput struct {
       Template    string   // basic, approvals, full
       Profiles    []string // AWS profiles to include
       Users       []string // Users for approvers/break-glass (required for approvals/full)
       OutputDir   string   // Directory to write files (empty = stdout)
       JSONOutput  bool     // Output as JSON instead of YAML files
       Stdout      *os.File
       Stderr      *os.File
   }
   ```

2. **CLI registration** (add to ConfigureConfigCommand):
   ```
   sentinel config generate --template basic|approvals|full --profile dev --profile prod [--user alice --user bob] [--output-dir ./policies] [--json]
   ```
   - --template required, enum validated
   - --profile required, repeatable
   - --user optional for basic, required for approvals/full
   - --output-dir optional (if omitted, write to stdout)
   - --json optional (output TemplateOutput as JSON)

3. **Command logic**:
   - Validate template ID
   - Validate users provided if template requires them
   - Call config.GenerateTemplate()
   - If --output-dir: write files (policy.yaml, approval.yaml, breakglass.yaml, ratelimit.yaml) - skip empty ones
   - If --json: marshal TemplateOutput to JSON
   - If neither: print each non-empty config to stdout with section headers

4. **Output format** (human, no --output-dir, no --json):
   ```
   # Access Policy (policy.yaml)
   # ============================
   [YAML content]

   # Approval Policy (approval.yaml)
   # ===============================
   [YAML content]
   ```

5. **Output format** (--output-dir):
   ```
   Generated 4 config files in ./policies:
     + policy.yaml
     + approval.yaml
     + breakglass.yaml
     + ratelimit.yaml
   ```

Add tests for:
- Basic template generation (no users required)
- Approvals template (users required, error if missing)
- Full template generation
- JSON output format
- File output to directory
- Invalid template ID error
  </action>
  <verify>go test ./cli/... -run ConfigGenerate -v passes; sentinel config generate --template basic --profile dev outputs valid YAML</verify>
  <done>sentinel config generate command working with all three templates, file output, and JSON output options</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./config/... -v` passes (template tests)
- [ ] `go test ./cli/... -run Config -v` passes (config command tests)
- [ ] `go vet ./...` passes
- [ ] Generated configs pass validation: `sentinel config validate --type policy < generated.yaml`
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- TemplateID type with basic, approvals, full values
- Template registry with metadata for each template
- GenerateTemplate function producing valid YAML
- CLI command `sentinel config generate --template X --profile Y` working
- Generated configs validate successfully with `sentinel config validate`
</success_criteria>

<output>
After completion, create `.planning/phases/67-quick-start-templates/67-01-SUMMARY.md`
</output>
