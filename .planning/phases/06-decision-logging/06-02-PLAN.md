---
phase: 06-decision-logging
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified: [cli/credentials.go, logging/logger.go, logging/logger_test.go]
autonomous: true
---

<objective>
Add log destination configuration to credentials command.

Purpose: Users need to configure where decision logs are written - stderr for debugging, file for audit trails, or disabled entirely.
Output: CLI flags for log destination, file logger support, and tests for logging paths.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-decision-logging/06-01-SUMMARY.md

@logging/logger.go
@logging/decision.go
@cli/credentials.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add log destination flags to credentials command</name>
  <files>cli/credentials.go</files>
  <action>
Add logging configuration flags to CredentialsCommandInput:

1. Add fields:
   ```go
   LogFile   string // Path to log file (empty = no file logging)
   LogStderr bool   // Log to stderr (default: false)
   ```

2. Add flags in ConfigureCredentialsCommand:
   ```go
   cmd.Flag("log-file", "Path to write decision logs (JSON Lines format)").
       StringVar(&input.LogFile)

   cmd.Flag("log-stderr", "Write decision logs to stderr").
       BoolVar(&input.LogStderr)
   ```

3. In CredentialsCommand, before policy evaluation, create appropriate logger:
   ```go
   // Create logger based on configuration
   var logger logging.Logger
   if input.LogFile != "" || input.LogStderr {
       writers := []io.Writer{}
       if input.LogStderr {
           writers = append(writers, os.Stderr)
       }
       if input.LogFile != "" {
           f, err := os.OpenFile(input.LogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
           if err != nil {
               fmt.Fprintf(os.Stderr, "Failed to open log file: %v\n", err)
               return err
           }
           defer f.Close()
           writers = append(writers, f)
       }
       logger = logging.NewJSONLogger(io.MultiWriter(writers...))
   }
   input.Logger = logger
   ```

Note: Use io.MultiWriter from standard library for multiple destinations.
  </action>
  <verify>go build ./cmd/sentinel/... && sentinel credentials --help shows --log-file and --log-stderr flags</verify>
  <done>Log destination flags added and parsed, logger created based on configuration</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for logger and decision log entry</name>
  <files>logging/logger_test.go, logging/decision_test.go</files>
  <action>
Create tests for logging package:

**logging/logger_test.go:**
1. TestJSONLogger_LogDecision - verify JSON output format
   - Create JSONLogger with bytes.Buffer
   - Log a DecisionLogEntry
   - Verify output is valid JSON with expected fields
   - Verify newline-terminated (JSON Lines format)

2. TestNopLogger_LogDecision - verify no output
   - Create NopLogger
   - Log entry, verify no panic

**logging/decision_test.go:**
3. TestNewDecisionLogEntry_Allow - verify allow decision fields
   - Create Request and Decision for allow case
   - Call NewDecisionLogEntry
   - Verify all fields populated correctly

4. TestNewDecisionLogEntry_Deny - verify deny decision fields
   - Create Request and Decision for deny case (default deny)
   - Call NewDecisionLogEntry
   - Verify rule is empty, rule_index is -1

Follow existing test patterns in policy/*_test.go files.
  </action>
  <verify>go test ./logging/... -v</verify>
  <done>All tests pass, logger and decision entry functionality verified</done>
</task>

<task type="auto">
  <name>Task 3: Add integration test for credentials logging</name>
  <files>cli/credentials_test.go</files>
  <action>
Add test to verify logging integration in credentials command:

1. TestCredentialsCommand_LogsDecision:
   - Create a mock/test scenario where we can verify logging occurs
   - Use bytes.Buffer as log destination
   - Verify log entry contains expected fields

Note: This may require creating a test helper or using the existing test patterns from cli/credentials_test.go.

If full integration test is complex due to SSM dependency, create a simpler unit test that:
- Tests the logging code path with a mock Logger
- Verifies LogDecision is called with correct entry

Keep test focused on logging, not full credential flow (that's tested elsewhere).
  </action>
  <verify>go test ./cli/... -v -run TestCredentials</verify>
  <done>Logging integration verified in credentials command tests</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./...` passes
- [ ] `go vet ./...` passes
- [ ] --log-file and --log-stderr flags work
- [ ] Multiple destinations work via MultiWriter
- [ ] JSON Lines format correct (one JSON object per line)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Log destination configurable via CLI flags
- File logging appends to existing file
- Multiple destinations supported simultaneously
- Tests cover logger, decision entry, and integration
</success_criteria>

<output>
After completion, create `.planning/phases/06-decision-logging/06-02-SUMMARY.md`
</output>
