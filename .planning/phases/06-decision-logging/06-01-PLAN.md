---
phase: 06-decision-logging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [logging/logger.go, logging/decision.go, cli/credentials.go]
autonomous: true
---

<objective>
Create structured logging infrastructure for decision logging.

Purpose: Every access decision (allow/deny) must be logged with full context for audit trails and debugging. This creates the logging package and integrates it into the credentials command.
Output: logging package with JSON logger, decision log entry formatting, and credentials command integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-credential-process/05-01-SUMMARY.md
@.planning/phases/05-credential-process/05-02-SUMMARY.md

@policy/evaluate.go
@policy/types.go
@cli/credentials.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logging package with Logger interface and JSON implementation</name>
  <files>logging/logger.go</files>
  <action>
Create new `logging` package with:

1. `Logger` interface with single method: `LogDecision(entry DecisionLogEntry)`
2. `JSONLogger` struct implementing Logger:
   - Constructor `NewJSONLogger(w io.Writer) *JSONLogger`
   - LogDecision writes JSON-encoded entry to writer, one line per entry (JSON Lines format)
   - Use json.Marshal (not MarshalIndent) for single-line entries suitable for log aggregation
3. `NopLogger` for testing/disabled logging:
   - `NewNopLogger() *NopLogger` returns logger that discards all entries

Follow existing codebase patterns:
- Package doc comment at top
- PascalCase for exported types
- No external dependencies (use standard library only)
  </action>
  <verify>go build ./logging/... compiles without errors</verify>
  <done>Logger interface defined, JSONLogger and NopLogger implementations working</done>
</task>

<task type="auto">
  <name>Task 2: Create DecisionLogEntry struct and formatting</name>
  <files>logging/decision.go</files>
  <action>
Create `DecisionLogEntry` struct capturing all decision context:

```go
type DecisionLogEntry struct {
    Timestamp   string `json:"timestamp"`    // ISO8601 format
    User        string `json:"user"`
    Profile     string `json:"profile"`
    Effect      string `json:"effect"`       // "allow" or "deny"
    Rule        string `json:"rule"`         // Matched rule name (empty if default deny)
    RuleIndex   int    `json:"rule_index"`   // -1 if no match
    Reason      string `json:"reason"`       // Rule's reason or "no matching rule"
    PolicyPath  string `json:"policy_path"`  // SSM parameter path
}
```

Create helper function `NewDecisionLogEntry(req *policy.Request, decision policy.Decision, policyPath string) DecisionLogEntry`:
- Converts policy.Request and policy.Decision to log entry
- Uses iso8601.Format for timestamp (import from existing iso8601 package)
- Handles all fields including default deny case

Follow existing patterns in policy/ package for struct design.
  </action>
  <verify>go build ./logging/... compiles without errors</verify>
  <done>DecisionLogEntry struct defined with all required fields, NewDecisionLogEntry helper working</done>
</task>

<task type="auto">
  <name>Task 3: Integrate logging into credentials command</name>
  <files>cli/credentials.go</files>
  <action>
Modify CredentialsCommand to log every decision:

1. Add Logger field to CredentialsCommandInput:
   ```go
   Logger logging.Logger // nil means no logging
   ```

2. After policy evaluation (line 110), log the decision:
   ```go
   if input.Logger != nil {
       entry := logging.NewDecisionLogEntry(policyRequest, decision, input.PolicyParameter)
       input.Logger.LogDecision(entry)
   }
   ```

3. Log BEFORE handling the decision (both allow and deny get logged)

4. Do NOT add CLI flags yet (that's plan 06-02) - Logger will be nil by default

Important: Log entry is created after evaluation but before acting on result, so both allow and deny are logged.
  </action>
  <verify>go build ./cli/... && go build ./cmd/sentinel/...</verify>
  <done>Credentials command logs decisions when Logger is provided, nil Logger skips logging silently</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go vet ./...` passes
- [ ] logging package has Logger interface, JSONLogger, NopLogger
- [ ] DecisionLogEntry captures all decision fields
- [ ] CredentialsCommandInput has Logger field
- [ ] Logging integrated at correct point in credential flow
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Logger interface allows different backends
- Decision logging captures user, profile, effect, rule, reason, timestamp, policy path
</success_criteria>

<output>
After completion, create `.planning/phases/06-decision-logging/06-01-SUMMARY.md`
</output>
