---
phase: 129-local-server-security
plan: 04
type: execute
wave: 3
depends_on: ["129-02"]
files_modified: [server/ecsserver.go, server/ecsserver_unix.go, server/ec2server.go, server/security_test.go]
autonomous: true
---

<objective>
Add Unix socket mode to ECS/EC2 credential servers and create security regression tests.

Purpose: Extend process-based authentication to all local credential servers (ECS, EC2) and verify security properties through comprehensive regression tests.

Output: ECS/EC2 servers with optional Unix socket mode and security test suite.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/129-local-server-security/129-02-SUMMARY.md

# Server infrastructure
@server/peercred.go
@server/process_auth.go
@server/unix_server.go

# Current ECS/EC2 servers to extend
@server/ecsserver.go
@server/ec2server.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Unix socket mode to EcsServer</name>
  <files>server/ecsserver_unix.go</files>
  <action>
Create Unix socket factory for EcsServer:

```go
//go:build linux || darwin

package server

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "path/filepath"

    "github.com/aws/aws-sdk-go-v2/aws"
    "github.com/byteness/aws-vault/v7/vault"
)

// NewEcsServerUnix creates an EcsServer using Unix domain sockets
// with process-based authentication.
func NewEcsServerUnix(ctx context.Context, baseCredsProvider aws.CredentialsProvider, config *vault.ProfileConfig, socketPath string, socketMode os.FileMode, lazyLoadBaseCreds bool) (*EcsServer, error) {
    // Determine socket path
    if socketPath == "" {
        socketPath = filepath.Join(os.TempDir(), fmt.Sprintf("ecs-creds-%d.sock", os.Getpid()))
    }

    // Determine socket mode
    if socketMode == 0 {
        socketMode = 0600
    }

    // Create process authenticator
    processAuth := NewProcessAuthenticator()

    // Generate token bound to current user (PID binding happens on first use)
    currentUID := uint32(os.Getuid())
    token, err := processAuth.GenerateToken(0, currentUID, false)
    if err != nil {
        return nil, fmt.Errorf("failed to generate process token: %w", err)
    }

    // Pre-fetch credentials if not lazy loading
    credsCache := aws.NewCredentialsCache(baseCredsProvider)
    if !lazyLoadBaseCreds {
        _, err := credsCache.Retrieve(ctx)
        if err != nil {
            return nil, fmt.Errorf("Retrieving creds: %w", err)
        }
    }

    e := &EcsServer{
        authToken:         token.Token,
        baseCredsProvider: credsCache,
        config:            config,
        processAuth:       processAuth,
    }

    // Create router with credential routes
    router := http.NewServeMux()
    router.HandleFunc("/", e.DefaultRoute)
    router.HandleFunc("/role-arn/", e.AssumeRoleArnRoute)

    // Wrap with process authentication
    authedHandler := WithProcessAuth(processAuth, router)

    // Wrap with logging
    loggedHandler := withLogging(authedHandler)

    // Create Unix server
    unixConfig := UnixServerConfig{
        SocketPath:    socketPath,
        SocketMode:    socketMode,
        Handler:       loggedHandler,
        AllowFallback: false,
        BoundUID:      currentUID,
    }

    unixServer, err := NewUnixServer(ctx, unixConfig)
    if err != nil {
        return nil, fmt.Errorf("failed to create Unix server: %w", err)
    }

    e.unixServer = unixServer
    e.listener = nil // Not used in Unix mode

    return e, nil
}
```

Update EcsServer struct to add fields (in ecsserver.go):

```go
type EcsServer struct {
    listener          net.Listener
    authToken         string
    server            http.Server
    cache             sync.Map
    baseCredsProvider aws.CredentialsProvider
    config            *vault.ProfileConfig

    // Unix socket mode fields
    unixServer  *UnixServer
    processAuth *ProcessAuthenticator
}
```

Add methods to EcsServer:

```go
// ServeUnix starts serving on the Unix domain socket. This call blocks.
func (e *EcsServer) ServeUnix() error {
    if e.unixServer == nil {
        return fmt.Errorf("Unix server not initialized - use NewEcsServerUnix")
    }
    return e.unixServer.Serve()
}

// ShutdownUnix gracefully shuts down the Unix socket server.
func (e *EcsServer) ShutdownUnix(ctx context.Context) error {
    if e.unixServer == nil {
        return nil
    }
    return e.unixServer.Shutdown(ctx)
}

// UnixSocketPath returns the path to the Unix socket.
func (e *EcsServer) UnixSocketPath() string {
    if e.unixServer == nil {
        return ""
    }
    return e.unixServer.SocketPath()
}

// IsUnixMode returns true if the server is using Unix domain sockets.
func (e *EcsServer) IsUnixMode() bool {
    return e.unixServer != nil
}
```
  </action>
  <verify>go build ./server/...</verify>
  <done>EcsServer has Unix socket mode</done>
</task>

<task type="auto">
  <name>Task 2: Document EC2 server security limitations</name>
  <files>server/ec2server.go</files>
  <action>
The EC2 metadata server has different security requirements - it emulates the EC2 metadata endpoint at 169.254.169.254, which is accessed by the AWS SDK without authentication tokens. It already has security checks for loopback and host verification.

Add documentation about security limitations:

```go
// SECURITY NOTE: EC2 Metadata Server Limitations
//
// The EC2 metadata server emulates the EC2 Instance Metadata Service (IMDS)
// at 169.254.169.254. Unlike the ECS container credentials server:
//
// 1. NO TOKEN AUTHENTICATION: AWS SDKs expect IMDS to be unauthenticated.
//    The server relies on network-level security (loopback check, host check).
//
// 2. NO PROCESS AUTHENTICATION: Cannot use Unix sockets because SDKs expect
//    to connect to a specific IP address (169.254.169.254).
//
// 3. LOCAL PROCESS EXPOSURE: Any process on the local machine that can route
//    to the loopback interface can potentially access credentials.
//
// Security mitigations:
// - withSecurityChecks middleware validates loopback source and correct host
// - Credentials have short TTL (governed by session duration)
// - For higher security requirements, use SentinelServer with --server flag
//   or the Lambda TVM with --remote-server
//
// The EC2 metadata server is provided for legacy compatibility with tools that
// require IMDS emulation. For new deployments, prefer container credentials
// (ECS server) or SentinelServer which support token authentication.
```

Add this documentation comment before StartEc2CredentialsServer function.
  </action>
  <verify>go build ./server/...</verify>
  <done>EC2 server security limitations documented</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive security regression tests</name>
  <files>server/security_test.go</files>
  <action>
Create comprehensive security tests for all local credential servers:

```go
//go:build linux || darwin

package server

import (
    "context"
    "go/ast"
    "go/parser"
    "go/token"
    "net"
    "net/http"
    "os"
    "path/filepath"
    "testing"
    "time"
)

// =============================================================================
// THREAT: LOCAL CREDENTIAL THEFT
// Attack: Malicious local process intercepts bearer token or connects to server
// =============================================================================

// TestThreat_LocalCredentialTheft_SocketPermissions verifies that Unix sockets
// have restrictive permissions (owner only).
func TestThreat_LocalCredentialTheft_SocketPermissions(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "socket-perm-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    config := UnixServerConfig{
        SocketPath: socketPath,
        SocketMode: 0600, // Owner only
        Handler:    http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}),
        BoundUID:   uint32(os.Getuid()),
    }

    ctx := context.Background()
    server, err := NewUnixServer(ctx, config)
    if err != nil {
        t.Fatalf("failed to create server: %v", err)
    }
    defer server.Shutdown(ctx)

    info, err := os.Stat(socketPath)
    if err != nil {
        t.Fatalf("failed to stat socket: %v", err)
    }

    mode := info.Mode().Perm()
    if mode != 0600 {
        t.Errorf("SECURITY: Socket permissions should be 0600 (owner only), got %o", mode)
    }
}

// TestThreat_LocalCredentialTheft_WrongUIDRejected verifies that processes
// with different UID cannot use tokens bound to another user.
func TestThreat_LocalCredentialTheft_WrongUIDRejected(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "uid-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    pa := NewProcessAuthenticator()
    // Register token with a different UID than current process
    fakeUID := uint32(99999) // Unlikely to be our actual UID
    token := pa.RegisterToken("test-token", 0, fakeUID, false)

    done := make(chan bool)
    go func() {
        conn, err := listener.Accept()
        if err != nil {
            t.Errorf("accept failed: %v", err)
            done <- false
            return
        }
        defer conn.Close()

        req, _ := http.NewRequest("GET", "/", nil)
        req.Header.Set("Authorization", token.Token)

        _, err = pa.ValidateRequest(req, conn)
        if err == nil {
            t.Error("SECURITY: Token with wrong UID should be rejected")
            done <- false
            return
        }
        done <- true
    }()

    client, err := net.Dial("unix", socketPath)
    if err != nil {
        t.Fatalf("dial failed: %v", err)
    }
    client.Close()

    if !<-done {
        t.Error("UID validation test failed")
    }
}

// TestThreat_LocalCredentialTheft_WrongPIDRejected verifies that processes
// with different PID cannot use tokens bound to another process.
func TestThreat_LocalCredentialTheft_WrongPIDRejected(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "pid-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    pa := NewProcessAuthenticator()
    currentUID := uint32(os.Getuid())
    // Register token with a different PID than current process
    fakePID := int32(99999) // Unlikely to be our actual PID
    token := pa.RegisterToken("test-token", fakePID, currentUID, false)

    done := make(chan bool)
    go func() {
        conn, err := listener.Accept()
        if err != nil {
            t.Errorf("accept failed: %v", err)
            done <- false
            return
        }
        defer conn.Close()

        req, _ := http.NewRequest("GET", "/", nil)
        req.Header.Set("Authorization", token.Token)

        _, err = pa.ValidateRequest(req, conn)
        if err == nil {
            t.Error("SECURITY: Token with wrong PID should be rejected")
            done <- false
            return
        }
        done <- true
    }()

    client, err := net.Dial("unix", socketPath)
    if err != nil {
        t.Fatalf("dial failed: %v", err)
    }
    client.Close()

    if !<-done {
        t.Error("PID validation test failed")
    }
}

// =============================================================================
// THREAT: TOKEN BRUTE FORCE
// Attack: Attacker tries to guess or brute-force bearer tokens
// =============================================================================

// TestThreat_TokenBruteForce_ConstantTimeComparison verifies that token
// comparison uses constant-time algorithm to prevent timing attacks.
func TestThreat_TokenBruteForce_ConstantTimeComparison(t *testing.T) {
    // Parse EcsServer source to verify crypto/subtle usage
    files := []string{
        "ecsserver.go",
        "process_auth.go",
    }

    for _, file := range files {
        fset := token.NewFileSet()
        f, err := parser.ParseFile(fset, file, nil, parser.ImportsOnly)
        if err != nil {
            continue // File might not exist in all builds
        }

        hasSubtleImport := false
        for _, imp := range f.Imports {
            if imp.Path.Value == `"crypto/subtle"` {
                hasSubtleImport = true
                break
            }
        }

        if !hasSubtleImport {
            t.Errorf("SECURITY: %s should import crypto/subtle for constant-time comparison", file)
        }
    }
}

// TestThreat_TokenBruteForce_TokenLength verifies that generated tokens
// have sufficient entropy.
func TestThreat_TokenBruteForce_TokenLength(t *testing.T) {
    pa := NewProcessAuthenticator()
    token, err := pa.GenerateToken(0, 0, false)
    if err != nil {
        t.Fatalf("failed to generate token: %v", err)
    }

    // Token should be at least 32 bytes of entropy (256 bits)
    // Base64 encoding: 32 bytes = 43 characters
    if len(token.Token) < 40 {
        t.Errorf("SECURITY: Token too short (%d chars), should be at least 40 for 256-bit entropy", len(token.Token))
    }
}

// =============================================================================
// THREAT: SOCKET EXPOSURE
// Attack: Socket file left behind after crash, allowing later access
// =============================================================================

// TestThreat_SocketExposure_CleanupOnShutdown verifies that socket files
// are removed on graceful shutdown.
func TestThreat_SocketExposure_CleanupOnShutdown(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "cleanup-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    config := UnixServerConfig{
        SocketPath: socketPath,
        Handler:    http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}),
        BoundUID:   uint32(os.Getuid()),
    }

    ctx := context.Background()
    server, err := NewUnixServer(ctx, config)
    if err != nil {
        t.Fatalf("failed to create server: %v", err)
    }

    // Socket should exist
    if _, err := os.Stat(socketPath); os.IsNotExist(err) {
        t.Error("socket should exist after creation")
    }

    // Shutdown
    server.Shutdown(ctx)

    // Socket should be removed
    if _, err := os.Stat(socketPath); !os.IsNotExist(err) {
        t.Error("SECURITY: Socket should be removed after shutdown")
    }
}

// TestThreat_SocketExposure_RemoveExistingSocket verifies that stale sockets
// from previous runs are removed before creating new ones.
func TestThreat_SocketExposure_RemoveExistingSocket(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "stale-socket-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "stale.sock")

    // Create a stale socket file
    if err := os.WriteFile(socketPath, []byte("stale"), 0600); err != nil {
        t.Fatalf("failed to create stale socket: %v", err)
    }

    config := UnixServerConfig{
        SocketPath: socketPath,
        Handler:    http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}),
        BoundUID:   uint32(os.Getuid()),
    }

    ctx := context.Background()
    server, err := NewUnixServer(ctx, config)
    if err != nil {
        t.Fatalf("SECURITY: Should be able to replace stale socket: %v", err)
    }
    defer server.Shutdown(ctx)

    // New socket should be a socket, not the stale file
    info, err := os.Stat(socketPath)
    if err != nil {
        t.Fatalf("failed to stat socket: %v", err)
    }

    if info.Mode()&os.ModeSocket == 0 {
        t.Error("SECURITY: New server should create actual socket, not leave stale file")
    }
}

// =============================================================================
// EC2 METADATA SERVER SECURITY
// =============================================================================

// TestThreat_EC2Metadata_LoopbackOnly verifies that the EC2 metadata server
// validates requests come from loopback.
func TestThreat_EC2Metadata_LoopbackOnly(t *testing.T) {
    // Parse ec2server.go to verify security check exists
    fset := token.NewFileSet()
    f, err := parser.ParseFile(fset, "ec2server.go", nil, parser.ParseComments)
    if err != nil {
        t.Skipf("ec2server.go not parseable: %v", err)
    }

    hasLoopbackCheck := false
    ast.Inspect(f, func(n ast.Node) bool {
        if call, ok := n.(*ast.CallExpr); ok {
            if sel, ok := call.Fun.(*ast.SelectorExpr); ok {
                if sel.Sel.Name == "IsLoopback" {
                    hasLoopbackCheck = true
                    return false
                }
            }
        }
        return true
    })

    if !hasLoopbackCheck {
        t.Error("SECURITY: EC2 metadata server should validate loopback source")
    }
}

// TestThreat_EC2Metadata_HostCheck verifies that the EC2 metadata server
// validates the Host header to prevent DNS rebinding.
func TestThreat_EC2Metadata_HostCheck(t *testing.T) {
    // Parse ec2server.go to verify host check exists
    fset := token.NewFileSet()
    f, err := parser.ParseFile(fset, "ec2server.go", nil, parser.ParseComments)
    if err != nil {
        t.Skipf("ec2server.go not parseable: %v", err)
    }

    hasHostCheck := false
    ast.Inspect(f, func(n ast.Node) bool {
        if sel, ok := n.(*ast.SelectorExpr); ok {
            if ident, ok := sel.X.(*ast.Ident); ok {
                if ident.Name == "r" && sel.Sel.Name == "Host" {
                    hasHostCheck = true
                    return false
                }
            }
        }
        return true
    })

    if !hasHostCheck {
        t.Error("SECURITY: EC2 metadata server should check Host header for DNS rebinding prevention")
    }
}
```
  </action>
  <verify>go test ./server/... -run TestThreat -v</verify>
  <done>Security regression tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./server/...` succeeds
- [ ] `go test ./server/... -run TestThreat` passes
- [ ] EcsServer has Unix socket mode
- [ ] EC2 server security limitations are documented
- [ ] All security tests validate expected properties
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- EcsServer supports Unix socket mode with process authentication
- EC2 server security limitations clearly documented
- Comprehensive security tests verify threat mitigations
</success_criteria>

<output>
After completion, create `.planning/phases/129-local-server-security/129-04-SUMMARY.md`
</output>
