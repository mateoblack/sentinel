---
phase: 129-local-server-security
plan: 03
type: execute
wave: 3
depends_on: ["129-02"]
files_modified: [sentinel/server.go, sentinel/server_unix.go, sentinel/server_test.go, cli/sentinel_exec.go]
autonomous: true
---

<objective>
Integrate Unix domain socket mode into SentinelServer for process-authenticated credential serving.

Purpose: Enable SentinelServer to optionally use Unix domain sockets with process authentication, preventing credential theft via token interception from other local processes.

Output: SentinelServer with optional Unix socket mode and process authentication.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/129-local-server-security/129-01-SUMMARY.md
@.planning/phases/129-local-server-security/129-02-SUMMARY.md

# Server infrastructure from Plans 01-02
@server/peercred.go
@server/process_auth.go
@server/unix_server.go

# Current SentinelServer implementation to extend
@sentinel/server.go
@cli/sentinel_exec.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Unix socket mode to SentinelServerConfig</name>
  <files>sentinel/server.go</files>
  <action>
Extend SentinelServerConfig to support Unix domain socket mode:

Add to the existing SentinelServerConfig struct in sentinel/server.go (after existing fields):

```go
// UseUnixSocket enables Unix domain socket mode instead of TCP.
// When enabled, the server uses process-based authentication via peer credentials.
// This prevents credential theft from other local processes.
// Default: false (TCP mode for backward compatibility)
UseUnixSocket bool

// UnixSocketPath is the path for the Unix domain socket.
// Only used when UseUnixSocket is true.
// If empty, a temporary socket is created at /tmp/sentinel-<pid>.sock
UnixSocketPath string

// UnixSocketMode is the file mode for the Unix socket.
// Only used when UseUnixSocket is true.
// Default: 0600 (owner only)
UnixSocketMode os.FileMode

// AllowProcessAuthFallback allows TCP connections when Unix sockets are unavailable.
// Only used when UseUnixSocket is true.
// When true, falls back to TCP with standard bearer token auth (less secure).
// Default: false (strict Unix socket enforcement)
AllowProcessAuthFallback bool
```

Also add import for "os" if not present.

Update the SentinelServer struct to add:

```go
// unixServer is the Unix domain socket server (nil if TCP mode)
unixServer *server.UnixServer

// processAuth is the process authenticator for Unix socket mode
processAuth *server.ProcessAuthenticator
```

Add import for "github.com/byteness/aws-vault/v7/server".
  </action>
  <verify>go build ./sentinel/...</verify>
  <done>SentinelServerConfig has Unix socket configuration fields</done>
</task>

<task type="auto">
  <name>Task 2: Create Unix socket SentinelServer factory</name>
  <files>sentinel/server_unix.go</files>
  <action>
Create a separate file for Unix socket server creation logic:

```go
//go:build linux || darwin

package sentinel

import (
    "context"
    "fmt"
    "log"
    "net/http"
    "os"
    "path/filepath"

    "github.com/byteness/aws-vault/v7/server"
)

// NewSentinelServerUnix creates a SentinelServer using Unix domain sockets
// with process-based authentication.
func NewSentinelServerUnix(ctx context.Context, config SentinelServerConfig) (*SentinelServer, error) {
    // Determine socket path
    socketPath := config.UnixSocketPath
    if socketPath == "" {
        socketPath = filepath.Join(os.TempDir(), fmt.Sprintf("sentinel-%d.sock", os.Getpid()))
    }

    // Determine socket mode
    socketMode := config.UnixSocketMode
    if socketMode == 0 {
        socketMode = 0600
    }

    // Create process authenticator
    processAuth := server.NewProcessAuthenticator()

    // Generate token bound to current process (it will serve itself)
    currentPID := int32(os.Getpid())
    currentUID := uint32(os.Getuid())
    token, err := processAuth.GenerateToken(0, currentUID, config.AllowProcessAuthFallback)
    if err != nil {
        return nil, fmt.Errorf("failed to generate process token: %w", err)
    }

    // Generate ServerInstanceID if not provided
    serverInstanceID := config.ServerInstanceID
    if serverInstanceID == "" {
        serverInstanceID = identity.NewRequestID()
    }

    // Initialize rate limiter if configured
    var rateLimiter ratelimit.RateLimiter
    if config.RateLimiter != nil {
        rateLimiter = config.RateLimiter
    } else if config.RateLimitConfig != nil {
        limiter, limiterErr := ratelimit.NewMemoryRateLimiter(*config.RateLimitConfig)
        if limiterErr != nil {
            return nil, fmt.Errorf("failed to create rate limiter: %w", limiterErr)
        }
        rateLimiter = limiter
    }

    // Collect device ID for logging (fail-open)
    deviceID, deviceErr := device.GetDeviceID()
    if deviceErr != nil {
        log.Printf("Warning: failed to collect device ID for logging: %v", deviceErr)
        deviceID = ""
    }

    s := &SentinelServer{
        authToken:   token.Token,
        config:      config,
        rateLimiter: rateLimiter,
        deviceID:    deviceID,
        processAuth: processAuth,
    }

    // Create the credential handler (same as TCP mode)
    credHandler := http.HandlerFunc(s.DefaultRoute)

    // Wrap with process authentication
    authedHandler := server.WithProcessAuth(processAuth, credHandler)

    // Wrap with rate limiting
    rateLimitedHandler := withRateLimiting(rateLimiter, authedHandler.ServeHTTP)

    // Wrap with logging
    loggedHandler := withLogging(rateLimitedHandler)

    // Create Unix server
    unixConfig := server.UnixServerConfig{
        SocketPath:    socketPath,
        SocketMode:    socketMode,
        Handler:       loggedHandler,
        AllowFallback: config.AllowProcessAuthFallback,
        BoundUID:      currentUID,
    }

    unixServer, err := server.NewUnixServer(ctx, unixConfig)
    if err != nil {
        return nil, fmt.Errorf("failed to create Unix server: %w", err)
    }

    s.unixServer = unixServer
    s.listener = nil // Not used in Unix mode

    // Prefetch credentials if not lazy loading
    if !config.LazyLoad && config.CredentialProvider != nil {
        log.Printf("Prefetching credentials for profile %s", config.ProfileName)
        credReq := CredentialRequest{
            ProfileName:     config.ProfileName,
            Region:          config.Region,
            NoSession:       config.NoSession,
            SessionDuration: config.SessionDuration,
            User:            config.User,
            RequestID:       identity.NewRequestID(),
        }
        prefetchCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()
        _, err := config.CredentialProvider.GetCredentialsWithSourceIdentity(prefetchCtx, credReq)
        if err != nil {
            unixServer.Shutdown(ctx)
            return nil, fmt.Errorf("failed to prefetch credentials: %w", err)
        }
    }

    // Create session if SessionStore is configured
    if config.SessionStore != nil {
        sessionID := session.NewSessionID()
        now := time.Now().UTC()

        sessionDuration := config.SessionDuration
        if sessionDuration == 0 {
            sessionDuration = DefaultServerSessionDuration
        }

        serverSession := &session.ServerSession{
            ID:               sessionID,
            User:             config.User,
            Profile:          config.ProfileName,
            ServerInstanceID: serverInstanceID,
            Status:           session.StatusActive,
            StartedAt:        now,
            LastAccessAt:     now,
            ExpiresAt:        now.Add(sessionDuration),
            RequestCount:     0,
            CreatedAt:        now,
            UpdatedAt:        now,
        }

        if err := config.SessionStore.Create(ctx, serverSession); err != nil {
            log.Printf("Warning: failed to create session record: %v", err)
        } else {
            s.sessionID = sessionID
            log.Printf("Session created: %s for user %s profile %s (Unix socket)", sessionID, config.User, config.ProfileName)
        }
    }

    return s, nil
}

// ServeUnix starts serving on the Unix domain socket. This call blocks.
func (s *SentinelServer) ServeUnix() error {
    if s.unixServer == nil {
        return fmt.Errorf("Unix server not initialized - use NewSentinelServerUnix")
    }
    return s.unixServer.Serve()
}

// ShutdownUnix gracefully shuts down the Unix socket server.
func (s *SentinelServer) ShutdownUnix(ctx context.Context) error {
    if s.unixServer == nil {
        return nil
    }

    // Mark session as expired if tracking
    if s.sessionID != "" && s.config.SessionStore != nil {
        sess, err := s.config.SessionStore.Get(ctx, s.sessionID)
        if err != nil {
            log.Printf("Warning: failed to get session for shutdown: %v", err)
        } else if !sess.Status.IsTerminal() {
            sess.Status = session.StatusExpired
            sess.UpdatedAt = time.Now().UTC()
            if updateErr := s.config.SessionStore.Update(ctx, sess); updateErr != nil {
                log.Printf("Warning: failed to mark session expired on shutdown: %v", updateErr)
            } else {
                log.Printf("Session %s marked expired on shutdown", s.sessionID)
            }
        }
    }

    // Close rate limiter
    if s.rateLimiter != nil {
        if closer, ok := s.rateLimiter.(io.Closer); ok {
            if closeErr := closer.Close(); closeErr != nil {
                log.Printf("Warning: failed to close rate limiter: %v", closeErr)
            }
        }
    }

    return s.unixServer.Shutdown(ctx)
}

// UnixSocketPath returns the path to the Unix socket.
// Returns empty string if not in Unix socket mode.
func (s *SentinelServer) UnixSocketPath() string {
    if s.unixServer == nil {
        return ""
    }
    return s.unixServer.SocketPath()
}

// IsUnixMode returns true if the server is using Unix domain sockets.
func (s *SentinelServer) IsUnixMode() bool {
    return s.unixServer != nil
}
```

Add necessary imports (identity, session, device, ratelimit, io, time).
  </action>
  <verify>go build ./sentinel/...</verify>
  <done>Unix socket SentinelServer factory and methods exist</done>
</task>

<task type="auto">
  <name>Task 3: Add CLI flag for Unix socket mode</name>
  <files>cli/sentinel_exec.go</files>
  <action>
Add --unix-socket flag to the sentinel exec command to enable Unix socket mode:

Find the ConfigureSentinelExec function and add a new flag after the existing server-related flags:

```go
// Add to SentinelExecCommandInput struct (or inline in function):
useUnixSocket := cmd.Flag("unix-socket",
    "Use Unix domain socket for credential server (more secure, Linux/macOS only). "+
    "Enables process-based authentication to prevent credential theft from other local processes.").
    Default("false").
    Bool()

unixSocketPath := cmd.Flag("unix-socket-path",
    "Path for Unix domain socket (default: /tmp/sentinel-<pid>.sock). "+
    "Only used with --unix-socket.").
    String()
```

Then in the execution logic where SentinelServer is created, add the Unix socket configuration:

```go
// Determine if Unix socket mode should be used
if input.StartServer {
    serverConfig := sentinel.SentinelServerConfig{
        ProfileName:        input.ProfileName,
        PolicyParameter:    policyPath,
        Region:             cfg.Region,
        NoSession:          input.NoSession,
        SessionDuration:    serverSessionDuration,
        User:               awsUser,
        Logger:             logger,
        Store:              store,
        BreakGlassStore:    breakGlassStore,
        PolicyLoader:       cachedLoader,
        CredentialProvider: credProvider,
        LazyLoad:           false,
        SessionStore:       sessionStore,
        RateLimitConfig:    &ratelimit.DefaultConfig,
    }

    var sentinelServer *sentinel.SentinelServer
    var serverURL string

    if *useUnixSocket {
        // Unix socket mode with process authentication
        serverConfig.UseUnixSocket = true
        serverConfig.UnixSocketPath = *unixSocketPath

        sentinelServer, err = sentinel.NewSentinelServerUnix(ctx, serverConfig)
        if err != nil {
            return 0, fmt.Errorf("Failed to start Unix credential server: %w", err)
        }

        // For Unix sockets, we pass the socket path instead of HTTP URL
        serverURL = sentinelServer.UnixSocketPath()
        log.Printf("Starting Sentinel Unix socket credential server at %s", serverURL)

        go func() {
            if err := sentinelServer.ServeUnix(); err != nil {
                log.Fatalf("Unix credential server: %s", err.Error())
            }
        }()

        defer sentinelServer.ShutdownUnix(ctx)
    } else {
        // TCP mode (existing behavior)
        sentinelServer, err = sentinel.NewSentinelServer(ctx, serverConfig, "", *serverPort)
        if err != nil {
            return 0, fmt.Errorf("Failed to start credential server: %w", err)
        }

        serverURL = sentinelServer.BaseURL()
        log.Printf("Starting Sentinel credential server at %s", serverURL)

        go func() {
            if err := sentinelServer.Serve(); err != nil {
                log.Fatalf("credential server: %s", err.Error())
            }
        }()

        defer sentinelServer.Shutdown(ctx)
    }

    // Set environment for subprocess
    if sentinelServer.IsUnixMode() {
        // Unix socket mode uses different environment variable
        // AWS SDKs don't directly support Unix sockets, so we use a wrapper
        // For now, document that this mode requires SDK support
        env = append(env, fmt.Sprintf("SENTINEL_UNIX_SOCKET=%s", serverURL))
        env = append(env, fmt.Sprintf("SENTINEL_AUTH_TOKEN=%s", sentinelServer.AuthToken()))
    } else {
        // TCP mode uses standard container credentials
        env = append(env, fmt.Sprintf("AWS_CONTAINER_CREDENTIALS_FULL_URI=%s", serverURL))
        env = append(env, fmt.Sprintf("AWS_CONTAINER_AUTHORIZATION_TOKEN=%s", sentinelServer.AuthToken()))
    }
}
```

Note: This implementation adds Unix socket support but recognizes that AWS SDKs don't natively support Unix sockets for container credentials. The environment variables are set for potential future SDK support or custom credential helper wrappers.
  </action>
  <verify>go build ./cmd/sentinel/...</verify>
  <done>--unix-socket flag added to sentinel exec command</done>
</task>

<task type="auto">
  <name>Task 4: Add security tests for Unix socket mode</name>
  <files>sentinel/server_unix_test.go</files>
  <action>
Create security tests for Unix socket mode:

```go
//go:build linux || darwin

package sentinel

import (
    "context"
    "net"
    "net/http"
    "os"
    "path/filepath"
    "testing"
    "time"

    "github.com/byteness/aws-vault/v7/policy"
)

// TestSecurityRegression_UnixSocket_ProcessAuthentication verifies that
// only the process that received the token can use it.
func TestSecurityRegression_UnixSocket_ProcessAuthentication(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "sentinel-unix-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    config := SentinelServerConfig{
        ProfileName:     "test-profile",
        User:            "test-user",
        LazyLoad:        true,
        UseUnixSocket:   true,
        UnixSocketPath:  socketPath,
        UnixSocketMode:  0600,
        PolicyLoader:    &mockPolicyLoader{policy: &policy.Policy{Version: "1"}},
    }

    ctx := context.Background()
    server, err := NewSentinelServerUnix(ctx, config)
    if err != nil {
        t.Fatalf("failed to create Unix server: %v", err)
    }

    go server.ServeUnix()
    defer server.ShutdownUnix(ctx)

    time.Sleep(50 * time.Millisecond)

    // Verify socket permissions
    info, err := os.Stat(socketPath)
    if err != nil {
        t.Fatalf("failed to stat socket: %v", err)
    }

    mode := info.Mode().Perm()
    if mode != 0600 {
        t.Errorf("SECURITY: socket should be owner-only (0600), got %o", mode)
    }

    // Test that valid token works
    client := &http.Client{
        Transport: &http.Transport{
            DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
                return net.Dial("unix", socketPath)
            },
        },
    }

    req, _ := http.NewRequest("GET", "http://unix/", nil)
    req.Header.Set("Authorization", server.AuthToken())

    resp, err := client.Do(req)
    if err != nil {
        t.Fatalf("request failed: %v", err)
    }
    resp.Body.Close()

    // Status might be error due to no credential provider, but should not be 403
    // (auth should pass, then fail at credential retrieval)
    if resp.StatusCode == http.StatusForbidden {
        t.Error("SECURITY: valid token should not be rejected")
    }

    // Test that invalid token is rejected
    req2, _ := http.NewRequest("GET", "http://unix/", nil)
    req2.Header.Set("Authorization", "invalid-token")

    resp2, err := client.Do(req2)
    if err != nil {
        t.Fatalf("request failed: %v", err)
    }
    resp2.Body.Close()

    if resp2.StatusCode != http.StatusForbidden {
        t.Errorf("SECURITY: invalid token should be rejected with 403, got %d", resp2.StatusCode)
    }
}

// TestSecurityRegression_UnixSocket_SocketCleanup verifies that the socket
// is cleaned up on shutdown.
func TestSecurityRegression_UnixSocket_SocketCleanup(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "sentinel-unix-cleanup-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "cleanup.sock")

    config := SentinelServerConfig{
        ProfileName:     "test-profile",
        User:            "test-user",
        LazyLoad:        true,
        UseUnixSocket:   true,
        UnixSocketPath:  socketPath,
        PolicyLoader:    &mockPolicyLoader{policy: &policy.Policy{Version: "1"}},
    }

    ctx := context.Background()
    server, err := NewSentinelServerUnix(ctx, config)
    if err != nil {
        t.Fatalf("failed to create Unix server: %v", err)
    }

    // Verify socket exists
    if _, err := os.Stat(socketPath); os.IsNotExist(err) {
        t.Error("socket should exist after server creation")
    }

    // Shutdown
    server.ShutdownUnix(ctx)

    // Verify socket is cleaned up
    if _, err := os.Stat(socketPath); !os.IsNotExist(err) {
        t.Error("SECURITY: socket should be removed after shutdown")
    }
}

// TestSecurityRegression_UnixSocket_TCPFallbackDisabledByDefault verifies
// that TCP fallback is disabled by default.
func TestSecurityRegression_UnixSocket_TCPFallbackDisabledByDefault(t *testing.T) {
    config := SentinelServerConfig{
        ProfileName:   "test-profile",
        User:          "test-user",
        UseUnixSocket: true,
    }

    if config.AllowProcessAuthFallback {
        t.Error("SECURITY: TCP fallback should be disabled by default")
    }
}

// mockPolicyLoader is a test mock for PolicyLoader.
type mockPolicyLoader struct {
    policy *policy.Policy
    err    error
}

func (m *mockPolicyLoader) Load(ctx context.Context, path string) (*policy.Policy, error) {
    return m.policy, m.err
}
```

Add import for "github.com/byteness/aws-vault/v7/policy".
  </action>
  <verify>go test ./sentinel/... -run TestSecurityRegression_UnixSocket -v</verify>
  <done>Security tests for Unix socket mode pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./sentinel/...` succeeds
- [ ] `go build ./cmd/sentinel/...` succeeds
- [ ] `go test ./sentinel/... -run TestSecurityRegression_UnixSocket` passes
- [ ] --unix-socket flag is available in `sentinel exec --help`
- [ ] Socket permissions are 0600 (owner only)
- [ ] Socket is cleaned up on shutdown
- [ ] Invalid tokens are rejected with 403
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- SentinelServer supports Unix socket mode
- CLI has --unix-socket flag
- Security tests verify process authentication
</success_criteria>

<output>
After completion, create `.planning/phases/129-local-server-security/129-03-SUMMARY.md`
</output>
