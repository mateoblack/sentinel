---
phase: 129-local-server-security
plan: 02
type: execute
wave: 2
depends_on: ["129-01"]
files_modified: [server/unix_server.go, server/unix_server_test.go, server/process_auth.go, server/process_auth_test.go]
autonomous: true
---

<objective>
Create Unix domain socket server with process authentication middleware.

Purpose: Provide a secure server infrastructure that binds bearer tokens to specific processes and validates peer credentials on each request, preventing credential theft via token interception.

Output: UnixServer type with process authentication middleware for use by credential servers.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/129-local-server-security/129-01-SUMMARY.md

# Peer credential infrastructure from Plan 01
@server/peercred.go

# Existing server patterns to follow
@server/ecsserver.go
@sentinel/server.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create process authentication token binding</name>
  <files>server/process_auth.go</files>
  <action>
Create process authentication infrastructure that binds tokens to specific processes:

```go
package server

import (
    "crypto/rand"
    "crypto/subtle"
    "encoding/base64"
    "fmt"
    "log"
    "net"
    "net/http"
    "sync"
)

// ProcessToken represents a bearer token bound to a specific process.
// The token is only valid when presented by the process with matching PID/UID.
type ProcessToken struct {
    // Token is the bearer token value.
    Token string

    // BoundPID is the process ID this token is bound to.
    // If 0, token is not PID-bound (for initial handshake scenarios).
    BoundPID int32

    // BoundUID is the user ID this token is bound to.
    BoundUID uint32

    // AllowFallback allows token validation to succeed even if peer credentials
    // cannot be obtained (e.g., TCP fallback mode). This should only be enabled
    // for backward compatibility during migration.
    AllowFallback bool
}

// ProcessAuthenticator manages process-bound tokens and validates requests.
type ProcessAuthenticator struct {
    mu     sync.RWMutex
    tokens map[string]*ProcessToken
}

// NewProcessAuthenticator creates a new process authenticator.
func NewProcessAuthenticator() *ProcessAuthenticator {
    return &ProcessAuthenticator{
        tokens: make(map[string]*ProcessToken),
    }
}

// GenerateToken creates a new process-bound token.
// If pid is 0, the token is not PID-bound (will be bound on first use).
func (pa *ProcessAuthenticator) GenerateToken(pid int32, uid uint32, allowFallback bool) (*ProcessToken, error) {
    token, err := generateSecureToken()
    if err != nil {
        return nil, fmt.Errorf("failed to generate token: %w", err)
    }

    pt := &ProcessToken{
        Token:         token,
        BoundPID:      pid,
        BoundUID:      uid,
        AllowFallback: allowFallback,
    }

    pa.mu.Lock()
    pa.tokens[token] = pt
    pa.mu.Unlock()

    return pt, nil
}

// RegisterToken registers an externally-generated token.
func (pa *ProcessAuthenticator) RegisterToken(token string, pid int32, uid uint32, allowFallback bool) *ProcessToken {
    pt := &ProcessToken{
        Token:         token,
        BoundPID:      pid,
        BoundUID:      uid,
        AllowFallback: allowFallback,
    }

    pa.mu.Lock()
    pa.tokens[token] = pt
    pa.mu.Unlock()

    return pt
}

// ValidateRequest validates a request's Authorization header against peer credentials.
// Returns the matching token if valid, nil and error if invalid.
func (pa *ProcessAuthenticator) ValidateRequest(r *http.Request, conn net.Conn) (*ProcessToken, error) {
    authHeader := r.Header.Get("Authorization")
    if authHeader == "" {
        return nil, fmt.Errorf("missing Authorization header")
    }

    pa.mu.RLock()
    pt, exists := pa.tokens[authHeader]
    pa.mu.RUnlock()

    if !exists {
        // Use constant-time comparison even for existence check
        // This prevents timing attacks that could reveal valid token prefixes
        return nil, fmt.Errorf("invalid token")
    }

    // Constant-time token comparison
    if subtle.ConstantTimeCompare([]byte(authHeader), []byte(pt.Token)) != 1 {
        return nil, fmt.Errorf("invalid token")
    }

    // Get peer credentials if available
    creds, err := GetPeerCredentials(conn)
    if err != nil {
        if pt.AllowFallback {
            log.Printf("WARNING: Process auth fallback mode - peer credentials unavailable: %v", err)
            return pt, nil
        }
        return nil, fmt.Errorf("failed to get peer credentials: %w", err)
    }

    // Validate UID matches
    if creds.UID != pt.BoundUID {
        log.Printf("SECURITY: Token UID mismatch: expected %d, got %d", pt.BoundUID, creds.UID)
        return nil, fmt.Errorf("token UID mismatch")
    }

    // Validate PID if bound
    if pt.BoundPID != 0 && creds.PID != pt.BoundPID {
        log.Printf("SECURITY: Token PID mismatch: expected %d, got %d", pt.BoundPID, creds.PID)
        return nil, fmt.Errorf("token PID mismatch")
    }

    // Bind to PID on first successful use if not already bound
    if pt.BoundPID == 0 {
        pa.mu.Lock()
        if pt.BoundPID == 0 {
            pt.BoundPID = creds.PID
            log.Printf("Token bound to PID %d", creds.PID)
        }
        pa.mu.Unlock()
    }

    return pt, nil
}

// RevokeToken removes a token from the authenticator.
func (pa *ProcessAuthenticator) RevokeToken(token string) {
    pa.mu.Lock()
    delete(pa.tokens, token)
    pa.mu.Unlock()
}

// generateSecureToken creates a cryptographically secure random token.
func generateSecureToken() (string, error) {
    b := make([]byte, 32)
    if _, err := rand.Read(b); err != nil {
        return "", err
    }
    return base64.RawURLEncoding.EncodeToString(b), nil
}
```

This provides process-bound token management with PID/UID validation.
  </action>
  <verify>go build ./server/...</verify>
  <done>ProcessAuthenticator type with token binding and validation exists</done>
</task>

<task type="auto">
  <name>Task 2: Create Unix domain socket HTTP server</name>
  <files>server/unix_server.go</files>
  <action>
Create a Unix domain socket server that captures connection for peer credential extraction:

```go
package server

import (
    "context"
    "fmt"
    "log"
    "net"
    "net/http"
    "os"
    "path/filepath"
    "sync"
    "time"
)

// UnixServer is an HTTP server that listens on a Unix domain socket
// and supports process-based authentication via peer credentials.
type UnixServer struct {
    listener      net.Listener
    socketPath    string
    server        http.Server
    authenticator *ProcessAuthenticator
    connTracker   *connectionTracker

    // mu protects cleanup state
    mu      sync.Mutex
    cleaned bool
}

// UnixServerConfig contains configuration for UnixServer.
type UnixServerConfig struct {
    // SocketPath is the path for the Unix domain socket.
    // If empty, a temporary socket in os.TempDir() is created.
    SocketPath string

    // SocketMode is the file mode for the socket (default: 0600).
    SocketMode os.FileMode

    // Handler is the HTTP handler to serve.
    Handler http.Handler

    // AllowFallback enables TCP fallback mode for testing/compatibility.
    // When true, tokens work even without peer credentials (less secure).
    AllowFallback bool

    // BoundUID is the UID to bind tokens to (usually current user).
    BoundUID uint32
}

// connectionTracker tracks the connection for each HTTP request
// so we can extract peer credentials in the handler.
type connectionTracker struct {
    mu    sync.RWMutex
    conns map[*http.Request]net.Conn
}

func newConnectionTracker() *connectionTracker {
    return &connectionTracker{
        conns: make(map[*http.Request]net.Conn),
    }
}

func (ct *connectionTracker) Add(r *http.Request, conn net.Conn) {
    ct.mu.Lock()
    ct.conns[r] = conn
    ct.mu.Unlock()
}

func (ct *connectionTracker) Get(r *http.Request) net.Conn {
    ct.mu.RLock()
    defer ct.mu.RUnlock()
    return ct.conns[r]
}

func (ct *connectionTracker) Remove(r *http.Request) {
    ct.mu.Lock()
    delete(ct.conns, r)
    ct.mu.Unlock()
}

// NewUnixServer creates a new Unix domain socket server.
func NewUnixServer(ctx context.Context, config UnixServerConfig) (*UnixServer, error) {
    socketPath := config.SocketPath
    if socketPath == "" {
        // Create temporary socket
        socketPath = filepath.Join(os.TempDir(), fmt.Sprintf("sentinel-%d.sock", os.Getpid()))
    }

    // Remove existing socket if it exists
    if err := os.Remove(socketPath); err != nil && !os.IsNotExist(err) {
        return nil, fmt.Errorf("failed to remove existing socket: %w", err)
    }

    // Create Unix socket listener
    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        return nil, fmt.Errorf("failed to create Unix listener: %w", err)
    }

    // Set socket permissions (default: owner only)
    mode := config.SocketMode
    if mode == 0 {
        mode = 0600
    }
    if err := os.Chmod(socketPath, mode); err != nil {
        listener.Close()
        os.Remove(socketPath)
        return nil, fmt.Errorf("failed to set socket permissions: %w", err)
    }

    authenticator := NewProcessAuthenticator()
    connTracker := newConnectionTracker()

    us := &UnixServer{
        listener:      listener,
        socketPath:    socketPath,
        authenticator: authenticator,
        connTracker:   connTracker,
    }

    // Wrap handler with connection tracking
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        config.Handler.ServeHTTP(w, r)
        connTracker.Remove(r)
    })

    us.server = http.Server{
        Handler: handler,
        ConnContext: func(ctx context.Context, c net.Conn) context.Context {
            // Store connection in context for later retrieval
            return context.WithValue(ctx, connContextKey{}, c)
        },
    }

    return us, nil
}

// connContextKey is the context key for storing the connection.
type connContextKey struct{}

// GetConnFromRequest retrieves the net.Conn from an HTTP request's context.
// This is used by handlers to get peer credentials.
func GetConnFromRequest(r *http.Request) net.Conn {
    if conn, ok := r.Context().Value(connContextKey{}).(net.Conn); ok {
        return conn
    }
    return nil
}

// SocketPath returns the path to the Unix socket.
func (us *UnixServer) SocketPath() string {
    return us.socketPath
}

// SocketURL returns the URL for connecting to this server.
// Format: unix:///path/to/socket
func (us *UnixServer) SocketURL() string {
    return fmt.Sprintf("unix://%s", us.socketPath)
}

// Authenticator returns the process authenticator for token management.
func (us *UnixServer) Authenticator() *ProcessAuthenticator {
    return us.authenticator
}

// Serve starts serving HTTP requests. This call blocks.
func (us *UnixServer) Serve() error {
    return us.server.Serve(us.listener)
}

// Shutdown gracefully shuts down the server.
func (us *UnixServer) Shutdown(ctx context.Context) error {
    us.mu.Lock()
    defer us.mu.Unlock()

    if us.cleaned {
        return nil
    }

    err := us.server.Shutdown(ctx)

    // Clean up socket file
    if rmErr := os.Remove(us.socketPath); rmErr != nil && !os.IsNotExist(rmErr) {
        log.Printf("Warning: failed to remove socket file: %v", rmErr)
    }

    us.cleaned = true
    return err
}

// WithProcessAuth creates HTTP middleware that validates process authentication.
// It extracts peer credentials from the connection and validates against the token.
func WithProcessAuth(authenticator *ProcessAuthenticator, next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        conn := GetConnFromRequest(r)
        if conn == nil {
            log.Printf("ERROR: No connection context available for process auth")
            writeErrorMessage(w, "Authentication failed", http.StatusInternalServerError)
            return
        }

        token, err := authenticator.ValidateRequest(r, conn)
        if err != nil {
            log.Printf("SECURITY: Process auth failed: %v", err)
            writeErrorMessage(w, "invalid Authorization token", http.StatusForbidden)
            return
        }

        // Add token info to request context for handlers
        ctx := context.WithValue(r.Context(), processTokenContextKey{}, token)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// processTokenContextKey is the context key for storing the validated token.
type processTokenContextKey struct{}

// GetProcessTokenFromContext retrieves the validated ProcessToken from request context.
func GetProcessTokenFromContext(ctx context.Context) *ProcessToken {
    if token, ok := ctx.Value(processTokenContextKey{}).(*ProcessToken); ok {
        return token
    }
    return nil
}
```

This provides a complete Unix socket server with process authentication middleware.
  </action>
  <verify>go build ./server/...</verify>
  <done>UnixServer with process authentication middleware exists</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for process authentication</name>
  <files>server/process_auth_test.go</files>
  <action>
Create comprehensive tests for process authentication:

```go
//go:build linux || darwin

package server

import (
    "context"
    "errors"
    "net"
    "net/http"
    "net/http/httptest"
    "os"
    "path/filepath"
    "testing"
    "time"
)

func TestProcessAuthenticator_GenerateToken(t *testing.T) {
    pa := NewProcessAuthenticator()

    token, err := pa.GenerateToken(12345, 1000, false)
    if err != nil {
        t.Fatalf("failed to generate token: %v", err)
    }

    if token.Token == "" {
        t.Error("token should not be empty")
    }
    if token.BoundPID != 12345 {
        t.Errorf("expected PID 12345, got %d", token.BoundPID)
    }
    if token.BoundUID != 1000 {
        t.Errorf("expected UID 1000, got %d", token.BoundUID)
    }
}

func TestProcessAuthenticator_ValidateRequest_Success(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "process-auth-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    // Create Unix socket listener
    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    pa := NewProcessAuthenticator()
    currentUID := uint32(os.Getuid())
    currentPID := int32(os.Getpid())

    // Register token bound to current process
    token := pa.RegisterToken("test-token-123", currentPID, currentUID, false)

    done := make(chan error)
    go func() {
        conn, err := listener.Accept()
        if err != nil {
            done <- err
            return
        }
        defer conn.Close()

        req, _ := http.NewRequest("GET", "/", nil)
        req.Header.Set("Authorization", token.Token)

        validatedToken, err := pa.ValidateRequest(req, conn)
        if err != nil {
            done <- err
            return
        }

        if validatedToken.Token != token.Token {
            done <- errors.New("token mismatch")
            return
        }

        done <- nil
    }()

    // Connect as client
    client, err := net.Dial("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to dial: %v", err)
    }
    defer client.Close()

    if err := <-done; err != nil {
        t.Fatalf("validation failed: %v", err)
    }
}

func TestProcessAuthenticator_ValidateRequest_WrongUID(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "process-auth-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    pa := NewProcessAuthenticator()
    // Register token with wrong UID
    token := pa.RegisterToken("test-token-456", 0, 99999, false)

    done := make(chan error)
    go func() {
        conn, err := listener.Accept()
        if err != nil {
            done <- err
            return
        }
        defer conn.Close()

        req, _ := http.NewRequest("GET", "/", nil)
        req.Header.Set("Authorization", token.Token)

        _, err = pa.ValidateRequest(req, conn)
        if err == nil {
            done <- errors.New("expected UID mismatch error")
            return
        }
        done <- nil // Expected to fail
    }()

    client, err := net.Dial("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to dial: %v", err)
    }
    defer client.Close()

    if err := <-done; err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
}

func TestProcessAuthenticator_ValidateRequest_WrongPID(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "process-auth-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    pa := NewProcessAuthenticator()
    currentUID := uint32(os.Getuid())
    // Register token with correct UID but wrong PID
    token := pa.RegisterToken("test-token-789", 99999, currentUID, false)

    done := make(chan error)
    go func() {
        conn, err := listener.Accept()
        if err != nil {
            done <- err
            return
        }
        defer conn.Close()

        req, _ := http.NewRequest("GET", "/", nil)
        req.Header.Set("Authorization", token.Token)

        _, err = pa.ValidateRequest(req, conn)
        if err == nil {
            done <- errors.New("expected PID mismatch error")
            return
        }
        done <- nil // Expected to fail
    }()

    client, err := net.Dial("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to dial: %v", err)
    }
    defer client.Close()

    if err := <-done; err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
}

func TestProcessAuthenticator_ValidateRequest_InvalidToken(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "process-auth-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    pa := NewProcessAuthenticator()

    done := make(chan error)
    go func() {
        conn, err := listener.Accept()
        if err != nil {
            done <- err
            return
        }
        defer conn.Close()

        req, _ := http.NewRequest("GET", "/", nil)
        req.Header.Set("Authorization", "invalid-token")

        _, err = pa.ValidateRequest(req, conn)
        if err == nil {
            done <- errors.New("expected invalid token error")
            return
        }
        done <- nil // Expected to fail
    }()

    client, err := net.Dial("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to dial: %v", err)
    }
    defer client.Close()

    if err := <-done; err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
}

func TestProcessAuthenticator_TokenBinding(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "process-auth-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    pa := NewProcessAuthenticator()
    currentUID := uint32(os.Getuid())
    currentPID := int32(os.Getpid())

    // Register token with PID=0 (unbound)
    token := pa.RegisterToken("bind-test-token", 0, currentUID, false)

    if token.BoundPID != 0 {
        t.Error("token should start unbound")
    }

    done := make(chan error)
    go func() {
        conn, err := listener.Accept()
        if err != nil {
            done <- err
            return
        }
        defer conn.Close()

        req, _ := http.NewRequest("GET", "/", nil)
        req.Header.Set("Authorization", token.Token)

        _, err = pa.ValidateRequest(req, conn)
        if err != nil {
            done <- err
            return
        }

        done <- nil
    }()

    client, err := net.Dial("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to dial: %v", err)
    }
    defer client.Close()

    if err := <-done; err != nil {
        t.Fatalf("validation failed: %v", err)
    }

    // Token should now be bound to current PID
    if token.BoundPID != currentPID {
        t.Errorf("expected token bound to PID %d, got %d", currentPID, token.BoundPID)
    }
}

func TestProcessAuthenticator_FallbackMode(t *testing.T) {
    pa := NewProcessAuthenticator()

    // Register token with fallback enabled
    token := pa.RegisterToken("fallback-token", 12345, 1000, true)

    // Create a TCP connection (no peer credentials available)
    listener, err := net.Listen("tcp", "127.0.0.1:0")
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    done := make(chan error)
    go func() {
        conn, err := listener.Accept()
        if err != nil {
            done <- err
            return
        }
        defer conn.Close()

        req, _ := http.NewRequest("GET", "/", nil)
        req.Header.Set("Authorization", token.Token)

        // Should succeed in fallback mode despite TCP connection
        validated, err := pa.ValidateRequest(req, conn)
        if err != nil {
            done <- err
            return
        }
        if validated.Token != token.Token {
            done <- errors.New("token mismatch")
            return
        }
        done <- nil
    }()

    client, err := net.Dial("tcp", listener.Addr().String())
    if err != nil {
        t.Fatalf("failed to dial: %v", err)
    }
    defer client.Close()

    if err := <-done; err != nil {
        t.Fatalf("fallback mode failed: %v", err)
    }
}

func TestProcessAuthenticator_RevokeToken(t *testing.T) {
    pa := NewProcessAuthenticator()
    token, _ := pa.GenerateToken(12345, 1000, true)

    // Token should exist
    pa.mu.RLock()
    _, exists := pa.tokens[token.Token]
    pa.mu.RUnlock()
    if !exists {
        t.Error("token should exist before revocation")
    }

    // Revoke
    pa.RevokeToken(token.Token)

    // Token should not exist
    pa.mu.RLock()
    _, exists = pa.tokens[token.Token]
    pa.mu.RUnlock()
    if exists {
        t.Error("token should not exist after revocation")
    }
}
```
  </action>
  <verify>go test ./server/... -run TestProcessAuth -v</verify>
  <done>All process authentication tests pass</done>
</task>

<task type="auto">
  <name>Task 4: Add Unix server integration tests</name>
  <files>server/unix_server_test.go</files>
  <action>
Create integration tests for the Unix domain socket server:

```go
//go:build linux || darwin

package server

import (
    "context"
    "io"
    "net"
    "net/http"
    "os"
    "path/filepath"
    "testing"
    "time"
)

func TestUnixServer_BasicOperation(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "unix-server-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "server.sock")

    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("success"))
    })

    config := UnixServerConfig{
        SocketPath: socketPath,
        Handler:    handler,
        BoundUID:   uint32(os.Getuid()),
    }

    ctx := context.Background()
    server, err := NewUnixServer(ctx, config)
    if err != nil {
        t.Fatalf("failed to create server: %v", err)
    }

    // Start server in background
    go server.Serve()
    defer server.Shutdown(ctx)

    // Give server time to start
    time.Sleep(50 * time.Millisecond)

    // Connect and make request
    client := &http.Client{
        Transport: &http.Transport{
            DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
                return net.Dial("unix", socketPath)
            },
        },
    }

    resp, err := client.Get("http://unix/")
    if err != nil {
        t.Fatalf("request failed: %v", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        t.Errorf("expected status 200, got %d", resp.StatusCode)
    }

    body, _ := io.ReadAll(resp.Body)
    if string(body) != "success" {
        t.Errorf("expected 'success', got %q", string(body))
    }
}

func TestUnixServer_SocketPermissions(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "unix-server-perm-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "server.sock")

    config := UnixServerConfig{
        SocketPath: socketPath,
        SocketMode: 0600, // Owner only
        Handler:    http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}),
        BoundUID:   uint32(os.Getuid()),
    }

    ctx := context.Background()
    server, err := NewUnixServer(ctx, config)
    if err != nil {
        t.Fatalf("failed to create server: %v", err)
    }
    defer server.Shutdown(ctx)

    // Check socket permissions
    info, err := os.Stat(socketPath)
    if err != nil {
        t.Fatalf("failed to stat socket: %v", err)
    }

    mode := info.Mode().Perm()
    if mode != 0600 {
        t.Errorf("expected socket mode 0600, got %o", mode)
    }
}

func TestUnixServer_CleanupOnShutdown(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "unix-server-cleanup-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "server.sock")

    config := UnixServerConfig{
        SocketPath: socketPath,
        Handler:    http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}),
        BoundUID:   uint32(os.Getuid()),
    }

    ctx := context.Background()
    server, err := NewUnixServer(ctx, config)
    if err != nil {
        t.Fatalf("failed to create server: %v", err)
    }

    // Verify socket exists
    if _, err := os.Stat(socketPath); os.IsNotExist(err) {
        t.Error("socket should exist after server creation")
    }

    // Shutdown
    server.Shutdown(ctx)

    // Verify socket is cleaned up
    if _, err := os.Stat(socketPath); !os.IsNotExist(err) {
        t.Error("socket should be removed after shutdown")
    }
}

func TestUnixServer_WithProcessAuth(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "unix-server-auth-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "auth-server.sock")
    currentUID := uint32(os.Getuid())
    currentPID := int32(os.Getpid())

    authenticator := NewProcessAuthenticator()
    token := authenticator.RegisterToken("server-test-token", currentPID, currentUID, false)

    innerHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Verify we can get the token from context
        pt := GetProcessTokenFromContext(r.Context())
        if pt == nil {
            t.Error("expected token in context")
            w.WriteHeader(http.StatusInternalServerError)
            return
        }
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("authenticated"))
    })

    config := UnixServerConfig{
        SocketPath: socketPath,
        Handler:    WithProcessAuth(authenticator, innerHandler),
        BoundUID:   currentUID,
    }

    ctx := context.Background()
    server, err := NewUnixServer(ctx, config)
    if err != nil {
        t.Fatalf("failed to create server: %v", err)
    }

    go server.Serve()
    defer server.Shutdown(ctx)

    time.Sleep(50 * time.Millisecond)

    client := &http.Client{
        Transport: &http.Transport{
            DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {
                return net.Dial("unix", socketPath)
            },
        },
    }

    // Request with valid token
    req, _ := http.NewRequest("GET", "http://unix/", nil)
    req.Header.Set("Authorization", token.Token)

    resp, err := client.Do(req)
    if err != nil {
        t.Fatalf("request failed: %v", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        t.Errorf("expected status 200, got %d", resp.StatusCode)
    }

    // Request with invalid token
    req2, _ := http.NewRequest("GET", "http://unix/", nil)
    req2.Header.Set("Authorization", "wrong-token")

    resp2, err := client.Do(req2)
    if err != nil {
        t.Fatalf("request failed: %v", err)
    }
    defer resp2.Body.Close()

    if resp2.StatusCode != http.StatusForbidden {
        t.Errorf("expected status 403 for invalid token, got %d", resp2.StatusCode)
    }
}

func TestUnixServer_SocketURL(t *testing.T) {
    tmpDir, err := os.MkdirTemp("", "unix-server-url-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "url-test.sock")

    config := UnixServerConfig{
        SocketPath: socketPath,
        Handler:    http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}),
        BoundUID:   uint32(os.Getuid()),
    }

    ctx := context.Background()
    server, err := NewUnixServer(ctx, config)
    if err != nil {
        t.Fatalf("failed to create server: %v", err)
    }
    defer server.Shutdown(ctx)

    expectedURL := "unix://" + socketPath
    if server.SocketURL() != expectedURL {
        t.Errorf("expected URL %q, got %q", expectedURL, server.SocketURL())
    }

    if server.SocketPath() != socketPath {
        t.Errorf("expected path %q, got %q", socketPath, server.SocketPath())
    }
}
```
  </action>
  <verify>go test ./server/... -run TestUnixServer -v</verify>
  <done>All Unix server integration tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./server/...` succeeds
- [ ] `go test ./server/... -run TestProcessAuth` passes
- [ ] `go test ./server/... -run TestUnixServer` passes
- [ ] Process authentication correctly validates UID/PID
- [ ] Token binding works (unbound token gets bound on first use)
- [ ] Invalid tokens and UID/PID mismatches are rejected
- [ ] Unix socket cleanup works on shutdown
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- ProcessAuthenticator validates tokens with peer credentials
- UnixServer provides secure Unix domain socket serving
- Tests demonstrate security properties (UID/PID validation, token revocation)
</success_criteria>

<output>
After completion, create `.planning/phases/129-local-server-security/129-02-SUMMARY.md`
</output>
