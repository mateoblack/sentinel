---
phase: 129-local-server-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [server/peercred.go, server/peercred_linux.go, server/peercred_darwin.go, server/peercred_default.go, server/peercred_test.go]
autonomous: true
---

<objective>
Implement peer credential extraction infrastructure for Unix domain sockets.

Purpose: Enable local credential servers to verify the PID and UID of connecting processes using SO_PEERCRED (Linux) or LOCAL_PEERCRED (macOS), preventing unauthorized local access.

Output: Cross-platform `peercred` package with peer credential extraction from Unix socket connections.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Current server implementations - these will be modified in Plan 02
@server/ecsserver.go
@server/ec2server.go
@sentinel/server.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create peer credential types</name>
  <files>server/peercred.go</files>
  <action>
Create the core peer credential types and interface:

```go
// Package server provides local credential servers.
// peercred.go contains peer credential types for process-based authentication.
package server

import (
    "fmt"
    "net"
)

// PeerCredentials contains the credentials of a peer process connected via Unix socket.
// These credentials are obtained from the kernel via SO_PEERCRED (Linux) or
// LOCAL_PEERCRED (macOS) and cannot be spoofed by the connecting process.
type PeerCredentials struct {
    // PID is the process ID of the peer.
    PID int32

    // UID is the user ID of the peer.
    UID uint32

    // GID is the group ID of the peer.
    GID uint32
}

// String returns a human-readable representation of the credentials.
func (p *PeerCredentials) String() string {
    return fmt.Sprintf("pid=%d uid=%d gid=%d", p.PID, p.UID, p.GID)
}

// GetPeerCredentials extracts peer credentials from a Unix domain socket connection.
// Returns nil, nil if credentials cannot be obtained (e.g., non-Unix socket).
// Returns nil, error if there was an error extracting credentials.
//
// SECURITY: These credentials come directly from the kernel and cannot be
// spoofed by the connecting process. This is the basis for process-based
// authentication in local credential servers.
func GetPeerCredentials(conn net.Conn) (*PeerCredentials, error) {
    return getPeerCredentials(conn)
}

// ErrNotUnixSocket is returned when attempting to get peer credentials from
// a non-Unix socket connection.
type ErrNotUnixSocket struct {
    ConnType string
}

func (e *ErrNotUnixSocket) Error() string {
    return fmt.Sprintf("peer credentials only available for Unix sockets, got %s", e.ConnType)
}

// ErrPeerCredentialsUnavailable is returned when the platform does not support
// peer credential extraction.
type ErrPeerCredentialsUnavailable struct {
    Platform string
    Reason   string
}

func (e *ErrPeerCredentialsUnavailable) Error() string {
    return fmt.Sprintf("peer credentials unavailable on %s: %s", e.Platform, e.Reason)
}
```

This provides the foundation for platform-specific implementations.
  </action>
  <verify>go build ./server/...</verify>
  <done>PeerCredentials type and GetPeerCredentials function signature exist</done>
</task>

<task type="auto">
  <name>Task 2: Implement Linux peer credential extraction</name>
  <files>server/peercred_linux.go</files>
  <action>
Implement SO_PEERCRED extraction for Linux using golang.org/x/sys/unix:

```go
//go:build linux

package server

import (
    "net"
    "runtime"

    "golang.org/x/sys/unix"
)

// getPeerCredentials extracts peer credentials using SO_PEERCRED on Linux.
// This works for Unix domain sockets (stream and datagram).
func getPeerCredentials(conn net.Conn) (*PeerCredentials, error) {
    unixConn, ok := conn.(*net.UnixConn)
    if !ok {
        return nil, &ErrNotUnixSocket{ConnType: connTypeName(conn)}
    }

    // Get the raw file descriptor
    rawConn, err := unixConn.SyscallConn()
    if err != nil {
        return nil, fmt.Errorf("failed to get syscall conn: %w", err)
    }

    var ucred *unix.Ucred
    var ucredErr error

    err = rawConn.Control(func(fd uintptr) {
        ucred, ucredErr = unix.GetsockoptUcred(int(fd), unix.SOL_SOCKET, unix.SO_PEERCRED)
    })

    if err != nil {
        return nil, fmt.Errorf("failed to control socket: %w", err)
    }
    if ucredErr != nil {
        return nil, fmt.Errorf("failed to get peer credentials: %w", ucredErr)
    }

    return &PeerCredentials{
        PID: ucred.Pid,
        UID: ucred.Uid,
        GID: ucred.Gid,
    }, nil
}

func connTypeName(conn net.Conn) string {
    switch conn.(type) {
    case *net.TCPConn:
        return "TCP"
    case *net.UDPConn:
        return "UDP"
    case *net.UnixConn:
        return "Unix"
    default:
        return "unknown"
    }
}
```

Add "golang.org/x/sys" to go.mod if not already present (it should be since aws-sdk uses it).
  </action>
  <verify>GOOS=linux go build ./server/...</verify>
  <done>Linux peer credential extraction compiles successfully</done>
</task>

<task type="auto">
  <name>Task 3: Implement macOS peer credential extraction</name>
  <files>server/peercred_darwin.go</files>
  <action>
Implement LOCAL_PEERCRED extraction for macOS:

```go
//go:build darwin

package server

import (
    "fmt"
    "net"
    "unsafe"

    "golang.org/x/sys/unix"
)

// Constants for macOS LOCAL_PEERCRED
const (
    // SOL_LOCAL is the socket option level for local socket options on macOS.
    SOL_LOCAL = 0

    // LOCAL_PEERCRED retrieves peer credentials on macOS.
    // Returns xucred structure containing effective UID/GID.
    LOCAL_PEERCRED = 0x001
)

// xucred is the Darwin credential structure returned by LOCAL_PEERCRED.
// Note: Darwin doesn't provide PID via LOCAL_PEERCRED, only via LOCAL_PEERPID (separate call).
type xucred struct {
    Version uint32
    UID     uint32
    Ngroups int16
    Groups  [16]uint32 // NGROUPS = 16 on Darwin
}

const LOCAL_PEERPID = 0x002

// getPeerCredentials extracts peer credentials using LOCAL_PEERCRED on macOS.
// macOS requires two separate calls: LOCAL_PEERCRED for UID/GID and LOCAL_PEERPID for PID.
func getPeerCredentials(conn net.Conn) (*PeerCredentials, error) {
    unixConn, ok := conn.(*net.UnixConn)
    if !ok {
        return nil, &ErrNotUnixSocket{ConnType: connTypeName(conn)}
    }

    rawConn, err := unixConn.SyscallConn()
    if err != nil {
        return nil, fmt.Errorf("failed to get syscall conn: %w", err)
    }

    var creds PeerCredentials
    var credErr error

    err = rawConn.Control(func(fd uintptr) {
        // Get UID/GID via LOCAL_PEERCRED
        var xc xucred
        xcLen := uint32(unsafe.Sizeof(xc))
        _, _, errno := unix.Syscall6(
            unix.SYS_GETSOCKOPT,
            fd,
            SOL_LOCAL,
            LOCAL_PEERCRED,
            uintptr(unsafe.Pointer(&xc)),
            uintptr(unsafe.Pointer(&xcLen)),
            0,
        )
        if errno != 0 {
            credErr = fmt.Errorf("getsockopt LOCAL_PEERCRED failed: %v", errno)
            return
        }

        creds.UID = xc.UID
        if xc.Ngroups > 0 {
            creds.GID = xc.Groups[0] // Primary group
        }

        // Get PID via LOCAL_PEERPID
        var pid int32
        pidLen := uint32(unsafe.Sizeof(pid))
        _, _, errno = unix.Syscall6(
            unix.SYS_GETSOCKOPT,
            fd,
            SOL_LOCAL,
            LOCAL_PEERPID,
            uintptr(unsafe.Pointer(&pid)),
            uintptr(unsafe.Pointer(&pidLen)),
            0,
        )
        if errno != 0 {
            credErr = fmt.Errorf("getsockopt LOCAL_PEERPID failed: %v", errno)
            return
        }
        creds.PID = pid
    })

    if err != nil {
        return nil, fmt.Errorf("failed to control socket: %w", err)
    }
    if credErr != nil {
        return nil, credErr
    }

    return &creds, nil
}

func connTypeName(conn net.Conn) string {
    switch conn.(type) {
    case *net.TCPConn:
        return "TCP"
    case *net.UDPConn:
        return "UDP"
    case *net.UnixConn:
        return "Unix"
    default:
        return "unknown"
    }
}
```
  </action>
  <verify>GOOS=darwin go build ./server/...</verify>
  <done>macOS peer credential extraction compiles successfully</done>
</task>

<task type="auto">
  <name>Task 4: Implement fallback for unsupported platforms</name>
  <files>server/peercred_default.go</files>
  <action>
Create a fallback implementation for Windows and other platforms:

```go
//go:build !linux && !darwin

package server

import (
    "net"
    "runtime"
)

// getPeerCredentials returns an error on unsupported platforms.
// Windows does not support Unix domain socket peer credentials in the same way.
func getPeerCredentials(conn net.Conn) (*PeerCredentials, error) {
    return nil, &ErrPeerCredentialsUnavailable{
        Platform: runtime.GOOS,
        Reason:   "peer credentials require Unix domain sockets with SO_PEERCRED (Linux) or LOCAL_PEERCRED (macOS)",
    }
}
```

This ensures the code compiles on all platforms while clearly indicating when the feature isn't available.
  </action>
  <verify>GOOS=windows go build ./server/...</verify>
  <done>Default fallback compiles for Windows and other platforms</done>
</task>

<task type="auto">
  <name>Task 5: Add unit tests for peer credential extraction</name>
  <files>server/peercred_test.go</files>
  <action>
Create comprehensive tests for peer credential extraction:

```go
//go:build linux || darwin

package server

import (
    "net"
    "os"
    "path/filepath"
    "runtime"
    "testing"
)

func TestGetPeerCredentials_UnixSocket(t *testing.T) {
    // Create a temporary directory for the socket
    tmpDir, err := os.MkdirTemp("", "peercred-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "test.sock")

    // Create Unix socket listener
    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    // Connect to the socket in a goroutine
    done := make(chan struct{})
    go func() {
        defer close(done)
        conn, err := listener.Accept()
        if err != nil {
            t.Errorf("failed to accept: %v", err)
            return
        }
        defer conn.Close()

        creds, err := GetPeerCredentials(conn)
        if err != nil {
            t.Errorf("failed to get peer credentials: %v", err)
            return
        }

        // Verify we got valid credentials
        if creds.PID <= 0 {
            t.Errorf("expected positive PID, got %d", creds.PID)
        }

        // UID should match current process
        expectedUID := uint32(os.Getuid())
        if creds.UID != expectedUID {
            t.Errorf("expected UID %d, got %d", expectedUID, creds.UID)
        }

        // GID should match current process primary group
        expectedGID := uint32(os.Getgid())
        if creds.GID != expectedGID {
            t.Errorf("expected GID %d, got %d", expectedGID, creds.GID)
        }
    }()

    // Connect as client
    client, err := net.Dial("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to dial: %v", err)
    }
    client.Close()

    <-done
}

func TestGetPeerCredentials_TCPSocket_ReturnsError(t *testing.T) {
    // Create TCP listener
    listener, err := net.Listen("tcp", "127.0.0.1:0")
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    done := make(chan struct{})
    go func() {
        defer close(done)
        conn, err := listener.Accept()
        if err != nil {
            return
        }
        defer conn.Close()

        _, err = GetPeerCredentials(conn)
        if err == nil {
            t.Error("expected error for TCP socket, got nil")
            return
        }

        var notUnix *ErrNotUnixSocket
        if !errors.As(err, &notUnix) {
            t.Errorf("expected ErrNotUnixSocket, got %T", err)
        }
    }()

    client, err := net.Dial("tcp", listener.Addr().String())
    if err != nil {
        t.Fatalf("failed to dial: %v", err)
    }
    client.Close()

    <-done
}

func TestPeerCredentials_String(t *testing.T) {
    creds := &PeerCredentials{
        PID: 12345,
        UID: 1000,
        GID: 1000,
    }

    expected := "pid=12345 uid=1000 gid=1000"
    if creds.String() != expected {
        t.Errorf("expected %q, got %q", expected, creds.String())
    }
}

func TestGetPeerCredentials_VerifiesCurrentProcess(t *testing.T) {
    // This test verifies that we get our own process credentials when connecting
    // to ourselves via Unix socket
    tmpDir, err := os.MkdirTemp("", "peercred-self-test")
    if err != nil {
        t.Fatalf("failed to create temp dir: %v", err)
    }
    defer os.RemoveAll(tmpDir)

    socketPath := filepath.Join(tmpDir, "self.sock")

    listener, err := net.Listen("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to create listener: %v", err)
    }
    defer listener.Close()

    var serverCreds *PeerCredentials
    done := make(chan error)

    go func() {
        conn, err := listener.Accept()
        if err != nil {
            done <- err
            return
        }
        defer conn.Close()

        serverCreds, err = GetPeerCredentials(conn)
        done <- err
    }()

    client, err := net.Dial("unix", socketPath)
    if err != nil {
        t.Fatalf("failed to dial: %v", err)
    }
    client.Close()

    if err := <-done; err != nil {
        t.Fatalf("server error: %v", err)
    }

    // The client is our own process
    currentPID := int32(os.Getpid())
    if serverCreds.PID != currentPID {
        t.Errorf("expected PID %d (current process), got %d", currentPID, serverCreds.PID)
    }
}
```

Add `import "errors"` for errors.As.
  </action>
  <verify>go test ./server/... -run TestGetPeerCredentials -v</verify>
  <done>Tests pass on Linux/macOS, verify peer credentials match current process</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./server/...` succeeds on Linux, macOS, and Windows
- [ ] `go test ./server/... -run TestGetPeerCredentials` passes
- [ ] PeerCredentials correctly identifies current process in tests
- [ ] TCP connections return ErrNotUnixSocket
- [ ] No new dependencies added (uses existing golang.org/x/sys/unix)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Cross-platform build succeeds (Linux, macOS, Windows)
- Tests verify peer credential extraction accuracy
</success_criteria>

<output>
After completion, create `.planning/phases/129-local-server-security/129-01-SUMMARY.md`
</output>
