---
phase: 36-bootstrap-planner
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [bootstrap/planner.go, bootstrap/planner_test.go, bootstrap/format.go, bootstrap/format_test.go]
autonomous: true
---

<objective>
Implement dry-run planner that checks AWS SSM for existing parameters and produces a BootstrapPlan.

Purpose: Enable users to see what bootstrap would do before making changes (terraform plan-style workflow).
Output: Planner with SSM existence checks and formatted plan output.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-bootstrap-schema/35-01-SUMMARY.md

@bootstrap/types.go
@bootstrap/validate.go
@policy/loader.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SSM interface and Planner with existence checks</name>
  <files>bootstrap/planner.go, bootstrap/planner_test.go</files>
  <action>
Create bootstrap/planner.go:

1. Define `ssmAPI` interface with GetParameter method (following notification/sns.go pattern):
   ```go
   type ssmAPI interface {
       GetParameter(ctx context.Context, params *ssm.GetParameterInput, optFns ...func(*ssm.Options)) (*ssm.GetParameterOutput, error)
   }
   ```

2. Create `Planner` struct:
   ```go
   type Planner struct {
       ssm ssmAPI
   }

   func NewPlanner(cfg aws.Config) *Planner
   ```

3. Implement `Plan(ctx context.Context, config *BootstrapConfig) (*BootstrapPlan, error)`:
   - Validate config first (return error if invalid)
   - For each profile in config.Profiles:
     - Determine SSM parameter name (use ProfileConfig.PolicyParameterName if set, else DefaultPolicyParameterName)
     - Call ssm.GetParameter to check existence
     - If parameter exists: state=StateExists, capture version from response
     - If ParameterNotFound error: state=StateCreate
     - Other errors: return error
   - If config.GenerateIAMPolicies is true:
     - Add ResourceSpec for SentinelPolicyReader IAM policy (state=StateCreate, since we generate documents not actual IAM policies)
     - Add ResourceSpec for SentinelPolicyAdmin IAM policy (state=StateCreate)
   - Build BootstrapPlan with resources, compute summary, set GeneratedAt to time.Now()
   - Return plan

4. Add helper `checkSSMParameter(ctx, paramName) (exists bool, version string, err error)` that handles GetParameter call and error classification.

Create bootstrap/planner_test.go:
- Create mockSSMAPI struct implementing ssmAPI interface
- Test Plan() with mock returning parameter exists (verify StateExists, version captured)
- Test Plan() with mock returning ParameterNotFound (verify StateCreate)
- Test Plan() with mock returning other error (verify error propagated)
- Test Plan() validates config first (invalid config returns error without SSM calls)
- Test Plan() with multiple profiles (verify all checked)
- Test Plan() with GenerateIAMPolicies=true (verify IAM policy specs added)
- Test Plan() with custom PolicyParameterName (verify custom name used)
- Test Plan() computes summary correctly

Follow existing patterns:
- Use aws.String() for pointer params
- Use errors.As for ParameterNotFound detection (like policy/loader.go)
- Import ssm types from "github.com/aws/aws-sdk-go-v2/service/ssm/types"
  </action>
  <verify>go test ./bootstrap/... -v -run TestPlanner passes all tests</verify>
  <done>Planner.Plan() returns correct BootstrapPlan based on SSM parameter existence</done>
</task>

<task type="auto">
  <name>Task 2: Create plan output formatting</name>
  <files>bootstrap/format.go, bootstrap/format_test.go</files>
  <action>
Create bootstrap/format.go:

1. Implement `FormatPlan(plan *BootstrapPlan) string` for human-readable output:
   ```
   Bootstrap Plan
   ==============
   Policy Root: /sentinel/policies
   Region: us-east-1 (or "default" if empty)

   Resources:
     + /sentinel/policies/dev        (SSM Parameter - create)
     = /sentinel/policies/staging    (SSM Parameter - exists, v3)
     + /sentinel/policies/prod       (SSM Parameter - create)

   Summary: 2 to create, 0 to update, 1 existing
   ```

2. Use symbols for states:
   - `+` for StateCreate
   - `~` for StateUpdate
   - `=` for StateExists
   - `-` for StateSkip

3. Group by ResourceType if plan includes IAM policies:
   ```
   SSM Parameters:
     + /sentinel/policies/dev        (create)
     ...

   IAM Policy Documents:
     + SentinelPolicyReader          (generate)
     + SentinelPolicyAdmin           (generate)
   ```

4. Add `FormatPlanJSON(plan *BootstrapPlan) ([]byte, error)` for machine-readable output using json.MarshalIndent.

Create bootstrap/format_test.go:
- Test FormatPlan with mixed states (create, exists)
- Test FormatPlan with no changes (all exists/skip)
- Test FormatPlan with IAM policies included
- Test FormatPlan with empty resources
- Test FormatPlanJSON produces valid JSON
- Test FormatPlanJSON round-trips with BootstrapPlan struct
  </action>
  <verify>go test ./bootstrap/... -v -run TestFormat passes all tests</verify>
  <done>FormatPlan() produces clear, readable plan output with state indicators</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./... succeeds
- [ ] go test ./bootstrap/... passes all tests
- [ ] go vet ./bootstrap/... reports no issues
- [ ] Planner correctly identifies existing vs new SSM parameters
- [ ] FormatPlan output is clear and actionable
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Planner ready for bootstrap command integration (Phase 40)
- Format output ready for CLI display
</success_criteria>

<output>
After completion, create `.planning/phases/36-bootstrap-planner/36-01-SUMMARY.md`
</output>
