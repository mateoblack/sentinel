---
phase: 96-session-tracking-audit
plan: 02
title: Session Compliance Reporting
subsystem: audit
tags: [compliance, reporting, session-tracking, policy]

requires:
  - phase: 96-session-tracking-audit/01
    provides: UntrackedSessionsResult types
  - phase: 94-require-server-session
    provides: require_server_session policy effect
provides:
  - sentinel audit session-compliance command
  - Per-profile compliance metrics
  - Policy vs. actual tracking comparison
affects: [compliance, security-teams, audit]

tech-stack:
  added: []
  patterns: [compliance-reporting]

key-files:
  created: [audit/compliance.go]
  modified: [cli/audit.go]

key-decisions:
  - "Compare policy requirements with actual session tracking"
  - "Report compliance rate per profile"
  - "Identify profiles with require_server_session that have untracked access"

patterns-established:
  - "Compliance reporting with profile breakdown"
  - "Policy requirement verification"

issues-created: []
---

# Plan 96-02: Session Compliance Reporting

## Objective

Create `sentinel audit session-compliance` command that reports whether profiles with `require_server_session` policy are achieving 100% tracked sessions. This identifies compliance gaps where the policy exists but enforcement may have been bypassed.

## Command Interface

```bash
# Check compliance for all profiles
sentinel audit session-compliance --since 7d --region us-east-1 --table sentinel-sessions

# Check specific profile
sentinel audit session-compliance --profile prod --since 7d --region us-east-1 --table sentinel-sessions

# With policy file for requirement checking
sentinel audit session-compliance --policy ~/.sentinel/policy.yaml --since 7d --region us-east-1 --table sentinel-sessions

# JSON output
sentinel audit session-compliance --since 7d --json --region us-east-1 --table sentinel-sessions
```

## Compliance Report Output

```
Session Compliance Report
=========================

Time Window: 2026-01-17T00:00:00Z to 2026-01-24T00:00:00Z

Profile Compliance
------------------
Profile              Policy Required    Tracked    Untracked    Compliance
prod                 Yes               145        0            100.0%
staging              Yes               89         3            96.7%  ⚠
dev                  No                12         45           21.1%

Summary
-------
Profiles with require_server_session: 2
Fully compliant profiles: 1
Profiles with gaps: 1

Result: 1 profile(s) with compliance gaps
```

## Tasks

### Task 1: Create compliance types

**File:** `audit/compliance.go`

```go
package audit

import (
    "context"
    "time"
)

// SessionComplianceInput contains the input for compliance reporting.
type SessionComplianceInput struct {
    StartTime   time.Time
    EndTime     time.Time
    ProfileName string   // Optional: specific profile to check
    PolicyPath  string   // Optional: policy file for requirement checking
}

// ProfileCompliance represents compliance metrics for a single profile.
type ProfileCompliance struct {
    Profile        string  `json:"profile"`
    PolicyRequired bool    `json:"policy_required"`  // Does policy require session tracking?
    TrackedCount   int     `json:"tracked_count"`
    UntrackedCount int     `json:"untracked_count"`
    ComplianceRate float64 `json:"compliance_rate"`
    HasGap         bool    `json:"has_gap"`          // PolicyRequired && UntrackedCount > 0
}

// SessionComplianceResult contains the full compliance report.
type SessionComplianceResult struct {
    StartTime              time.Time           `json:"start_time"`
    EndTime                time.Time           `json:"end_time"`
    Profiles               []ProfileCompliance `json:"profiles"`
    RequiredProfiles       int                 `json:"required_profiles"`       // Profiles with require_server_session
    FullyCompliantProfiles int                 `json:"fully_compliant_profiles"`
    ProfilesWithGaps       int                 `json:"profiles_with_gaps"`
}

// HasComplianceGaps returns true if any required profile has untracked sessions.
func (r *SessionComplianceResult) HasComplianceGaps() bool {
    return r.ProfilesWithGaps > 0
}

// ComplianceReporter generates session compliance reports.
type ComplianceReporter interface {
    Report(ctx context.Context, input *SessionComplianceInput) (*SessionComplianceResult, error)
}
```

### Task 2: Implement compliance reporter

**File:** `audit/compliance.go` (append)

```go
import (
    "github.com/aws/aws-sdk-go-v2/aws"
    "github.com/byteness/aws-vault/v7/policy"
    "github.com/byteness/aws-vault/v7/session"
)

// Reporter implements ComplianceReporter.
type Reporter struct {
    cloudtrail cloudtrailAPI
    sessions   sessionStoreQuerier
    policy     *policy.Policy // Optional: for checking requirements
}

// sessionStoreQuerier interface for session queries.
type sessionStoreQuerier interface {
    ListByProfile(ctx context.Context, profile string, limit int) ([]*session.ServerSession, error)
    GetBySourceIdentity(ctx context.Context, sourceIdentity string) (*session.ServerSession, error)
}

// NewReporter creates a new compliance Reporter.
func NewReporter(cfg aws.Config, store sessionStoreQuerier, pol *policy.Policy) *Reporter {
    return &Reporter{
        cloudtrail: cloudtrail.NewFromConfig(cfg),
        sessions:   store,
        policy:     pol,
    }
}

// Report generates a compliance report for session tracking.
func (r *Reporter) Report(ctx context.Context, input *SessionComplianceInput) (*SessionComplianceResult, error) {
    result := &SessionComplianceResult{
        StartTime: input.StartTime,
        EndTime:   input.EndTime,
        Profiles:  []ProfileCompliance{},
    }

    // 1. Get all CloudTrail events in time window
    events, err := r.queryCloudTrailEvents(ctx, input.StartTime, input.EndTime)
    if err != nil {
        return nil, fmt.Errorf("failed to query CloudTrail: %w", err)
    }

    // 2. Group events by profile (extracted from SourceIdentity or role)
    profileEvents := groupEventsByProfile(events)

    // 3. For each profile, calculate compliance
    profiles := getProfileList(profileEvents, input.ProfileName)

    for _, profile := range profiles {
        events := profileEvents[profile]

        // Check if policy requires session tracking for this profile
        policyRequired := r.profileRequiresTracking(profile)

        // Count tracked vs untracked
        tracked, untracked := r.countTrackedEvents(ctx, events)

        complianceRate := 100.0
        if tracked+untracked > 0 {
            complianceRate = float64(tracked) / float64(tracked+untracked) * 100
        }

        pc := ProfileCompliance{
            Profile:        profile,
            PolicyRequired: policyRequired,
            TrackedCount:   tracked,
            UntrackedCount: untracked,
            ComplianceRate: complianceRate,
            HasGap:         policyRequired && untracked > 0,
        }

        result.Profiles = append(result.Profiles, pc)

        if policyRequired {
            result.RequiredProfiles++
            if untracked == 0 {
                result.FullyCompliantProfiles++
            } else {
                result.ProfilesWithGaps++
            }
        }
    }

    return result, nil
}

// profileRequiresTracking checks if policy requires session tracking for a profile.
func (r *Reporter) profileRequiresTracking(profile string) bool {
    if r.policy == nil {
        return false // No policy loaded, can't determine requirement
    }

    // Evaluate policy for this profile
    req := policy.Request{
        ProfileName: profile,
        // Minimal request for policy evaluation
    }

    decision := r.policy.Evaluate(req)
    return decision.Effect == policy.EffectRequireServerSession
}

// countTrackedEvents counts tracked vs untracked events.
func (r *Reporter) countTrackedEvents(ctx context.Context, events []cloudtrailEvent) (tracked, untracked int) {
    for _, event := range events {
        sourceIdentity := extractSourceIdentity(event)

        if sourceIdentity == "" || !isSentinelSourceIdentity(sourceIdentity) {
            untracked++
            continue
        }

        // Check if session exists
        sess, _ := r.sessions.GetBySourceIdentity(ctx, sourceIdentity)
        if sess != nil {
            tracked++
        } else {
            untracked++ // Orphaned counts as untracked for compliance
        }
    }
    return
}

// groupEventsByProfile groups CloudTrail events by the AWS profile.
func groupEventsByProfile(events []cloudtrailEvent) map[string][]cloudtrailEvent {
    result := make(map[string][]cloudtrailEvent)

    for _, event := range events {
        profile := extractProfileFromEvent(event)
        result[profile] = append(result[profile], event)
    }

    return result
}

// extractProfileFromEvent extracts the AWS profile name from CloudTrail event.
// Uses the assumed role name or extracts from SourceIdentity.
func extractProfileFromEvent(event cloudtrailEvent) string {
    // Try to extract from SourceIdentity first (if Sentinel format)
    sourceIdentity := extractSourceIdentity(event)
    if isSentinelSourceIdentity(sourceIdentity) {
        // SourceIdentity format: sentinel-<session_id>
        // We need to look up the session to get the profile
        // For now, use role name as proxy
    }

    // Extract from assumed role ARN
    roleARN := extractRoleARN(event)
    if roleARN != "" {
        // arn:aws:iam::123456789012:role/role-name -> role-name
        parts := strings.Split(roleARN, "/")
        if len(parts) > 1 {
            return parts[len(parts)-1]
        }
    }

    return "unknown"
}

func getProfileList(profileEvents map[string][]cloudtrailEvent, filterProfile string) []string {
    if filterProfile != "" {
        return []string{filterProfile}
    }

    profiles := make([]string, 0, len(profileEvents))
    for p := range profileEvents {
        profiles = append(profiles, p)
    }
    sort.Strings(profiles)
    return profiles
}
```

### Task 3: Add audit session-compliance CLI command

**File:** `cli/audit.go` (append)

```go
// AuditSessionComplianceCommandInput contains the input for the audit session-compliance command.
type AuditSessionComplianceCommandInput struct {
    Since      string // Duration string
    Until      string // Optional
    Region     string
    TableName  string
    Profile    string // Optional: specific profile
    PolicyPath string // Optional: policy file
    JSONOutput bool
    AWSProfile string

    // Reporter is an optional implementation for testing.
    Reporter audit.ComplianceReporter

    Stdout *os.File
    Stderr *os.File
}

// ConfigureAuditSessionComplianceCommand sets up the audit session-compliance command.
func ConfigureAuditSessionComplianceCommand(app *kingpin.Application, s *Sentinel) {
    input := AuditSessionComplianceCommandInput{}

    auditCmd := app.GetCommand("audit")

    cmd := auditCmd.Command("session-compliance", "Report session tracking compliance by profile")

    cmd.Flag("since", "How far back to search (e.g., 7d, 24h)").
        Required().
        StringVar(&input.Since)

    cmd.Flag("until", "End of search window (default: now)").
        StringVar(&input.Until)

    cmd.Flag("region", "AWS region for CloudTrail and DynamoDB").
        Required().
        StringVar(&input.Region)

    cmd.Flag("table", "DynamoDB table name for sessions").
        Required().
        StringVar(&input.TableName)

    cmd.Flag("profile", "Check specific profile only").
        StringVar(&input.Profile)

    cmd.Flag("policy", "Policy file for requirement checking").
        StringVar(&input.PolicyPath)

    cmd.Flag("json", "Output in JSON format").
        BoolVar(&input.JSONOutput)

    cmd.Flag("aws-profile", "AWS profile for credentials").
        StringVar(&input.AWSProfile)

    cmd.Action(func(c *kingpin.ParseContext) error {
        err := AuditSessionComplianceCommand(context.Background(), input)
        if err != nil {
            if strings.Contains(err.Error(), "compliance gap") {
                os.Exit(1)
            }
            app.FatalIfError(err, "audit session-compliance")
        }
        return nil
    })
}

// AuditSessionComplianceCommand executes the audit session-compliance command logic.
func AuditSessionComplianceCommand(ctx context.Context, input AuditSessionComplianceCommandInput) error {
    stdout := input.Stdout
    if stdout == nil {
        stdout = os.Stdout
    }
    stderr := input.Stderr
    if stderr == nil {
        stderr = os.Stderr
    }

    // Parse time window
    sinceDuration, err := ParseDuration(input.Since)
    if err != nil {
        fmt.Fprintf(stderr, "Invalid --since duration: %v\n", err)
        return err
    }

    endTime := time.Now()
    if input.Until != "" {
        untilDuration, err := ParseDuration(input.Until)
        if err != nil {
            fmt.Fprintf(stderr, "Invalid --until duration: %v\n", err)
            return err
        }
        endTime = time.Now().Add(-untilDuration)
    }
    startTime := endTime.Add(-sinceDuration)

    // Load policy if specified
    var pol *policy.Policy
    if input.PolicyPath != "" {
        pol, err = policy.LoadFile(input.PolicyPath)
        if err != nil {
            fmt.Fprintf(stderr, "Failed to load policy: %v\n", err)
            return err
        }
    }

    // Get or create reporter
    reporter := input.Reporter
    if reporter == nil {
        awsCfgOpts := []func(*config.LoadOptions) error{
            config.WithRegion(input.Region),
        }
        if input.AWSProfile != "" {
            awsCfgOpts = append(awsCfgOpts, config.WithSharedConfigProfile(input.AWSProfile))
        }
        awsCfg, err := config.LoadDefaultConfig(ctx, awsCfgOpts...)
        if err != nil {
            fmt.Fprintf(stderr, "Failed to load AWS config: %v\n", err)
            return err
        }

        store := session.NewDynamoDBStore(awsCfg, input.TableName)
        reporter = audit.NewReporter(awsCfg, store, pol)
    }

    // Generate report
    reportInput := &audit.SessionComplianceInput{
        StartTime:   startTime,
        EndTime:     endTime,
        ProfileName: input.Profile,
        PolicyPath:  input.PolicyPath,
    }

    result, err := reporter.Report(ctx, reportInput)
    if err != nil {
        fmt.Fprintf(stderr, "Failed to generate compliance report: %v\n", err)
        return err
    }

    // Output results
    if input.JSONOutput {
        jsonBytes, err := json.MarshalIndent(result, "", "  ")
        if err != nil {
            fmt.Fprintf(stderr, "Failed to format results as JSON: %v\n", err)
            return err
        }
        fmt.Fprintln(stdout, string(jsonBytes))
    } else {
        outputComplianceHumanFormat(stdout, result)
    }

    // Return error if compliance gaps found
    if result.HasComplianceGaps() {
        return fmt.Errorf("%d profile(s) with compliance gaps", result.ProfilesWithGaps)
    }

    return nil
}

func outputComplianceHumanFormat(stdout *os.File, result *audit.SessionComplianceResult) {
    fmt.Fprintln(stdout, "Session Compliance Report")
    fmt.Fprintln(stdout, "=========================")
    fmt.Fprintln(stdout)

    fmt.Fprintf(stdout, "Time Window: %s to %s\n",
        result.StartTime.Format(time.RFC3339),
        result.EndTime.Format(time.RFC3339))
    fmt.Fprintln(stdout)

    fmt.Fprintln(stdout, "Profile Compliance")
    fmt.Fprintln(stdout, "------------------")
    fmt.Printf("%-20s  %-15s  %-10s  %-10s  %s\n",
        "Profile", "Policy Required", "Tracked", "Untracked", "Compliance")
    fmt.Println("--------------------  ---------------  ----------  ----------  ----------")

    for _, p := range result.Profiles {
        required := "No"
        if p.PolicyRequired {
            required = "Yes"
        }

        gap := ""
        if p.HasGap {
            gap = " ⚠"
        }

        fmt.Printf("%-20s  %-15s  %-10d  %-10d  %.1f%%%s\n",
            truncateString(p.Profile, 20),
            required,
            p.TrackedCount,
            p.UntrackedCount,
            p.ComplianceRate,
            gap,
        )
    }
    fmt.Fprintln(stdout)

    fmt.Fprintln(stdout, "Summary")
    fmt.Fprintln(stdout, "-------")
    fmt.Fprintf(stdout, "Profiles with require_server_session: %d\n", result.RequiredProfiles)
    fmt.Fprintf(stdout, "Fully compliant profiles: %d\n", result.FullyCompliantProfiles)
    fmt.Fprintf(stdout, "Profiles with gaps: %d\n", result.ProfilesWithGaps)
    fmt.Fprintln(stdout)

    if result.HasComplianceGaps() {
        fmt.Fprintf(stdout, "Result: %d profile(s) with compliance gaps\n", result.ProfilesWithGaps)
    } else {
        fmt.Fprintln(stdout, "Result: All required profiles fully compliant")
    }
}
```

### Task 4: Register command in main.go

**File:** `cmd/sentinel/main.go`

Add call to `cli.ConfigureAuditSessionComplianceCommand(app, s)`.

### Task 5: Add unit tests

**File:** `audit/compliance_test.go`

```go
func TestSessionComplianceResult_HasComplianceGaps(t *testing.T) {
    tests := []struct {
        name     string
        result   SessionComplianceResult
        expected bool
    }{
        {
            name: "no gaps",
            result: SessionComplianceResult{
                ProfilesWithGaps: 0,
            },
            expected: false,
        },
        {
            name: "has gaps",
            result: SessionComplianceResult{
                ProfilesWithGaps: 1,
            },
            expected: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := tt.result.HasComplianceGaps(); got != tt.expected {
                t.Errorf("HasComplianceGaps() = %v, want %v", got, tt.expected)
            }
        })
    }
}
```

**File:** `cli/audit_test.go` (append)

```go
func TestAuditSessionComplianceCommand(t *testing.T) {
    tests := []struct {
        name       string
        input      AuditSessionComplianceCommandInput
        mockResult *audit.SessionComplianceResult
        wantErr    bool
    }{
        {
            name: "all compliant",
            input: AuditSessionComplianceCommandInput{
                Since:     "7d",
                Region:    "us-east-1",
                TableName: "test-sessions",
            },
            mockResult: &audit.SessionComplianceResult{
                RequiredProfiles:       2,
                FullyCompliantProfiles: 2,
                ProfilesWithGaps:       0,
            },
            wantErr: false,
        },
        {
            name: "compliance gaps",
            input: AuditSessionComplianceCommandInput{
                Since:     "7d",
                Region:    "us-east-1",
                TableName: "test-sessions",
            },
            mockResult: &audit.SessionComplianceResult{
                RequiredProfiles:       2,
                FullyCompliantProfiles: 1,
                ProfilesWithGaps:       1,
            },
            wantErr: true,
        },
    }
    // ... test implementation
}
```

## Verification

```bash
# Build and test
go build ./...
go test ./cli/... ./audit/...

# Manual verification
sentinel audit session-compliance --since 7d --region us-east-1 --table sentinel-sessions
sentinel audit session-compliance --profile prod --policy ~/.sentinel/policy.yaml --since 7d --region us-east-1 --table sentinel-sessions
```

## Exit Criteria

1. `sentinel audit session-compliance` command implemented
2. Reports compliance rate per profile
3. Shows policy requirement status when --policy provided
4. Identifies profiles with compliance gaps
5. JSON output for automation
6. Non-zero exit code when gaps found
7. Unit tests pass
