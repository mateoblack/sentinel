---
phase: 96-session-tracking-audit
plan: 03
title: CSV/JSON Export for Audit
subsystem: cli
tags: [export, audit, csv, json, compliance]

requires:
  - phase: 81-session-management
    provides: server-sessions command
provides:
  - CSV export format for server-sessions
  - --since flag for time-based filtering
  - Audit-friendly session exports
affects: [compliance, audit, security-teams]

tech-stack:
  added: [encoding/csv]
  patterns: [csv-export]

key-files:
  created: []
  modified: [cli/sentinel_server.go, session/store.go, session/dynamodb.go]

key-decisions:
  - "Add --format csv alongside existing human/json"
  - "Add --since flag for time-based filtering"
  - "CSV format includes all audit-relevant fields"

patterns-established:
  - "CSV export pattern for CLI commands"
  - "Time-based query filtering"

issues-created: []
---

# Plan 96-03: CSV/JSON Export for Audit

## Objective

Enhance `sentinel server-sessions` command with CSV export format and time-based filtering for audit compliance reporting.

## Command Interface

```bash
# Export last 30 days to CSV
sentinel server-sessions --format csv --since 30d --region us-east-1 --table sentinel-sessions > sessions.csv

# Export all active sessions to JSON
sentinel server-sessions --format json --status active --region us-east-1 --table sentinel-sessions

# Export specific profile sessions
sentinel server-sessions --format csv --profile prod --since 7d --region us-east-1 --table sentinel-sessions
```

## CSV Format

```csv
id,user,profile,status,started_at,last_access_at,expires_at,request_count,server_instance_id,source_identity
a1b2c3d4e5f67890,alice,prod,active,2026-01-20T10:00:00Z,2026-01-24T15:30:00Z,2026-01-20T18:00:00Z,145,srv-abc123,sentinel-a1b2c3d4e5f67890
```

## Tasks

### Task 1: Add --since flag and --format csv to server-sessions

**File:** `cli/sentinel_server.go`

Update `ServerSessionsCommandInput`:

```go
type ServerSessionsCommandInput struct {
    Region       string
    TableName    string
    Status       string // Optional filter: active, revoked, expired
    User         string // Optional filter by user
    Profile      string // Optional filter by AWS profile served
    Limit        int
    OutputFormat string // human, json, csv
    Since        string // Duration: "7d", "30d", etc.
    AWSProfile   string // For SSO credential loading

    // Store is an optional Store implementation for testing.
    // If nil, a DynamoDB store will be created using the TableName and Region.
    Store session.Store

    // STSClient is an optional STS client for AWS identity extraction.
    // If nil, a new client will be created from AWS config.
    STSClient identity.STSAPI
}
```

Update `ConfigureServerSessionsCommand`:

```go
func ConfigureServerSessionsCommand(app *kingpin.Application, s *Sentinel) {
    input := ServerSessionsCommandInput{}

    cmd := app.Command("server-sessions", "List server sessions")

    // ... existing flags ...

    cmd.Flag("output", "Output format (human, json, csv)").
        Default("human").
        EnumVar(&input.OutputFormat, "human", "json", "csv")

    cmd.Flag("since", "Only show sessions started within this duration (e.g., 7d, 30d)").
        StringVar(&input.Since)

    // ... rest of configuration ...
}
```

### Task 2: Add ListByTimeRange method to session store

**File:** `session/store.go`

Add to Store interface:

```go
// ListByTimeRange retrieves sessions created within a time range.
// Results are sorted by created_at descending.
ListByTimeRange(ctx context.Context, startTime, endTime time.Time, limit int) ([]*ServerSession, error)
```

**File:** `session/dynamodb.go`

```go
// ListByTimeRange retrieves sessions created within a time range.
// Uses a scan with filter since we don't have a GSI on created_at.
// For audit queries, this is acceptable.
func (s *DynamoDBStore) ListByTimeRange(ctx context.Context, startTime, endTime time.Time, limit int) ([]*ServerSession, error) {
    limit = enforceLimit(limit)

    input := &dynamodb.ScanInput{
        TableName:        aws.String(s.tableName),
        FilterExpression: aws.String("created_at BETWEEN :start AND :end"),
        ExpressionAttributeValues: map[string]types.AttributeValue{
            ":start": &types.AttributeValueMemberS{Value: startTime.Format(time.RFC3339Nano)},
            ":end":   &types.AttributeValueMemberS{Value: endTime.Format(time.RFC3339Nano)},
        },
        Limit: aws.Int32(int32(limit)),
    }

    var sessions []*ServerSession
    paginator := dynamodb.NewScanPaginator(s.client, input)

    for paginator.HasMorePages() && len(sessions) < limit {
        page, err := paginator.NextPage(ctx)
        if err != nil {
            return nil, fmt.Errorf("failed to scan sessions by time range: %w", err)
        }

        for _, item := range page.Items {
            sess, err := unmarshalSession(item)
            if err != nil {
                continue // Skip invalid items
            }
            sessions = append(sessions, sess)
            if len(sessions) >= limit {
                break
            }
        }
    }

    // Sort by created_at descending
    sort.Slice(sessions, func(i, j int) bool {
        return sessions[i].CreatedAt.After(sessions[j].CreatedAt)
    })

    return sessions, nil
}
```

### Task 3: Update ServerSessionsCommand to support --since and CSV

**File:** `cli/sentinel_server.go`

```go
import (
    "encoding/csv"
    // ... existing imports ...
)

// ServerSessionsCommand executes the server sessions command logic.
func ServerSessionsCommand(ctx context.Context, input ServerSessionsCommandInput) error {
    // 1. Load AWS config (needed for STS and DynamoDB)
    awsCfgOpts := []func(*config.LoadOptions) error{}
    if input.AWSProfile != "" {
        awsCfgOpts = append(awsCfgOpts, config.WithSharedConfigProfile(input.AWSProfile))
    }
    if input.Region != "" {
        awsCfgOpts = append(awsCfgOpts, config.WithRegion(input.Region))
    }
    awsCfg, err := config.LoadDefaultConfig(ctx, awsCfgOpts...)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Failed to load AWS config: %v\n", err)
        return err
    }

    // 2. Get AWS identity if User not specified and no other filter
    user := input.User
    if user == "" && input.Status == "" && input.Profile == "" && input.Since == "" {
        stsClient := input.STSClient
        if stsClient == nil {
            stsClient = sts.NewFromConfig(awsCfg)
        }
        user, err = identity.GetAWSUsername(ctx, stsClient)
        if err != nil {
            fmt.Fprintf(os.Stderr, "Failed to get AWS identity: %v\n", err)
            return err
        }
    }

    // 3. Get or create store
    store := input.Store
    if store == nil {
        store = session.NewDynamoDBStore(awsCfg, input.TableName)
    }

    // 4. Parse --since if provided
    var sinceTime time.Time
    if input.Since != "" {
        sinceDuration, err := ParseDuration(input.Since)
        if err != nil {
            fmt.Fprintf(os.Stderr, "Invalid --since duration: %v\n", err)
            return err
        }
        sinceTime = time.Now().Add(-sinceDuration)
    }

    // 5. Query based on flags
    var sessions []*session.ServerSession
    limit := input.Limit

    if input.Since != "" {
        // Time-based query
        sessions, err = store.ListByTimeRange(ctx, sinceTime, time.Now(), limit)
        if err != nil {
            fmt.Fprintf(os.Stderr, "Failed to list sessions: %v\n", err)
            return err
        }

        // Apply additional filters if specified
        sessions = filterSessions(sessions, input.Status, input.Profile, input.User)
    } else if input.Status != "" {
        // Query by status
        status := session.SessionStatus(input.Status)
        if !status.IsValid() {
            fmt.Fprintf(os.Stderr, "Invalid status: %s (valid: active, revoked, expired)\n", input.Status)
            return fmt.Errorf("invalid status: %s", input.Status)
        }
        sessions, err = store.ListByStatus(ctx, status, limit)
    } else if input.Profile != "" {
        // Query by profile
        sessions, err = store.ListByProfile(ctx, input.Profile, limit)
    } else if user != "" {
        // Query by user
        sessions, err = store.ListByUser(ctx, user, limit)
    } else {
        // Default to active sessions
        sessions, err = store.ListByStatus(ctx, session.StatusActive, limit)
    }

    if err != nil {
        fmt.Fprintf(os.Stderr, "Failed to list sessions: %v\n", err)
        return err
    }

    // 6. Filter by user if specified AND query was not by user
    if input.User != "" && (input.Status != "" || input.Profile != "" || input.Since != "") {
        filtered := make([]*session.ServerSession, 0, len(sessions))
        for _, sess := range sessions {
            if sess.User == input.User {
                filtered = append(filtered, sess)
            }
        }
        sessions = filtered
    }

    // 7. Format output
    summaries := make([]ServerSessionSummary, 0, len(sessions))
    for _, sess := range sessions {
        summaries = append(summaries, ServerSessionSummary{
            ID:               sess.ID,
            User:             sess.User,
            Profile:          sess.Profile,
            Status:           string(sess.Status),
            StartedAt:        sess.StartedAt,
            LastAccessAt:     sess.LastAccessAt,
            ExpiresAt:        sess.ExpiresAt,
            RequestCount:     sess.RequestCount,
            ServerInstanceID: sess.ServerInstanceID,
            SourceIdentity:   sess.SourceIdentity, // Add this field
        })
    }

    switch input.OutputFormat {
    case "json":
        output := ServerSessionsCommandOutput{
            Sessions: summaries,
        }
        jsonBytes, err := json.MarshalIndent(&output, "", "  ")
        if err != nil {
            fmt.Fprintf(os.Stderr, "Failed to marshal output to JSON: %v\n", err)
            return err
        }
        fmt.Println(string(jsonBytes))

    case "csv":
        if err := outputSessionsCSV(os.Stdout, summaries); err != nil {
            fmt.Fprintf(os.Stderr, "Failed to write CSV: %v\n", err)
            return err
        }

    default: // human
        if len(summaries) == 0 {
            fmt.Println("No sessions found.")
            return nil
        }

        // Print header
        fmt.Printf("%-16s  %-12s  %-20s  %-8s  %-20s  %-20s  %s\n",
            "ID", "User", "Profile", "Status", "Started", "Last Access", "Requests")
        fmt.Println("----------------  ------------  --------------------  --------  --------------------  --------------------  --------")

        for _, s := range summaries {
            fmt.Printf("%-16s  %-12s  %-20s  %-8s  %-20s  %-20s  %d\n",
                s.ID,
                truncateString(s.User, 12),
                truncateString(s.Profile, 20),
                s.Status,
                s.StartedAt.Format("2006-01-02 15:04:05"),
                s.LastAccessAt.Format("2006-01-02 15:04:05"),
                s.RequestCount,
            )
        }
    }

    return nil
}

// filterSessions filters sessions by status, profile, and user.
func filterSessions(sessions []*session.ServerSession, status, profile, user string) []*session.ServerSession {
    result := sessions

    if status != "" {
        filtered := make([]*session.ServerSession, 0)
        for _, s := range result {
            if string(s.Status) == status {
                filtered = append(filtered, s)
            }
        }
        result = filtered
    }

    if profile != "" {
        filtered := make([]*session.ServerSession, 0)
        for _, s := range result {
            if s.Profile == profile {
                filtered = append(filtered, s)
            }
        }
        result = filtered
    }

    if user != "" {
        filtered := make([]*session.ServerSession, 0)
        for _, s := range result {
            if s.User == user {
                filtered = append(filtered, s)
            }
        }
        result = filtered
    }

    return result
}

// outputSessionsCSV writes sessions in CSV format.
func outputSessionsCSV(w io.Writer, sessions []ServerSessionSummary) error {
    writer := csv.NewWriter(w)
    defer writer.Flush()

    // Write header
    header := []string{
        "id",
        "user",
        "profile",
        "status",
        "started_at",
        "last_access_at",
        "expires_at",
        "request_count",
        "server_instance_id",
        "source_identity",
    }
    if err := writer.Write(header); err != nil {
        return err
    }

    // Write rows
    for _, s := range sessions {
        row := []string{
            s.ID,
            s.User,
            s.Profile,
            s.Status,
            s.StartedAt.Format(time.RFC3339),
            s.LastAccessAt.Format(time.RFC3339),
            s.ExpiresAt.Format(time.RFC3339),
            fmt.Sprintf("%d", s.RequestCount),
            s.ServerInstanceID,
            s.SourceIdentity,
        }
        if err := writer.Write(row); err != nil {
            return err
        }
    }

    return nil
}
```

### Task 4: Add SourceIdentity to ServerSessionSummary

**File:** `cli/sentinel_server.go`

Update the struct:

```go
// ServerSessionSummary represents a single session in the list output.
type ServerSessionSummary struct {
    ID               string    `json:"id"`
    User             string    `json:"user"`
    Profile          string    `json:"profile"`
    Status           string    `json:"status"`
    StartedAt        time.Time `json:"started_at"`
    LastAccessAt     time.Time `json:"last_access_at"`
    ExpiresAt        time.Time `json:"expires_at"`
    RequestCount     int64     `json:"request_count"`
    ServerInstanceID string    `json:"server_instance_id"`
    SourceIdentity   string    `json:"source_identity"` // ADD THIS
}
```

Update the mapping in `ServerSessionsCommand`:

```go
summaries = append(summaries, ServerSessionSummary{
    // ... existing fields ...
    SourceIdentity:   sess.SourceIdentity, // ADD THIS
})
```

### Task 5: Add unit tests

**File:** `cli/sentinel_server_test.go`

```go
func TestServerSessionsCommand_CSVOutput(t *testing.T) {
    // Create mock store with test sessions
    mockStore := &mockSessionStore{
        sessions: []*session.ServerSession{
            {
                ID:               "a1b2c3d4e5f67890",
                User:             "alice",
                Profile:          "prod",
                Status:           session.StatusActive,
                StartedAt:        time.Date(2026, 1, 20, 10, 0, 0, 0, time.UTC),
                LastAccessAt:     time.Date(2026, 1, 24, 15, 30, 0, 0, time.UTC),
                ExpiresAt:        time.Date(2026, 1, 20, 18, 0, 0, 0, time.UTC),
                RequestCount:     145,
                ServerInstanceID: "srv-abc123",
                SourceIdentity:   "sentinel-a1b2c3d4e5f67890",
            },
        },
    }

    var buf bytes.Buffer
    input := ServerSessionsCommandInput{
        Region:       "us-east-1",
        TableName:    "test-table",
        OutputFormat: "csv",
        Status:       "active",
        Store:        mockStore,
    }

    err := ServerSessionsCommand(context.Background(), input)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    // Verify CSV output contains expected fields
    output := buf.String()
    if !strings.Contains(output, "id,user,profile,status") {
        t.Error("CSV header missing expected columns")
    }
    if !strings.Contains(output, "a1b2c3d4e5f67890") {
        t.Error("CSV data missing session ID")
    }
}

func TestServerSessionsCommand_SinceFlag(t *testing.T) {
    mockStore := &mockSessionStore{}

    input := ServerSessionsCommandInput{
        Region:       "us-east-1",
        TableName:    "test-table",
        OutputFormat: "human",
        Since:        "7d",
        Store:        mockStore,
    }

    err := ServerSessionsCommand(context.Background(), input)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    // Verify ListByTimeRange was called
    if !mockStore.listByTimeRangeCalled {
        t.Error("Expected ListByTimeRange to be called with --since flag")
    }
}
```

**File:** `session/dynamodb_test.go`

```go
func TestDynamoDBStore_ListByTimeRange(t *testing.T) {
    // Test with mock DynamoDB client
    // Verify correct filter expression and time range handling
}
```

### Task 6: Update documentation

**File:** `docs/guide/commands.md`

Add to server-sessions documentation:

```markdown
### Export Formats

The `--output` flag supports three formats:

- `human` (default): Human-readable table format
- `json`: JSON format for programmatic consumption
- `csv`: CSV format for audit exports and spreadsheet analysis

### Time-Based Filtering

Use `--since` to filter sessions by creation time:

```bash
# Sessions from the last 7 days
sentinel server-sessions --since 7d --region us-east-1 --table sentinel-sessions

# Sessions from the last 30 days, exported to CSV
sentinel server-sessions --format csv --since 30d --region us-east-1 --table sentinel-sessions > audit.csv
```

### Audit Export Example

For compliance reporting, export all sessions to CSV:

```bash
# Monthly audit export
sentinel server-sessions \
  --format csv \
  --since 30d \
  --region us-east-1 \
  --table sentinel-sessions \
  > monthly-sessions-$(date +%Y-%m).csv
```
```

## Verification

```bash
# Build and test
go build ./...
go test ./cli/... ./session/...

# Manual verification
sentinel server-sessions --format csv --since 7d --region us-east-1 --table sentinel-sessions
sentinel server-sessions --format json --status active --region us-east-1 --table sentinel-sessions
```

## Exit Criteria

1. `--format csv` produces valid CSV output
2. `--since` flag filters sessions by creation time
3. CSV includes all audit-relevant fields (source_identity added)
4. Works with existing filters (--status, --profile, --user)
5. Documentation updated
6. Unit tests pass
