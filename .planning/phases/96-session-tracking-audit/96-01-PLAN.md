---
phase: 96-session-tracking-audit
plan: 01
title: Untracked Session Detection via CloudTrail
subsystem: audit
tags: [cloudtrail, compliance, session-tracking, detection]

requires:
  - phase: 46-cloudtrail-query-types
    provides: CloudTrail verifier infrastructure
  - phase: 90-session-table-provisioning
    provides: DynamoDB session store
provides:
  - sentinel audit untracked-sessions command
  - Cross-reference CloudTrail with DynamoDB sessions
affects: [compliance, audit, security-teams]

tech-stack:
  added: []
  patterns: [cloudtrail-dynamodb-correlation]

key-files:
  created: []
  modified: [cli/audit.go, audit/untracked.go]

key-decisions:
  - "Use --since duration format for relative time queries"
  - "Cross-reference CloudTrail AssumeRole events with DynamoDB sessions by SourceIdentity"
  - "Report sessions in CloudTrail that have no corresponding tracked session"

patterns-established:
  - "Duration-based time flags (--since 7d, --until 3d)"
  - "CloudTrail to DynamoDB correlation via SourceIdentity"

issues-created: []
---

# Plan 96-01: Untracked Session Detection via CloudTrail

## Objective

Create `sentinel audit untracked-sessions` command that identifies credential usage in CloudTrail that bypassed Sentinel session tracking, providing visibility into compliance gaps.

## Command Interface

```bash
# Detect untracked sessions in the last 7 days
sentinel audit untracked-sessions --since 7d --region us-east-1 --table sentinel-sessions

# Filter by profile
sentinel audit untracked-sessions --since 7d --profile prod --region us-east-1 --table sentinel-sessions

# JSON output for automation
sentinel audit untracked-sessions --since 7d --json --region us-east-1 --table sentinel-sessions
```

## Detection Logic

1. Query CloudTrail for AssumeRole events with SourceIdentity
2. Query DynamoDB sessions table for sessions in the same time window
3. For each CloudTrail event:
   - If SourceIdentity matches a tracked session: **tracked**
   - If SourceIdentity has Sentinel format but no session found: **orphaned** (session expired/deleted)
   - If no SourceIdentity or non-Sentinel format: **untracked** (bypassed Sentinel)
4. Report untracked sessions as compliance gaps

## Tasks

### Task 1: Add duration parsing utility

Create utility to parse relative duration strings like "7d", "24h", "30m".

**File:** `cli/time_utils.go`

```go
package cli

import (
    "fmt"
    "strconv"
    "strings"
    "time"
)

// ParseDuration parses a duration string with support for days (d).
// Examples: "7d", "24h", "30m", "1d12h"
func ParseDuration(s string) (time.Duration, error) {
    // Handle days specially since time.ParseDuration doesn't support 'd'
    if strings.Contains(s, "d") {
        // Split on 'd' and convert days to hours
        parts := strings.SplitN(s, "d", 2)
        days, err := strconv.Atoi(parts[0])
        if err != nil {
            return 0, fmt.Errorf("invalid duration: %s", s)
        }
        daysDuration := time.Duration(days) * 24 * time.Hour

        // If there's a remainder after 'd', parse it
        if len(parts) > 1 && parts[1] != "" {
            remainder, err := time.ParseDuration(parts[1])
            if err != nil {
                return 0, fmt.Errorf("invalid duration: %s", s)
            }
            return daysDuration + remainder, nil
        }
        return daysDuration, nil
    }

    // Standard duration parsing
    return time.ParseDuration(s)
}
```

### Task 2: Create untracked session detection types

**File:** `audit/untracked.go`

```go
package audit

import (
    "context"
    "time"

    "github.com/aws/aws-sdk-go-v2/aws"
)

// UntrackedSessionsInput contains the input for untracked session detection.
type UntrackedSessionsInput struct {
    StartTime   time.Time
    EndTime     time.Time
    RoleARN     string // Optional: filter by role
    ProfileName string // Optional: filter by profile (matched via SourceIdentity)
}

// UntrackedSession represents a CloudTrail event without a tracked session.
type UntrackedSession struct {
    EventID       string    `json:"event_id"`
    EventTime     time.Time `json:"event_time"`
    RoleARN       string    `json:"role_arn"`
    PrincipalID   string    `json:"principal_id"`
    SourceIP      string    `json:"source_ip"`
    UserAgent     string    `json:"user_agent"`
    SourceIdentity string   `json:"source_identity,omitempty"`
    Category      UntrackedCategory `json:"category"`
    Reason        string    `json:"reason"`
}

// UntrackedCategory indicates why a session is untracked.
type UntrackedCategory string

const (
    CategoryNoSourceIdentity UntrackedCategory = "no_source_identity"  // No SourceIdentity set
    CategoryNonSentinel      UntrackedCategory = "non_sentinel_format" // SourceIdentity not in Sentinel format
    CategoryOrphaned         UntrackedCategory = "orphaned"            // Sentinel format but session not found
)

// UntrackedSessionsResult contains the results of untracked session detection.
type UntrackedSessionsResult struct {
    StartTime        time.Time          `json:"start_time"`
    EndTime          time.Time          `json:"end_time"`
    TotalEvents      int                `json:"total_events"`
    TrackedEvents    int                `json:"tracked_events"`
    UntrackedEvents  int                `json:"untracked_events"`
    OrphanedEvents   int                `json:"orphaned_events"`
    UntrackedSessions []UntrackedSession `json:"untracked_sessions"`
}

// ComplianceRate returns the percentage of events that were properly tracked.
func (r *UntrackedSessionsResult) ComplianceRate() float64 {
    if r.TotalEvents == 0 {
        return 100.0
    }
    return float64(r.TrackedEvents) / float64(r.TotalEvents) * 100
}

// UntrackedSessionsDetector detects sessions that bypassed tracking.
type UntrackedSessionsDetector interface {
    Detect(ctx context.Context, input *UntrackedSessionsInput) (*UntrackedSessionsResult, error)
}
```

### Task 3: Implement untracked session detector

**File:** `audit/untracked.go` (append)

```go
// Detector implements UntrackedSessionsDetector using CloudTrail and DynamoDB.
type Detector struct {
    cloudtrail cloudtrailAPI
    sessions   sessionStore
}

// sessionStore interface for DynamoDB session queries.
type sessionStore interface {
    GetBySourceIdentity(ctx context.Context, sourceIdentity string) (*session.ServerSession, error)
}

// NewDetector creates a new Detector with CloudTrail and session store.
func NewDetector(cfg aws.Config, store sessionStore) *Detector {
    return &Detector{
        cloudtrail: cloudtrail.NewFromConfig(cfg),
        sessions:   store,
    }
}

// Detect finds untracked sessions by cross-referencing CloudTrail with DynamoDB.
func (d *Detector) Detect(ctx context.Context, input *UntrackedSessionsInput) (*UntrackedSessionsResult, error) {
    result := &UntrackedSessionsResult{
        StartTime:         input.StartTime,
        EndTime:           input.EndTime,
        UntrackedSessions: []UntrackedSession{},
    }

    // 1. Query CloudTrail for AssumeRole events
    events, err := d.queryCloudTrail(ctx, input)
    if err != nil {
        return nil, fmt.Errorf("failed to query CloudTrail: %w", err)
    }

    result.TotalEvents = len(events)

    // 2. Cross-reference each event with session store
    for _, event := range events {
        sourceIdentity := extractSourceIdentity(event)

        if sourceIdentity == "" {
            // No SourceIdentity - untracked
            result.UntrackedEvents++
            result.UntrackedSessions = append(result.UntrackedSessions, UntrackedSession{
                EventID:     aws.ToString(event.EventId),
                EventTime:   aws.ToTime(event.EventTime),
                RoleARN:     extractRoleARN(event),
                PrincipalID: extractPrincipalID(event),
                SourceIP:    aws.ToString(event.SourceIPAddress),
                UserAgent:   extractUserAgent(event),
                Category:    CategoryNoSourceIdentity,
                Reason:      "No SourceIdentity set on AssumeRole call",
            })
            continue
        }

        // Check if SourceIdentity is in Sentinel format
        if !isSentinelSourceIdentity(sourceIdentity) {
            result.UntrackedEvents++
            result.UntrackedSessions = append(result.UntrackedSessions, UntrackedSession{
                EventID:        aws.ToString(event.EventId),
                EventTime:      aws.ToTime(event.EventTime),
                RoleARN:        extractRoleARN(event),
                PrincipalID:    extractPrincipalID(event),
                SourceIP:       aws.ToString(event.SourceIPAddress),
                UserAgent:      extractUserAgent(event),
                SourceIdentity: sourceIdentity,
                Category:       CategoryNonSentinel,
                Reason:         "SourceIdentity not in Sentinel format",
            })
            continue
        }

        // Check if session exists in DynamoDB
        sess, err := d.sessions.GetBySourceIdentity(ctx, sourceIdentity)
        if err != nil || sess == nil {
            result.OrphanedEvents++
            result.UntrackedSessions = append(result.UntrackedSessions, UntrackedSession{
                EventID:        aws.ToString(event.EventId),
                EventTime:      aws.ToTime(event.EventTime),
                RoleARN:        extractRoleARN(event),
                PrincipalID:    extractPrincipalID(event),
                SourceIP:       aws.ToString(event.SourceIPAddress),
                UserAgent:      extractUserAgent(event),
                SourceIdentity: sourceIdentity,
                Category:       CategoryOrphaned,
                Reason:         "Sentinel SourceIdentity but session not found (expired/deleted)",
            })
            continue
        }

        // Tracked session found
        result.TrackedEvents++
    }

    return result, nil
}

// isSentinelSourceIdentity checks if a SourceIdentity matches Sentinel format.
// Sentinel format: sentinel-XXXXXXXX (16 hex chars)
func isSentinelSourceIdentity(s string) bool {
    if !strings.HasPrefix(s, "sentinel-") {
        return false
    }
    hexPart := strings.TrimPrefix(s, "sentinel-")
    if len(hexPart) != 16 {
        return false
    }
    for _, c := range hexPart {
        if !((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {
            return false
        }
    }
    return true
}
```

### Task 4: Add GetBySourceIdentity to session store

**File:** `session/store.go` - Add to Store interface

```go
// GetBySourceIdentity retrieves a session by its source identity.
GetBySourceIdentity(ctx context.Context, sourceIdentity string) (*ServerSession, error)
```

**File:** `session/dynamodb.go` - Implement method

```go
// GetBySourceIdentity retrieves a session by its source identity.
// This requires a scan since source_identity is not indexed.
func (s *DynamoDBStore) GetBySourceIdentity(ctx context.Context, sourceIdentity string) (*ServerSession, error) {
    // Use GSI-source-identity if exists, otherwise scan
    // For now, scan with filter (acceptable for audit queries)
    input := &dynamodb.ScanInput{
        TableName:        aws.String(s.tableName),
        FilterExpression: aws.String("source_identity = :sid"),
        ExpressionAttributeValues: map[string]types.AttributeValue{
            ":sid": &types.AttributeValueMemberS{Value: sourceIdentity},
        },
        Limit: aws.Int32(1),
    }

    output, err := s.client.Scan(ctx, input)
    if err != nil {
        return nil, fmt.Errorf("failed to scan for source identity: %w", err)
    }

    if len(output.Items) == 0 {
        return nil, nil // Not found, return nil without error
    }

    return unmarshalSession(output.Items[0])
}
```

### Task 5: Add audit untracked-sessions CLI command

**File:** `cli/audit.go` - Add to existing file

```go
// AuditUntrackedSessionsCommandInput contains the input for the audit untracked-sessions command.
type AuditUntrackedSessionsCommandInput struct {
    Since      string // Duration string: "7d", "24h", etc.
    Until      string // Optional end time duration
    Region     string
    TableName  string
    RoleARN    string
    Profile    string // Filter by profile
    JSONOutput bool
    AWSProfile string

    // Detector is an optional implementation for testing.
    Detector audit.UntrackedSessionsDetector

    Stdout *os.File
    Stderr *os.File
}

// ConfigureAuditUntrackedSessionsCommand sets up the audit untracked-sessions command.
func ConfigureAuditUntrackedSessionsCommand(app *kingpin.Application, s *Sentinel) {
    input := AuditUntrackedSessionsCommandInput{}

    // Get existing audit command group or create it
    auditCmd := app.GetCommand("audit")

    cmd := auditCmd.Command("untracked-sessions", "Detect credential usage that bypassed session tracking")

    cmd.Flag("since", "How far back to search (e.g., 7d, 24h, 30m)").
        Required().
        StringVar(&input.Since)

    cmd.Flag("until", "End of search window (e.g., 1d for 1 day ago, default: now)").
        StringVar(&input.Until)

    cmd.Flag("region", "AWS region for CloudTrail and DynamoDB").
        Required().
        StringVar(&input.Region)

    cmd.Flag("table", "DynamoDB table name for sessions").
        Required().
        StringVar(&input.TableName)

    cmd.Flag("role", "Filter by role ARN").
        StringVar(&input.RoleARN)

    cmd.Flag("profile", "Filter by AWS profile").
        StringVar(&input.Profile)

    cmd.Flag("json", "Output in JSON format").
        BoolVar(&input.JSONOutput)

    cmd.Flag("aws-profile", "AWS profile for credentials").
        StringVar(&input.AWSProfile)

    cmd.Action(func(c *kingpin.ParseContext) error {
        err := AuditUntrackedSessionsCommand(context.Background(), input)
        if err != nil {
            if strings.Contains(err.Error(), "untracked session") {
                os.Exit(1)
            }
            app.FatalIfError(err, "audit untracked-sessions")
        }
        return nil
    })
}

// AuditUntrackedSessionsCommand executes the audit untracked-sessions command logic.
func AuditUntrackedSessionsCommand(ctx context.Context, input AuditUntrackedSessionsCommandInput) error {
    stdout := input.Stdout
    if stdout == nil {
        stdout = os.Stdout
    }
    stderr := input.Stderr
    if stderr == nil {
        stderr = os.Stderr
    }

    // Parse --since duration
    sinceDuration, err := ParseDuration(input.Since)
    if err != nil {
        fmt.Fprintf(stderr, "Invalid --since duration: %v\n", err)
        return err
    }

    // Calculate time window
    endTime := time.Now()
    if input.Until != "" {
        untilDuration, err := ParseDuration(input.Until)
        if err != nil {
            fmt.Fprintf(stderr, "Invalid --until duration: %v\n", err)
            return err
        }
        endTime = time.Now().Add(-untilDuration)
    }
    startTime := endTime.Add(-sinceDuration)

    // Get or create detector
    detector := input.Detector
    if detector == nil {
        // Load AWS config
        awsCfgOpts := []func(*config.LoadOptions) error{
            config.WithRegion(input.Region),
        }
        if input.AWSProfile != "" {
            awsCfgOpts = append(awsCfgOpts, config.WithSharedConfigProfile(input.AWSProfile))
        }
        awsCfg, err := config.LoadDefaultConfig(ctx, awsCfgOpts...)
        if err != nil {
            fmt.Fprintf(stderr, "Failed to load AWS config: %v\n", err)
            return err
        }

        store := session.NewDynamoDBStore(awsCfg, input.TableName)
        detector = audit.NewDetector(awsCfg, store)
    }

    // Run detection
    detectInput := &audit.UntrackedSessionsInput{
        StartTime:   startTime,
        EndTime:     endTime,
        RoleARN:     input.RoleARN,
        ProfileName: input.Profile,
    }

    result, err := detector.Detect(ctx, detectInput)
    if err != nil {
        fmt.Fprintf(stderr, "Failed to detect untracked sessions: %v\n", err)
        return err
    }

    // Output results
    if input.JSONOutput {
        jsonBytes, err := json.MarshalIndent(result, "", "  ")
        if err != nil {
            fmt.Fprintf(stderr, "Failed to format results as JSON: %v\n", err)
            return err
        }
        fmt.Fprintln(stdout, string(jsonBytes))
    } else {
        outputUntrackedHumanFormat(stdout, result)
    }

    // Return error if untracked sessions found (for scripting exit code)
    if result.UntrackedEvents > 0 {
        return fmt.Errorf("%d untracked session(s) found", result.UntrackedEvents)
    }

    return nil
}

func outputUntrackedHumanFormat(stdout *os.File, result *audit.UntrackedSessionsResult) {
    fmt.Fprintln(stdout, "Untracked Session Detection")
    fmt.Fprintln(stdout, "===========================")
    fmt.Fprintln(stdout)

    fmt.Fprintf(stdout, "Time Window: %s to %s\n",
        result.StartTime.Format(time.RFC3339),
        result.EndTime.Format(time.RFC3339))
    fmt.Fprintln(stdout)

    fmt.Fprintln(stdout, "Summary")
    fmt.Fprintln(stdout, "-------")
    fmt.Fprintf(stdout, "Total events:     %d\n", result.TotalEvents)
    fmt.Fprintf(stdout, "Tracked:          %d (%.1f%%)\n", result.TrackedEvents, result.ComplianceRate())
    fmt.Fprintf(stdout, "Untracked:        %d\n", result.UntrackedEvents)
    fmt.Fprintf(stdout, "Orphaned:         %d\n", result.OrphanedEvents)
    fmt.Fprintln(stdout)

    if len(result.UntrackedSessions) > 0 {
        fmt.Fprintf(stdout, "Untracked Sessions (%d)\n", len(result.UntrackedSessions))
        fmt.Fprintln(stdout, "----------------------")
        for _, s := range result.UntrackedSessions {
            fmt.Fprintf(stdout, "[%s] %s\n", s.Category, s.EventTime.Format(time.RFC3339))
            fmt.Fprintf(stdout, "  Event ID: %s\n", s.EventID)
            fmt.Fprintf(stdout, "  Role: %s\n", s.RoleARN)
            fmt.Fprintf(stdout, "  Source IP: %s\n", s.SourceIP)
            fmt.Fprintf(stdout, "  Reason: %s\n", s.Reason)
            fmt.Fprintln(stdout)
        }
    }

    if result.UntrackedEvents > 0 {
        fmt.Fprintf(stdout, "Result: %d untracked session(s) detected - compliance gap\n", result.UntrackedEvents)
    } else {
        fmt.Fprintln(stdout, "Result: All sessions properly tracked")
    }
}
```

### Task 6: Register command in main.go

**File:** `cmd/sentinel/main.go`

Add call to `cli.ConfigureAuditUntrackedSessionsCommand(app, s)` after existing audit command registration.

### Task 7: Add unit tests

**File:** `cli/audit_test.go`

```go
func TestAuditUntrackedSessionsCommand(t *testing.T) {
    tests := []struct {
        name           string
        input          AuditUntrackedSessionsCommandInput
        mockResult     *audit.UntrackedSessionsResult
        wantErr        bool
        wantExitCode   int
    }{
        {
            name: "all tracked - success",
            input: AuditUntrackedSessionsCommandInput{
                Since:     "7d",
                Region:    "us-east-1",
                TableName: "test-sessions",
            },
            mockResult: &audit.UntrackedSessionsResult{
                TotalEvents:   10,
                TrackedEvents: 10,
            },
            wantErr: false,
        },
        {
            name: "untracked found - returns error",
            input: AuditUntrackedSessionsCommandInput{
                Since:     "7d",
                Region:    "us-east-1",
                TableName: "test-sessions",
            },
            mockResult: &audit.UntrackedSessionsResult{
                TotalEvents:     10,
                TrackedEvents:   7,
                UntrackedEvents: 3,
            },
            wantErr: true,
        },
    }
    // ... test implementation
}
```

**File:** `cli/time_utils_test.go`

```go
func TestParseDuration(t *testing.T) {
    tests := []struct {
        input    string
        expected time.Duration
        wantErr  bool
    }{
        {"7d", 7 * 24 * time.Hour, false},
        {"24h", 24 * time.Hour, false},
        {"30m", 30 * time.Minute, false},
        {"1d12h", 36 * time.Hour, false},
        {"invalid", 0, true},
    }
    // ... test implementation
}
```

## Verification

```bash
# Build and test
go build ./...
go test ./cli/... ./audit/...

# Manual verification
sentinel audit untracked-sessions --since 1d --region us-east-1 --table sentinel-sessions
```

## Exit Criteria

1. `sentinel audit untracked-sessions` command implemented
2. Duration parsing supports days (7d), hours (24h), minutes (30m)
3. Cross-references CloudTrail with DynamoDB sessions
4. Reports untracked, orphaned, and tracked counts
5. JSON output for automation
6. Non-zero exit code when untracked sessions found
7. Unit tests pass
