---
phase: 79-server-policy-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [policy/types.go, policy/evaluate.go, policy/evaluate_test.go, sentinel/server.go, cli/sentinel_exec.go, cli/sentinel_credentials.go]
autonomous: true
---

<objective>
Add credential mode awareness to policy schema so policies can distinguish server mode from CLI mode.

Purpose: Enable policies to have conditions like `mode: server` that only match when credentials are served via server mode, preparing for Phase 82's server mode enforcement for sensitive profiles.
Output: Extended policy schema with CredentialMode type and mode condition matching.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 78 summaries for server context:
@.planning/phases/78-server-infrastructure/78-01-SUMMARY.md
@.planning/phases/78-server-infrastructure/78-02-SUMMARY.md

# Key source files:
@policy/types.go
@policy/evaluate.go
@sentinel/server.go
@cli/sentinel_exec.go
@cli/sentinel_credentials.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CredentialMode type and update policy schema</name>
  <files>policy/types.go, policy/evaluate.go</files>
  <action>
1. In policy/types.go, add CredentialMode type after Effect:

```go
// CredentialMode identifies how credentials are being requested.
// Server mode evaluates policy per-request, CLI mode evaluates once.
type CredentialMode string

const (
    // ModeServer indicates credentials served via credential server (per-request evaluation).
    ModeServer CredentialMode = "server"
    // ModeCLI indicates credentials served via exec command (one-time evaluation).
    ModeCLI CredentialMode = "cli"
    // ModeCredentialProcess indicates credentials served via credential_process (one-time evaluation).
    ModeCredentialProcess CredentialMode = "credential_process"
)

// IsValid returns true if the CredentialMode is a known value.
func (m CredentialMode) IsValid() bool {
    return m == ModeServer || m == ModeCLI || m == ModeCredentialProcess
}

// String returns the string representation of the CredentialMode.
func (m CredentialMode) String() string {
    return string(m)
}
```

2. Update Condition struct to include Mode field:

```go
type Condition struct {
    Profiles []string         `yaml:"profiles,omitempty" json:"profiles,omitempty"`
    Users    []string         `yaml:"users,omitempty" json:"users,omitempty"`
    Time     *TimeWindow      `yaml:"time,omitempty" json:"time,omitempty"`
    Mode     []CredentialMode `yaml:"mode,omitempty" json:"mode,omitempty"` // Empty = match any mode
}
```

3. In policy/evaluate.go, update Request struct:

```go
type Request struct {
    User    string
    Profile string
    Time    time.Time
    Mode    CredentialMode // Credential delivery mode (server, cli, credential_process)
}
```

4. Add matchesMode function and update matchesConditions:

```go
// matchesMode checks if the request mode matches the condition.
// An empty mode list matches any mode.
func matchesMode(modes []CredentialMode, mode CredentialMode) bool {
    if len(modes) == 0 {
        return true
    }
    for _, m := range modes {
        if m == mode {
            return true
        }
    }
    return false
}
```

Update matchesConditions to include mode check:

```go
func matchesConditions(c *Condition, req *Request) bool {
    if !matchesProfiles(c.Profiles, req.Profile) {
        return false
    }
    if !matchesUsers(c.Users, req.User) {
        return false
    }
    if !matchesTimeWindow(c.Time, req.Time) {
        return false
    }
    if !matchesMode(c.Mode, req.Mode) {
        return false
    }
    return true
}
```
  </action>
  <verify>gofmt -l policy/types.go policy/evaluate.go returns no output (properly formatted)</verify>
  <done>CredentialMode type exists with server/cli/credential_process constants, Condition has Mode field, matchesMode implemented</done>
</task>

<task type="auto">
  <name>Task 2: Update callers to pass credential mode</name>
  <files>sentinel/server.go, cli/sentinel_exec.go, cli/sentinel_credentials.go</files>
  <action>
1. In sentinel/server.go DefaultRoute, add Mode to policy request:

```go
policyRequest := &policy.Request{
    User:    s.config.User,
    Profile: s.config.ProfileName,
    Time:    time.Now(),
    Mode:    policy.ModeServer, // Server mode - per-request evaluation
}
```

2. In cli/sentinel_exec.go SentinelExecCommand, add Mode based on --server flag:

For the CLI mode (non-server) section around line 229:
```go
policyRequest := &policy.Request{
    User:    username,
    Profile: input.ProfileName,
    Time:    time.Now(),
    Mode:    policy.ModeCLI, // CLI mode - one-time evaluation
}
```

Note: Server mode already creates its own policy request in sentinel/server.go, so CLI path always uses ModeCLI.

3. In cli/sentinel_credentials.go, add Mode to policy request:

Find the policy.Request creation and add:
```go
policyRequest := &policy.Request{
    User:    username,
    Profile: input.ProfileName,
    Time:    time.Now(),
    Mode:    policy.ModeCredentialProcess, // credential_process mode
}
```
  </action>
  <verify>grep -n "Mode:" sentinel/server.go cli/sentinel_exec.go cli/sentinel_credentials.go shows Mode field being set in all policy.Request creations</verify>
  <done>All policy.Request creations include Mode field with appropriate value</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for mode-aware policy evaluation</name>
  <files>policy/evaluate_test.go</files>
  <action>
Add tests for mode matching in policy evaluation. Find the existing test file and add:

1. TestMatchesMode function:
```go
func TestMatchesMode(t *testing.T) {
    tests := []struct {
        name     string
        modes    []CredentialMode
        mode     CredentialMode
        expected bool
    }{
        {"empty list matches any mode", nil, ModeServer, true},
        {"empty list matches cli", nil, ModeCLI, true},
        {"server matches server", []CredentialMode{ModeServer}, ModeServer, true},
        {"server does not match cli", []CredentialMode{ModeServer}, ModeCLI, false},
        {"multiple modes - server matches", []CredentialMode{ModeServer, ModeCLI}, ModeServer, true},
        {"multiple modes - cli matches", []CredentialMode{ModeServer, ModeCLI}, ModeCLI, true},
        {"multiple modes - credential_process no match", []CredentialMode{ModeServer, ModeCLI}, ModeCredentialProcess, false},
        {"credential_process matches", []CredentialMode{ModeCredentialProcess}, ModeCredentialProcess, true},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := matchesMode(tt.modes, tt.mode)
            if result != tt.expected {
                t.Errorf("matchesMode(%v, %v) = %v, want %v", tt.modes, tt.mode, result, tt.expected)
            }
        })
    }
}
```

2. TestEvaluate_ModeCondition - integration test for full policy evaluation with mode:
```go
func TestEvaluate_ModeCondition(t *testing.T) {
    tests := []struct {
        name       string
        policy     *Policy
        request    *Request
        wantEffect Effect
        wantRule   string
    }{
        {
            name: "server-only rule matches server mode",
            policy: &Policy{
                Version: "1",
                Rules: []Rule{
                    {Name: "server-only", Effect: EffectAllow, Conditions: Condition{Mode: []CredentialMode{ModeServer}}},
                },
            },
            request:    &Request{User: "alice", Profile: "prod", Time: time.Now(), Mode: ModeServer},
            wantEffect: EffectAllow,
            wantRule:   "server-only",
        },
        {
            name: "server-only rule denies cli mode",
            policy: &Policy{
                Version: "1",
                Rules: []Rule{
                    {Name: "server-only", Effect: EffectAllow, Conditions: Condition{Mode: []CredentialMode{ModeServer}}},
                },
            },
            request:    &Request{User: "alice", Profile: "prod", Time: time.Now(), Mode: ModeCLI},
            wantEffect: EffectDeny,
            wantRule:   "", // default deny
        },
        {
            name: "no mode condition matches any mode",
            policy: &Policy{
                Version: "1",
                Rules: []Rule{
                    {Name: "any-mode", Effect: EffectAllow, Conditions: Condition{Users: []string{"alice"}}},
                },
            },
            request:    &Request{User: "alice", Profile: "prod", Time: time.Now(), Mode: ModeCredentialProcess},
            wantEffect: EffectAllow,
            wantRule:   "any-mode",
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            decision := Evaluate(tt.policy, tt.request)
            if decision.Effect != tt.wantEffect {
                t.Errorf("Effect = %v, want %v", decision.Effect, tt.wantEffect)
            }
            if decision.MatchedRule != tt.wantRule {
                t.Errorf("MatchedRule = %v, want %v", decision.MatchedRule, tt.wantRule)
            }
        })
    }
}
```

3. TestCredentialMode_IsValid:
```go
func TestCredentialMode_IsValid(t *testing.T) {
    tests := []struct {
        mode  CredentialMode
        valid bool
    }{
        {ModeServer, true},
        {ModeCLI, true},
        {ModeCredentialProcess, true},
        {"", false},
        {"invalid", false},
    }

    for _, tt := range tests {
        t.Run(string(tt.mode), func(t *testing.T) {
            if got := tt.mode.IsValid(); got != tt.valid {
                t.Errorf("CredentialMode(%q).IsValid() = %v, want %v", tt.mode, got, tt.valid)
            }
        })
    }
}
```
  </action>
  <verify>go test ./policy/... -run Mode -v passes all mode-related tests</verify>
  <done>Tests cover mode matching, mode condition in policy evaluation, and CredentialMode.IsValid()</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] gofmt -l ./policy/ ./sentinel/ ./cli/ returns no files (all properly formatted)
- [ ] go build ./... succeeds
- [ ] go test ./policy/... -run Mode passes
- [ ] go test ./policy/... passes all existing tests (no regressions)
- [ ] grep confirms Mode field set in all policy.Request creations
</verification>

<success_criteria>

- CredentialMode type with server/cli/credential_process constants
- Mode field in policy.Condition for rule matching
- Mode field in policy.Request for evaluation context
- matchesMode function with wildcard (empty = any) semantics
- All callers pass appropriate mode value
- Tests cover mode matching and policy evaluation with mode conditions
</success_criteria>

<output>
After completion, create `.planning/phases/79-server-policy-integration/79-01-SUMMARY.md`
</output>
