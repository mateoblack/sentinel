---
phase: 79-server-policy-integration
plan: 02
type: execute
wave: 1
depends_on: ["79-01"]
files_modified: [sentinel/server_test.go, docs/guide/policy-reference.md, docs/guide/commands.md, docs/guide/concepts.md]
autonomous: true
---

<objective>
Add server mode policy integration tests and documentation for mode-aware policies.

Purpose: Complete Phase 79 by validating server mode passes ModeServer in policy evaluation and documenting mode conditions for users.
Output: Server mode tests verifying Mode field usage; documentation of mode condition and --server flag.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan context:
@.planning/phases/79-server-policy-integration/79-01-SUMMARY.md
@.planning/phases/78-server-infrastructure/78-01-SUMMARY.md
@.planning/phases/78-server-infrastructure/78-02-SUMMARY.md

# Key source files:
@sentinel/server.go
@sentinel/server_test.go
@policy/types.go
@policy/evaluate.go
@docs/guide/policy-reference.md
@docs/guide/commands.md
@docs/guide/concepts.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add server mode policy integration tests</name>
  <files>sentinel/server_test.go</files>
  <action>
Add tests to sentinel/server_test.go verifying Mode-aware policy integration:

1. Create a mode-conditional policy helper:

```go
// createModeConditionalPolicy creates a policy that only allows a specific mode.
func createModeConditionalPolicy(effect policy.Effect, allowedMode policy.CredentialMode) *policy.Policy {
	return &policy.Policy{
		Rules: []policy.Rule{
			{
				Name:       "mode-conditional",
				Effect:     effect,
				Conditions: policy.Condition{Mode: []policy.CredentialMode{allowedMode}},
			},
		},
	}
}
```

2. Add test for server mode policy allow:

```go
func TestSentinelServer_ModeCondition_ServerAllowed(t *testing.T) {
	// Policy allows only server mode
	mockLoader := testutil.NewMockPolicyLoader()
	mockLoader.Policies["/sentinel/policies/test"] = createModeConditionalPolicy(policy.EffectAllow, policy.ModeServer)

	mockProvider := &MockCredentialProvider{}

	config := SentinelServerConfig{
		ProfileName:        "test-profile",
		PolicyParameter:    "/sentinel/policies/test",
		User:               "testuser",
		PolicyLoader:       mockLoader,
		CredentialProvider: mockProvider,
		LazyLoad:           true,
	}

	server, err := NewSentinelServer(context.Background(), config, "test-auth-token", 0)
	if err != nil {
		t.Fatalf("Failed to create server: %v", err)
	}
	defer server.Shutdown(context.Background())

	// Create request
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	req.Header.Set("Authorization", "test-auth-token")

	rec := httptest.NewRecorder()
	server.DefaultRoute(rec, req)

	// Server should be allowed (policy allows server mode)
	if rec.Code != http.StatusOK {
		t.Errorf("Expected status %d (server mode allowed), got %d", http.StatusOK, rec.Code)
	}
}
```

3. Add test verifying server requests pass ModeServer:

```go
func TestSentinelServer_PassesModeServer(t *testing.T) {
	// Use a mock policy loader that captures the request
	mockLogger := testutil.NewMockLogger()

	server, authToken := createTestServer(t, policy.EffectAllow, func(c *SentinelServerConfig) {
		c.Logger = mockLogger
	})
	defer server.Shutdown(context.Background())

	req := httptest.NewRequest(http.MethodGet, "/", nil)
	req.Header.Set("Authorization", authToken)

	rec := httptest.NewRecorder()
	server.DefaultRoute(rec, req)

	// The logged decision should show the request was for server mode
	// We can verify this indirectly through the decision log which includes request details
	if mockLogger.DecisionCount() != 1 {
		t.Fatalf("Expected 1 decision log, got %d", mockLogger.DecisionCount())
	}

	// Verify credentials were issued (mode allowed)
	if rec.Code != http.StatusOK {
		t.Errorf("Expected status %d, got %d", http.StatusOK, rec.Code)
	}
}
```

4. Add test for CLI-only policy denying server mode:

```go
func TestSentinelServer_ModeCondition_CLIOnlyDeniesServer(t *testing.T) {
	// Policy allows only CLI mode - should deny server requests
	mockLoader := testutil.NewMockPolicyLoader()
	mockLoader.Policies["/sentinel/policies/test"] = createModeConditionalPolicy(policy.EffectAllow, policy.ModeCLI)

	mockProvider := &MockCredentialProvider{}

	config := SentinelServerConfig{
		ProfileName:        "test-profile",
		PolicyParameter:    "/sentinel/policies/test",
		User:               "testuser",
		PolicyLoader:       mockLoader,
		CredentialProvider: mockProvider,
		LazyLoad:           true,
	}

	server, err := NewSentinelServer(context.Background(), config, "test-auth-token", 0)
	if err != nil {
		t.Fatalf("Failed to create server: %v", err)
	}
	defer server.Shutdown(context.Background())

	req := httptest.NewRequest(http.MethodGet, "/", nil)
	req.Header.Set("Authorization", "test-auth-token")

	rec := httptest.NewRecorder()
	server.DefaultRoute(rec, req)

	// Server should be denied (policy only allows CLI mode)
	if rec.Code != http.StatusForbidden {
		t.Errorf("Expected status %d (CLI-only policy denies server), got %d", http.StatusForbidden, rec.Code)
	}
}
```

5. Add test for credential_process-only policy denying server mode:

```go
func TestSentinelServer_ModeCondition_CredentialProcessOnlyDeniesServer(t *testing.T) {
	// Policy allows only credential_process mode - should deny server requests
	mockLoader := testutil.NewMockPolicyLoader()
	mockLoader.Policies["/sentinel/policies/test"] = createModeConditionalPolicy(policy.EffectAllow, policy.ModeCredentialProcess)

	mockProvider := &MockCredentialProvider{}

	config := SentinelServerConfig{
		ProfileName:        "test-profile",
		PolicyParameter:    "/sentinel/policies/test",
		User:               "testuser",
		PolicyLoader:       mockLoader,
		CredentialProvider: mockProvider,
		LazyLoad:           true,
	}

	server, err := NewSentinelServer(context.Background(), config, "test-auth-token", 0)
	if err != nil {
		t.Fatalf("Failed to create server: %v", err)
	}
	defer server.Shutdown(context.Background())

	req := httptest.NewRequest(http.MethodGet, "/", nil)
	req.Header.Set("Authorization", "test-auth-token")

	rec := httptest.NewRecorder()
	server.DefaultRoute(rec, req)

	// Server should be denied (policy only allows credential_process mode)
	if rec.Code != http.StatusForbidden {
		t.Errorf("Expected status %d (credential_process-only denies server), got %d", http.StatusForbidden, rec.Code)
	}
}
```

6. Add test for empty mode (wildcard) allowing server:

```go
func TestSentinelServer_ModeCondition_EmptyModeAllowsServer(t *testing.T) {
	// Policy with no mode condition (empty) should allow any mode including server
	mockLoader := testutil.NewMockPolicyLoader()
	mockLoader.Policies["/sentinel/policies/test"] = &policy.Policy{
		Rules: []policy.Rule{
			{
				Name:   "any-mode",
				Effect: policy.EffectAllow,
				// No Mode condition - wildcard
			},
		},
	}

	mockProvider := &MockCredentialProvider{}

	config := SentinelServerConfig{
		ProfileName:        "test-profile",
		PolicyParameter:    "/sentinel/policies/test",
		User:               "testuser",
		PolicyLoader:       mockLoader,
		CredentialProvider: mockProvider,
		LazyLoad:           true,
	}

	server, err := NewSentinelServer(context.Background(), config, "test-auth-token", 0)
	if err != nil {
		t.Fatalf("Failed to create server: %v", err)
	}
	defer server.Shutdown(context.Background())

	req := httptest.NewRequest(http.MethodGet, "/", nil)
	req.Header.Set("Authorization", "test-auth-token")

	rec := httptest.NewRecorder()
	server.DefaultRoute(rec, req)

	// Server should be allowed (empty mode = wildcard)
	if rec.Code != http.StatusOK {
		t.Errorf("Expected status %d (empty mode = wildcard allows server), got %d", http.StatusOK, rec.Code)
	}
}
```
  </action>
  <verify>gofmt -l sentinel/server_test.go returns no output (properly formatted)</verify>
  <done>Tests verify server passes ModeServer, mode-conditional policies work, CLI-only/credential_process-only policies deny server, empty mode allows server</done>
</task>

<task type="auto">
  <name>Task 2: Document mode condition in policy reference</name>
  <files>docs/guide/policy-reference.md</files>
  <action>
Add mode condition documentation to docs/guide/policy-reference.md. Find the "Conditions" section (after users, profiles, time) and add a new "mode" subsection:

Add after the time condition section:

```markdown
### mode

The `mode` condition restricts when a rule applies based on how credentials are being requested. This enables different policies for server mode (per-request evaluation) versus CLI mode (one-time evaluation).

**Valid modes:**
- `server` - Credentials served via credential server (`sentinel exec --server`)
- `cli` - Credentials served via exec command (`sentinel exec` without `--server`)
- `credential_process` - Credentials served via credential_process (`sentinel credentials`)

**Omit for wildcard:** If `mode` is not specified, the rule matches any mode (equivalent to specifying all three modes).

**Examples:**

```yaml
# Only allow server mode (for real-time revocation control)
rules:
  - name: prod-server-only
    effect: allow
    conditions:
      profiles: [production]
      mode: [server]

# Allow both CLI and credential_process (one-time evaluation modes)
rules:
  - name: dev-one-time
    effect: allow
    conditions:
      profiles: [development]
      mode: [cli, credential_process]

# Allow any mode (omit mode condition)
rules:
  - name: staging-any-mode
    effect: allow
    conditions:
      profiles: [staging]
      # No mode condition = matches any mode
```

**Security considerations:**

Server mode enables real-time policy enforcement because each credential request is evaluated against the current policy. This provides:

1. **Instant revocation**: Change policy and new credential requests are immediately affected
2. **Per-request audit**: Every credential fetch is logged with policy decision
3. **Short-lived credentials**: Server can enforce shorter credential TTLs

For sensitive profiles requiring instant revocation capability, use `mode: [server]` to ensure credentials are only issued through the credential server.
```

Ensure the new section fits naturally with existing conditions documentation and maintains consistent formatting.
  </action>
  <verify>grep -A 5 "### mode" docs/guide/policy-reference.md shows the new section</verify>
  <done>policy-reference.md includes mode condition documentation with examples and security considerations</done>
</task>

<task type="auto">
  <name>Task 3: Document --server flag in commands reference</name>
  <files>docs/guide/commands.md</files>
  <action>
Add server mode documentation to docs/guide/commands.md. Find the `sentinel exec` command section and add the server mode flags and usage.

Find the exec command section and add after the existing flags:

```markdown
#### Server Mode

Server mode starts a local credential server that evaluates policy on every credential request. This enables real-time revocation - changing policy immediately affects subsequent credential requests.

**Flags:**
- `--server, -s` - Enable server mode (starts credential server instead of env vars)
- `--server-port PORT` - Port for credential server (default: auto-assigned)
- `--lazy` - Skip credential prefetch on server startup

**How it works:**

1. Server listens on localhost with a random auth token
2. Sets `AWS_CONTAINER_CREDENTIALS_FULL_URI` for the subprocess
3. Each credential request from the subprocess triggers policy evaluation
4. Credentials are served or denied based on current policy

**Example:**

```bash
# Start terraform with server mode credentials
sentinel exec --server --profile production -- terraform plan

# Server mode with explicit port
sentinel exec --server --server-port 9999 --profile staging -- aws s3 ls
```

**Server mode vs standard exec:**

| Aspect | Standard exec | Server mode |
|--------|--------------|-------------|
| Policy evaluation | Once at startup | Every credential request |
| Revocation timing | Next exec invocation | Immediate (next request) |
| Credential delivery | Environment variables | HTTP credential server |
| Credential lifetime | Full session duration | Can be shorter TTL |
| Use case | Short-lived commands | Long-running processes |

**When to use server mode:**

- Long-running processes that need revocation capability
- Profiles requiring real-time access control
- Compliance scenarios requiring per-request audit
- Terraform/CDK operations on sensitive infrastructure

**Incompatible flags:**
- `--server` cannot be combined with `--no-session` (server requires session credentials)
```
  </action>
  <verify>grep -A 3 "Server Mode" docs/guide/commands.md shows the new section</verify>
  <done>commands.md includes --server flag documentation with usage examples and comparison table</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] gofmt -l ./sentinel/ returns no files (all properly formatted)
- [ ] All new tests in sentinel/server_test.go compile and pass syntax check
- [ ] docs/guide/policy-reference.md includes mode condition section
- [ ] docs/guide/commands.md includes --server flag documentation
- [ ] Documentation examples are syntactically valid YAML
</verification>

<success_criteria>

- Server mode tests verify Mode field passed correctly
- Tests cover mode-conditional policies (allow/deny based on mode)
- Tests cover wildcard (empty mode) behavior
- policy-reference.md documents mode condition with examples
- commands.md documents --server flag with usage and comparison
</success_criteria>

<output>
After completion, create `.planning/phases/79-server-policy-integration/79-02-SUMMARY.md`
</output>
