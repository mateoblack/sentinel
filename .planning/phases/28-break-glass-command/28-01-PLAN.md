---
phase: 28-break-glass-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [breakglass/store.go, breakglass/dynamodb.go, breakglass/dynamodb_test.go]
autonomous: true
---

<objective>
Create break-glass storage layer with Store interface and DynamoDB implementation.

Purpose: Provide persistence for break-glass events matching the request package pattern.
Output: Store interface, DynamoDB implementation, and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-break-glass-schema/27-01-SUMMARY.md

# Existing patterns to follow:
@request/store.go
@request/dynamodb.go

# Break-glass types from Phase 27:
@breakglass/types.go
@breakglass/validate.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Store interface for break-glass events</name>
  <files>breakglass/store.go</files>
  <action>
Create Store interface following request/store.go pattern:

1. Define sentinel errors matching request package:
   - ErrEventNotFound (like ErrRequestNotFound)
   - ErrEventExists (like ErrRequestExists)
   - ErrConcurrentModification (reuse error message)

2. Define query constants:
   - DefaultQueryLimit = 100
   - MaxQueryLimit = 1000

3. Define Store interface with methods:
   - Create(ctx, *BreakGlassEvent) error
   - Get(ctx, id string) (*BreakGlassEvent, error)
   - Update(ctx, *BreakGlassEvent) error
   - Delete(ctx, id string) error
   - ListByInvoker(ctx, invoker string, limit int) ([]*BreakGlassEvent, error)
   - ListByStatus(ctx, status BreakGlassStatus, limit int) ([]*BreakGlassEvent, error)
   - ListByProfile(ctx, profile string, limit int) ([]*BreakGlassEvent, error)
   - FindActiveByInvokerAndProfile(ctx, invoker, profile string) (*BreakGlassEvent, error)

The FindActiveByInvokerAndProfile method is critical - it checks if the user already has active break-glass access for a profile (to prevent stacking).

Add doc comments following existing patterns. Methods must be safe for concurrent use.
  </action>
  <verify>go build ./breakglass/... succeeds</verify>
  <done>Store interface defined with all CRUD and query methods, sentinel errors, and query constants</done>
</task>

<task type="auto">
  <name>Task 2: Implement DynamoDB store for break-glass events</name>
  <files>breakglass/dynamodb.go, breakglass/dynamodb_test.go</files>
  <action>
Create DynamoDBStore implementation following request/dynamodb.go pattern:

1. Define DynamoDBStore struct:
   - client dynamodb.Client (interface for testing)
   - tableName string

2. Create NewDynamoDBStore(cfg aws.Config, tableName string) *DynamoDBStore constructor

3. Implement all Store interface methods:

   Create: Use PutItem with ConditionExpression to prevent overwrites
   - attribute_not_exists(pk)
   - Return ErrEventExists on ConditionalCheckFailedException

   Get: Use GetItem with pk = "BREAKGLASS#" + id
   - Return ErrEventNotFound if item not found

   Update: Use PutItem with optimistic locking via UpdatedAt
   - ConditionExpression: updated_at = :expected_updated_at
   - Return ErrConcurrentModification on ConditionalCheckFailedException

   Delete: Use DeleteItem (idempotent, no error if not exists)

   ListByInvoker: Query GSI "invoker-index" with invoker = :invoker
   - Sort by created_at desc (ScanIndexForward: false)
   - Apply limit (default 100, max 1000)

   ListByStatus: Query GSI "status-index" with status = :status
   - Sort by created_at desc
   - Apply limit

   ListByProfile: Query GSI "profile-index" with profile = :profile
   - Sort by created_at desc
   - Apply limit

   FindActiveByInvokerAndProfile: Query with invoker and profile filters, status = "active"
   - Return nil, nil if no active event found
   - Return single event if found

4. DynamoDB table design (for documentation, not created here):
   - PK: "BREAKGLASS#" + id
   - GSI: invoker-index (invoker, created_at)
   - GSI: status-index (status, created_at)
   - GSI: profile-index (profile, created_at)
   - TTL: expires_at

5. Write comprehensive tests using mock DynamoDB client:
   - Test Create success and duplicate rejection
   - Test Get success and not found
   - Test Update success and concurrent modification
   - Test Delete idempotency
   - Test all List methods with various filters
   - Test FindActiveByInvokerAndProfile with active/no-active cases

Use table-driven tests. Follow request/dynamodb_test.go patterns.
  </action>
  <verify>go test ./breakglass/... -v passes all tests</verify>
  <done>DynamoDB store implementation complete with all CRUD and query methods, tests passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./breakglass/... succeeds
- [ ] go test ./breakglass/... -v passes all tests
- [ ] Store interface matches request/store.go pattern
- [ ] DynamoDB implementation handles all error cases
</verification>

<success_criteria>
- All tasks completed
- Store interface defined with CRUD + query methods
- DynamoDB implementation with optimistic locking
- Tests cover all operations and error cases
- No build or test failures
</success_criteria>

<output>
After completion, create `.planning/phases/28-break-glass-command/28-01-SUMMARY.md`
</output>
