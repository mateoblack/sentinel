---
phase: 28-break-glass-command
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified: [cli/breakglass.go, cli/breakglass_test.go]
autonomous: true
---

<objective>
Create CLI command to invoke break-glass emergency access with mandatory justification.

Purpose: Provide emergency access mechanism with full audit trail following CLI patterns.
Output: Working `sentinel breakglass` command with tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-break-glass-command/28-01-SUMMARY.md

# CLI patterns to follow:
@cli/request.go
@cli/approve.go

# Break-glass types and store:
@breakglass/types.go
@breakglass/validate.go
@breakglass/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create breakglass CLI command</name>
  <files>cli/breakglass.go</files>
  <action>
Create breakglass command following cli/request.go pattern:

1. Define BreakGlassCommandInput struct:
   - ProfileName string
   - Duration time.Duration
   - ReasonCode string (maps to breakglass.ReasonCode)
   - Justification string
   - BreakGlassTable string (DynamoDB table name)
   - Region string
   - Store breakglass.Store (optional, for testing)
   - Notifier notification.Notifier (optional, for notifications)
   - Logger logging.Logger (optional, for audit trail)

2. Define BreakGlassCommandOutput struct (JSON output):
   - EventID string `json:"event_id"`
   - Profile string `json:"profile"`
   - ReasonCode string `json:"reason_code"`
   - Status string `json:"status"`
   - ExpiresAt time.Time `json:"expires_at"`
   - RequestID string `json:"request_id,omitempty"` (for CloudTrail correlation)

3. Implement ConfigureBreakGlassCommand(app *kingpin.Application, s *Sentinel):
   - Register "breakglass" command with help: "Invoke emergency break-glass access"
   - Required flags: --profile, --reason-code, --justification, --breakglass-table
   - Optional flags: --duration (default 1h), --region
   - reason-code accepts: incident, maintenance, security, recovery, other

4. Implement BreakGlassCommand(ctx context.Context, input BreakGlassCommandInput, s *Sentinel) error:

   a. Get current user (invoker)
   b. Validate profile exists via s.ValidateProfile()
   c. Parse and validate reason code (must be valid ReasonCode)
   d. Cap duration at breakglass.MaxDuration (4h)
   e. Get or create DynamoDB store (like request command)
   f. Check for existing active break-glass for same user+profile using FindActiveByInvokerAndProfile
      - If found, error: "active break-glass already exists for this profile"
      - This prevents stacking multiple break-glass sessions
   g. Build BreakGlassEvent struct:
      - ID: breakglass.NewBreakGlassID()
      - Invoker: username
      - Profile: input.ProfileName
      - ReasonCode: parsed reason code
      - Justification: input.Justification
      - Duration: capped duration
      - Status: breakglass.StatusActive (starts active immediately)
      - CreatedAt: now
      - UpdatedAt: now
      - ExpiresAt: now.Add(duration)
      - RequestID: generate new request ID for CloudTrail correlation
   h. Validate event via event.Validate()
   i. Store event via store.Create()
   j. Log break-glass invocation if Logger provided (new event type for Phase 29)
   k. Output success JSON to stdout

Error handling:
- Validation errors → stderr + return error
- Store errors → stderr + return error
- Profile not found → stderr + return error
- Active break-glass exists → stderr + return error
  </action>
  <verify>go build ./cli/... succeeds</verify>
  <done>BreakGlass command implemented with all validation, storage, and JSON output</done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive tests for breakglass command</name>
  <files>cli/breakglass_test.go</files>
  <action>
Create comprehensive tests following cli/request_test.go and cli/approve_test.go patterns:

1. Create mock store implementing breakglass.Store for testing
2. Create mock Sentinel with ValidateProfile for profile validation testing

3. Test cases (table-driven):

   Success cases:
   - Valid break-glass with all fields → success JSON output
   - Valid break-glass with minimum duration → capped at max
   - Valid break-glass with each reason code (incident, maintenance, security, recovery, other)

   Validation failures:
   - Invalid profile (not in config) → error
   - Empty justification → error (Validate catches this)
   - Justification too short (<20 chars) → error
   - Justification too long (>1000 chars) → error
   - Invalid reason code → error
   - Duration exceeds max → warning + capped (not error)

   State validation:
   - Active break-glass exists for same user+profile → error
   - No active break-glass exists → success

   Store errors:
   - Store.Create returns error → error propagated
   - Store.FindActiveByInvokerAndProfile returns error → error propagated

4. Verify JSON output structure:
   - Contains event_id (16 hex chars)
   - Contains profile
   - Contains reason_code
   - Contains status = "active"
   - Contains expires_at
   - Contains request_id for CloudTrail correlation

5. Use testify for assertions where helpful
  </action>
  <verify>go test ./cli/... -v -run TestBreakGlass passes all tests</verify>
  <done>All test cases passing, covering success paths, validation errors, and store errors</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./... succeeds
- [ ] go test ./cli/... -v passes all tests
- [ ] go test ./breakglass/... -v passes all tests
- [ ] Command follows existing CLI patterns (request, approve)
- [ ] JSON output matches expected structure
</verification>

<success_criteria>
- All tasks completed
- breakglass command registered and functional
- All reason codes supported
- Active break-glass stacking prevented
- Tests cover all success and error paths
- No build or test failures
</success_criteria>

<output>
After completion, create `.planning/phases/28-break-glass-command/28-02-SUMMARY.md`
</output>
