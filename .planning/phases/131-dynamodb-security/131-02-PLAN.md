---
phase: 131-dynamodb-security
plan: 02
type: execute
wave: 2
depends_on: ["131-01"]
files_modified: [request/dynamodb_security_test.go, breakglass/dynamodb_security_test.go, session/dynamodb_security_test.go]
autonomous: true
---

<objective>
Create security regression tests for DynamoDB stores to verify conditional writes prevent manipulation attacks.

Purpose: Establish security regression tests that explicitly demonstrate and prevent state manipulation attacks on DynamoDB stores. These tests ensure the fixes from Plan 01 remain effective and prevent future regressions.
Output: Security test files following TestSecurityRegression_ naming convention for CI filtering.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/131-dynamodb-security/131-01-SUMMARY.md

@request/dynamodb.go
@request/dynamodb_test.go
@breakglass/dynamodb.go
@breakglass/dynamodb_test.go
@session/dynamodb.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create request store security regression tests</name>
  <files>request/dynamodb_security_test.go</files>
  <action>
Create security regression tests for request store DynamoDB operations.

Create `request/dynamodb_security_test.go` with tests following TestSecurityRegression_ prefix:

```go
package request

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// TestSecurityRegression_CreateDuplicatePrevented verifies that conditional writes
// prevent duplicate request creation attacks.
func TestSecurityRegression_CreateDuplicatePrevented(t *testing.T) {
	// Mock returns ConditionalCheckFailedException to simulate existing item
	mock := &mockDynamoDBClient{
		putItemFunc: func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
			// Verify condition expression is present
			if params.ConditionExpression == nil || *params.ConditionExpression != "attribute_not_exists(id)" {
				t.Error("SECURITY VIOLATION: Create() missing uniqueness condition")
			}
			return nil, &types.ConditionalCheckFailedException{Message: aws.String("exists")}
		},
	}

	store := newDynamoDBStoreWithClient(mock, "test-table")
	req := testRequest()

	err := store.Create(context.Background(), req)
	if !errors.Is(err, ErrRequestExists) {
		t.Errorf("SECURITY VIOLATION: Create duplicate should return ErrRequestExists, got: %v", err)
	}
}

// TestSecurityRegression_ConcurrentModificationDetected verifies optimistic locking
// prevents concurrent modification attacks.
func TestSecurityRegression_ConcurrentModificationDetected(t *testing.T) {
	getCallCount := 0
	mock := &mockDynamoDBClient{
		putItemFunc: func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
			// Verify condition expression includes updated_at check
			if params.ConditionExpression == nil || !strings.Contains(*params.ConditionExpression, "updated_at") {
				t.Error("SECURITY VIOLATION: Update() missing optimistic locking condition")
			}
			return nil, &types.ConditionalCheckFailedException{Message: aws.String("modified")}
		},
		getItemFunc: func(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {
			getCallCount++
			// Return item exists (so it's concurrent modification, not not-found)
			return &dynamodb.GetItemOutput{
				Item: map[string]types.AttributeValue{
					"id": &types.AttributeValueMemberS{Value: "test-id"},
				},
			}, nil
		},
	}

	store := newDynamoDBStoreWithClient(mock, "test-table")
	req := testRequest()
	req.Status = StatusApproved

	err := store.Update(context.Background(), req)
	if !errors.Is(err, ErrConcurrentModification) {
		t.Errorf("SECURITY VIOLATION: Concurrent modification should be detected, got: %v", err)
	}
}

// TestSecurityRegression_InvalidStateTransitionPrevented verifies that invalid
// state transitions are rejected (e.g., approved â†’ pending).
func TestSecurityRegression_InvalidStateTransitionPrevented(t *testing.T) {
	testCases := []struct {
		name       string
		fromStatus RequestStatus
		toStatus   RequestStatus
		shouldFail bool
	}{
		// Valid transitions
		{"pending_to_approved", StatusPending, StatusApproved, false},
		{"pending_to_denied", StatusPending, StatusDenied, false},
		{"pending_to_expired", StatusPending, StatusExpired, false},
		{"pending_to_cancelled", StatusPending, StatusCancelled, false},
		// Invalid transitions (attack scenarios)
		{"approved_to_pending", StatusApproved, StatusPending, true},
		{"denied_to_approved", StatusDenied, StatusApproved, true},
		{"expired_to_approved", StatusExpired, StatusApproved, true},
		{"cancelled_to_pending", StatusCancelled, StatusPending, true},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			now := time.Now().UTC()
			currentItem := &dynamoItem{
				ID:        "test-id",
				Requester: "alice",
				Profile:   "prod",
				Status:    string(tc.fromStatus),
				CreatedAt: now.Format(time.RFC3339Nano),
				UpdatedAt: now.Format(time.RFC3339Nano),
				ExpiresAt: now.Add(time.Hour).Format(time.RFC3339Nano),
			}

			mock := &mockDynamoDBClient{
				getItemFunc: func(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {
					av, _ := attributevalue.MarshalMap(currentItem)
					return &dynamodb.GetItemOutput{Item: av}, nil
				},
				putItemFunc: func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
					return &dynamodb.PutItemOutput{}, nil
				},
			}

			store := newDynamoDBStoreWithClient(mock, "test-table")
			req := &Request{
				ID:        "test-id",
				Status:    tc.toStatus,
				UpdatedAt: now,
			}

			err := store.Update(context.Background(), req)

			if tc.shouldFail {
				if !errors.Is(err, ErrInvalidStateTransition) {
					t.Errorf("SECURITY VIOLATION: %s should be prevented, got: %v", tc.name, err)
				}
			} else {
				if errors.Is(err, ErrInvalidStateTransition) {
					t.Errorf("Valid transition %s incorrectly rejected: %v", tc.name, err)
				}
			}
		})
	}
}
```

Add necessary imports: `"strings"`, `"github.com/aws/aws-sdk-go-v2/aws"`, `"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"`.
  </action>
  <verify>go test ./request/... -v -run TestSecurityRegression</verify>
  <done>request/dynamodb_security_test.go created with 3+ security regression tests</done>
</task>

<task type="auto">
  <name>Task 2: Create breakglass store security regression tests</name>
  <files>breakglass/dynamodb_security_test.go</files>
  <action>
Create security regression tests for breakglass store DynamoDB operations.

Create `breakglass/dynamodb_security_test.go` with tests:

```go
package breakglass

import (
	"context"
	"errors"
	"strings"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// TestSecurityRegression_CreateDuplicatePrevented verifies conditional writes
// prevent duplicate break-glass event creation.
func TestSecurityRegression_CreateDuplicatePrevented(t *testing.T) {
	mock := &mockDynamoDBClient{
		putItemFunc: func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
			if params.ConditionExpression == nil || *params.ConditionExpression != "attribute_not_exists(id)" {
				t.Error("SECURITY VIOLATION: Create() missing uniqueness condition")
			}
			return nil, &types.ConditionalCheckFailedException{Message: aws.String("exists")}
		},
	}

	store := newDynamoDBStoreWithClient(mock, "test-table")
	event := testEvent()

	err := store.Create(context.Background(), event)
	if !errors.Is(err, ErrEventExists) {
		t.Errorf("SECURITY VIOLATION: Create duplicate should return ErrEventExists, got: %v", err)
	}
}

// TestSecurityRegression_ConcurrentModificationDetected verifies optimistic locking.
func TestSecurityRegression_ConcurrentModificationDetected(t *testing.T) {
	mock := &mockDynamoDBClient{
		putItemFunc: func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
			if params.ConditionExpression == nil || !strings.Contains(*params.ConditionExpression, "updated_at") {
				t.Error("SECURITY VIOLATION: Update() missing optimistic locking condition")
			}
			return nil, &types.ConditionalCheckFailedException{Message: aws.String("modified")}
		},
		getItemFunc: func(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {
			return &dynamodb.GetItemOutput{
				Item: map[string]types.AttributeValue{
					"id": &types.AttributeValueMemberS{Value: "test-id"},
				},
			}, nil
		},
	}

	store := newDynamoDBStoreWithClient(mock, "test-table")
	event := testEvent()
	event.Status = StatusClosed

	err := store.Update(context.Background(), event)
	if !errors.Is(err, ErrConcurrentModification) {
		t.Errorf("SECURITY VIOLATION: Concurrent modification should be detected, got: %v", err)
	}
}

// TestSecurityRegression_InvalidStateTransitionPrevented verifies break-glass
// reactivation attacks are prevented.
func TestSecurityRegression_InvalidStateTransitionPrevented(t *testing.T) {
	testCases := []struct {
		name       string
		fromStatus BreakGlassStatus
		toStatus   BreakGlassStatus
		shouldFail bool
	}{
		// Valid transitions
		{"active_to_closed", StatusActive, StatusClosed, false},
		{"active_to_expired", StatusActive, StatusExpired, false},
		// Invalid transitions (reactivation attacks)
		{"closed_to_active", StatusClosed, StatusActive, true},
		{"expired_to_active", StatusExpired, StatusActive, true},
		{"closed_to_expired", StatusClosed, StatusExpired, true},
		{"expired_to_closed", StatusExpired, StatusClosed, true},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			now := time.Now().UTC()
			currentItem := &dynamoItem{
				ID:         "test-id",
				Invoker:    "alice",
				Profile:    "prod",
				ReasonCode: string(ReasonIncident),
				Status:     string(tc.fromStatus),
				CreatedAt:  now.Format(time.RFC3339Nano),
				UpdatedAt:  now.Format(time.RFC3339Nano),
				ExpiresAt:  now.Add(time.Hour).Format(time.RFC3339Nano),
			}

			mock := &mockDynamoDBClient{
				getItemFunc: func(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {
					av, _ := attributevalue.MarshalMap(currentItem)
					return &dynamodb.GetItemOutput{Item: av}, nil
				},
				putItemFunc: func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
					return &dynamodb.PutItemOutput{}, nil
				},
			}

			store := newDynamoDBStoreWithClient(mock, "test-table")
			event := &BreakGlassEvent{
				ID:        "test-id",
				Status:    tc.toStatus,
				UpdatedAt: now,
			}

			err := store.Update(context.Background(), event)

			if tc.shouldFail {
				if !errors.Is(err, ErrInvalidStateTransition) {
					t.Errorf("SECURITY VIOLATION: %s should be prevented, got: %v", tc.name, err)
				}
			} else {
				if errors.Is(err, ErrInvalidStateTransition) {
					t.Errorf("Valid transition %s incorrectly rejected: %v", tc.name, err)
				}
			}
		})
	}
}

// testEvent returns a valid BreakGlassEvent for testing.
func testEvent() *BreakGlassEvent {
	now := time.Now().UTC()
	return &BreakGlassEvent{
		ID:            "test-event-id",
		Invoker:       "alice",
		Profile:       "production",
		ReasonCode:    ReasonIncident,
		Justification: "Production incident",
		Duration:      time.Hour,
		Status:        StatusActive,
		CreatedAt:     now,
		UpdatedAt:     now,
		ExpiresAt:     now.Add(time.Hour),
	}
}
```
  </action>
  <verify>go test ./breakglass/... -v -run TestSecurityRegression</verify>
  <done>breakglass/dynamodb_security_test.go created with 3+ security regression tests</done>
</task>

<task type="auto">
  <name>Task 3: Create session store security regression tests</name>
  <files>session/dynamodb_security_test.go</files>
  <action>
Create security regression tests for session store DynamoDB operations.

Create `session/dynamodb_security_test.go`:

```go
package session

import (
	"context"
	"errors"
	"strings"
	"testing"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

// mockDynamoDBClientSecurity is a test mock for security tests.
type mockDynamoDBClientSecurity struct {
	putItemFunc    func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error)
	getItemFunc    func(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error)
	deleteItemFunc func(ctx context.Context, params *dynamodb.DeleteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error)
	updateItemFunc func(ctx context.Context, params *dynamodb.UpdateItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.UpdateItemOutput, error)
	queryFunc      func(ctx context.Context, params *dynamodb.QueryInput, optFns ...func(*dynamodb.Options)) (*dynamodb.QueryOutput, error)
	scanFunc       func(ctx context.Context, params *dynamodb.ScanInput, optFns ...func(*dynamodb.Options)) (*dynamodb.ScanOutput, error)
}

func (m *mockDynamoDBClientSecurity) PutItem(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
	if m.putItemFunc != nil {
		return m.putItemFunc(ctx, params, optFns...)
	}
	return &dynamodb.PutItemOutput{}, nil
}

func (m *mockDynamoDBClientSecurity) GetItem(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {
	if m.getItemFunc != nil {
		return m.getItemFunc(ctx, params, optFns...)
	}
	return &dynamodb.GetItemOutput{}, nil
}

func (m *mockDynamoDBClientSecurity) DeleteItem(ctx context.Context, params *dynamodb.DeleteItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.DeleteItemOutput, error) {
	if m.deleteItemFunc != nil {
		return m.deleteItemFunc(ctx, params, optFns...)
	}
	return &dynamodb.DeleteItemOutput{}, nil
}

func (m *mockDynamoDBClientSecurity) UpdateItem(ctx context.Context, params *dynamodb.UpdateItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.UpdateItemOutput, error) {
	if m.updateItemFunc != nil {
		return m.updateItemFunc(ctx, params, optFns...)
	}
	return &dynamodb.UpdateItemOutput{}, nil
}

func (m *mockDynamoDBClientSecurity) Query(ctx context.Context, params *dynamodb.QueryInput, optFns ...func(*dynamodb.Options)) (*dynamodb.QueryOutput, error) {
	if m.queryFunc != nil {
		return m.queryFunc(ctx, params, optFns...)
	}
	return &dynamodb.QueryOutput{}, nil
}

func (m *mockDynamoDBClientSecurity) Scan(ctx context.Context, params *dynamodb.ScanInput, optFns ...func(*dynamodb.Options)) (*dynamodb.ScanOutput, error) {
	if m.scanFunc != nil {
		return m.scanFunc(ctx, params, optFns...)
	}
	return &dynamodb.ScanOutput{}, nil
}

// TestSecurityRegression_CreateDuplicatePrevented verifies conditional writes
// prevent duplicate session creation attacks.
func TestSecurityRegression_CreateDuplicatePrevented(t *testing.T) {
	mock := &mockDynamoDBClientSecurity{
		putItemFunc: func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
			if params.ConditionExpression == nil || *params.ConditionExpression != "attribute_not_exists(id)" {
				t.Error("SECURITY VIOLATION: Create() missing uniqueness condition")
			}
			return nil, &types.ConditionalCheckFailedException{Message: aws.String("exists")}
		},
	}

	store := newDynamoDBStoreWithClient(mock, "test-table")
	session := testSession()

	err := store.Create(context.Background(), session)
	if !errors.Is(err, ErrSessionExists) {
		t.Errorf("SECURITY VIOLATION: Create duplicate should return ErrSessionExists, got: %v", err)
	}
}

// TestSecurityRegression_OptimisticLockingUsesOriginalTimestamp verifies that
// Update() properly saves the original UpdatedAt for the condition check.
// This is the bug that was fixed in Plan 01 - ensure it doesn't regress.
func TestSecurityRegression_OptimisticLockingUsesOriginalTimestamp(t *testing.T) {
	originalTime := time.Now().UTC().Add(-time.Hour) // Original timestamp from "previous read"
	var capturedConditionValue string

	mock := &mockDynamoDBClientSecurity{
		putItemFunc: func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
			if params.ConditionExpression == nil || !strings.Contains(*params.ConditionExpression, "updated_at") {
				t.Error("SECURITY VIOLATION: Update() missing optimistic locking condition")
			}
			if val, ok := params.ExpressionAttributeValues[":old_updated_at"]; ok {
				if s, ok := val.(*types.AttributeValueMemberS); ok {
					capturedConditionValue = s.Value
				}
			}
			return &dynamodb.PutItemOutput{}, nil
		},
	}

	store := newDynamoDBStoreWithClient(mock, "test-table")
	session := testSession()
	session.UpdatedAt = originalTime // Simulate session read with this timestamp

	_ = store.Update(context.Background(), session)

	// The condition should use the ORIGINAL timestamp, not a new one
	expectedCondition := originalTime.Format(time.RFC3339Nano)
	if capturedConditionValue != expectedCondition {
		t.Errorf("SECURITY VIOLATION: Condition used %q instead of original %q - optimistic locking broken",
			capturedConditionValue, expectedCondition)
	}

	// The session's UpdatedAt should have been updated to a NEW value (not the original)
	if session.UpdatedAt.Equal(originalTime) {
		t.Error("SECURITY VIOLATION: Session UpdatedAt was not updated - writes would conflict")
	}
}

// TestSecurityRegression_ConcurrentModificationDetected verifies concurrent modification detection.
func TestSecurityRegression_ConcurrentModificationDetected(t *testing.T) {
	mock := &mockDynamoDBClientSecurity{
		putItemFunc: func(ctx context.Context, params *dynamodb.PutItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.PutItemOutput, error) {
			return nil, &types.ConditionalCheckFailedException{Message: aws.String("modified")}
		},
		getItemFunc: func(ctx context.Context, params *dynamodb.GetItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.GetItemOutput, error) {
			return &dynamodb.GetItemOutput{
				Item: map[string]types.AttributeValue{
					"id": &types.AttributeValueMemberS{Value: "test-id"},
				},
			}, nil
		},
	}

	store := newDynamoDBStoreWithClient(mock, "test-table")
	session := testSession()
	session.Status = StatusRevoked

	err := store.Update(context.Background(), session)
	if !errors.Is(err, ErrConcurrentModification) {
		t.Errorf("SECURITY VIOLATION: Concurrent modification should be detected, got: %v", err)
	}
}

// TestSecurityRegression_TouchHasCondition verifies Touch() has attribute_exists condition.
func TestSecurityRegression_TouchHasCondition(t *testing.T) {
	mock := &mockDynamoDBClientSecurity{
		updateItemFunc: func(ctx context.Context, params *dynamodb.UpdateItemInput, optFns ...func(*dynamodb.Options)) (*dynamodb.UpdateItemOutput, error) {
			if params.ConditionExpression == nil || *params.ConditionExpression != "attribute_exists(id)" {
				t.Error("SECURITY VIOLATION: Touch() missing existence condition")
			}
			return &dynamodb.UpdateItemOutput{}, nil
		},
	}

	store := newDynamoDBStoreWithClient(mock, "test-table")
	_ = store.Touch(context.Background(), "session-id")
}

// testSession returns a valid ServerSession for testing.
func testSession() *ServerSession {
	now := time.Now().UTC()
	return &ServerSession{
		ID:               "test-session-id",
		User:             "alice",
		Profile:          "production",
		ServerInstanceID: "server-123",
		Status:           StatusActive,
		StartedAt:        now,
		LastAccessAt:     now,
		ExpiresAt:        now.Add(15 * time.Minute),
		RequestCount:     0,
		SourceIdentity:   "sentinel:alice:abc123",
		CreatedAt:        now,
		UpdatedAt:        now,
	}
}
```
  </action>
  <verify>go test ./session/... -v -run TestSecurityRegression</verify>
  <done>session/dynamodb_security_test.go created with 4+ security regression tests including optimistic locking verification</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./request/... -v -run TestSecurityRegression` passes
- [ ] `go test ./breakglass/... -v -run TestSecurityRegression` passes
- [ ] `go test ./session/... -v -run TestSecurityRegression` passes
- [ ] All tests use TestSecurityRegression_ prefix for CI filtering
- [ ] Tests include SECURITY VIOLATION markers for failure identification
</verification>

<success_criteria>
- Security regression tests created for all three DynamoDB stores
- Tests verify conditional writes (Create, Update, Touch)
- Tests verify state transition validation
- Tests verify optimistic locking uses original timestamp (session store fix)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/131-dynamodb-security/131-02-SUMMARY.md`
</output>
