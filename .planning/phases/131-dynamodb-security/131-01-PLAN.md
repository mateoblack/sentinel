---
phase: 131-dynamodb-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [session/dynamodb.go, request/dynamodb.go, breakglass/dynamodb.go]
autonomous: true
---

<objective>
Fix optimistic locking bug in session store and add state transition validation to prevent invalid status changes.

Purpose: Ensure DynamoDB stores properly implement optimistic locking to prevent concurrent modification attacks and enforce valid state machine transitions at the persistence layer.
Output: Fixed session store Update(), validated status transitions in all three stores.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@session/dynamodb.go
@session/store.go
@session/types.go
@request/dynamodb.go
@request/types.go
@breakglass/dynamodb.go
@breakglass/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix session store optimistic locking bug</name>
  <files>session/dynamodb.go</files>
  <action>
Fix the Update() method in session/dynamodb.go to properly implement optimistic locking.

**Current bug:** The method uses `session.UpdatedAt` directly in both the condition check AND the item being written. This means the condition always checks against the new value, not the original value.

**Compare with request/dynamodb.go (correct implementation):**
```go
// Save original UpdatedAt for optimistic lock condition check
originalUpdatedAt := req.UpdatedAt

// Set new UpdatedAt for the write
req.UpdatedAt = time.Now()

// Condition uses originalUpdatedAt, item uses new req.UpdatedAt
```

**Fix session/dynamodb.go Update() to match this pattern:**

1. At the start of Update(), save the original UpdatedAt:
   ```go
   // Save original UpdatedAt for optimistic lock condition check
   originalUpdatedAt := session.UpdatedAt

   // Set new UpdatedAt for the write (this also updates the caller's session in-place)
   session.UpdatedAt = time.Now()
   ```

2. In the ConditionExpression, use originalUpdatedAt:
   ```go
   ExpressionAttributeValues: map[string]types.AttributeValue{
       ":old_updated_at": &types.AttributeValueMemberS{Value: originalUpdatedAt.Format(time.RFC3339Nano)},
   },
   ```

3. Add doc comment clarifying callers should NOT set UpdatedAt before calling (matches request store pattern).

This ensures the condition checks the original value while writing the new value.
  </action>
  <verify>go build ./... && go test ./session/... -v -run TestDynamoDB</verify>
  <done>session/dynamodb.go Update() saves originalUpdatedAt before overwriting, condition uses original value</done>
</task>

<task type="auto">
  <name>Task 2: Add state transition validation to request store</name>
  <files>request/dynamodb.go, request/types.go</files>
  <action>
Add state transition validation to request store Update() to prevent invalid status changes.

**Valid transitions for Request (from types.go):**
- pending → approved (by approver)
- pending → denied (by approver)
- pending → expired (by TTL)
- pending → cancelled (by requester)

**Invalid transitions to prevent:**
- approved → pending (regression)
- denied → approved (bypass)
- expired → approved (bypass)
- cancelled → approved (bypass)

**Implementation:**

1. In request/types.go, add a ValidTransition method to RequestStatus:
   ```go
   // ValidTransition returns true if transitioning from current status to newStatus is allowed.
   // The request state machine only allows forward transitions from pending.
   func (s RequestStatus) ValidTransition(newStatus RequestStatus) bool {
       // Same status is always valid (idempotent update)
       if s == newStatus {
           return true
       }
       // Only pending can transition to other states
       if s != StatusPending {
           return false
       }
       // From pending, can only go to approved, denied, expired, or cancelled
       switch newStatus {
       case StatusApproved, StatusDenied, StatusExpired, StatusCancelled:
           return true
       default:
           return false
       }
   }
   ```

2. Add sentinel error in request/store.go:
   ```go
   // ErrInvalidStateTransition is returned when attempting an invalid status transition.
   ErrInvalidStateTransition = errors.New("invalid state transition")
   ```

3. In request/dynamodb.go Update(), before the PutItem call, add validation:
   ```go
   // Get current item to validate state transition
   current, err := s.Get(ctx, req.ID)
   if err != nil {
       if errors.Is(err, ErrRequestNotFound) {
           return fmt.Errorf("%s: %w", req.ID, ErrRequestNotFound)
       }
       return err
   }

   // Validate state transition
   if !current.Status.ValidTransition(req.Status) {
       return fmt.Errorf("%s to %s: %w", current.Status, req.Status, ErrInvalidStateTransition)
   }
   ```

Note: The extra Get() call is acceptable for security-critical state transitions. The conditional write still prevents race conditions.
  </action>
  <verify>go build ./... && go test ./request/... -v</verify>
  <done>request store validates state transitions, ErrInvalidStateTransition returned for invalid transitions</done>
</task>

<task type="auto">
  <name>Task 3: Add state transition validation to breakglass store</name>
  <files>breakglass/dynamodb.go, breakglass/types.go</files>
  <action>
Add state transition validation to breakglass store Update() following the same pattern.

**Valid transitions for BreakGlassEvent (from types.go state machine):**
- active → closed (by security review)
- active → expired (by TTL)

**Invalid transitions to prevent:**
- closed → active (reactivation)
- expired → active (reactivation)

**Implementation:**

1. In breakglass/types.go, add ValidTransition method to BreakGlassStatus:
   ```go
   // ValidTransition returns true if transitioning from current status to newStatus is allowed.
   // Break-glass events only allow forward transitions from active to closed/expired.
   func (s BreakGlassStatus) ValidTransition(newStatus BreakGlassStatus) bool {
       // Same status is always valid (idempotent update)
       if s == newStatus {
           return true
       }
       // Only active can transition to other states
       if s != StatusActive {
           return false
       }
       // From active, can only go to closed or expired
       switch newStatus {
       case StatusClosed, StatusExpired:
           return true
       default:
           return false
       }
   }
   ```

2. Add sentinel error in breakglass/store.go:
   ```go
   // ErrInvalidStateTransition is returned when attempting an invalid status transition.
   ErrInvalidStateTransition = errors.New("invalid state transition")
   ```

3. In breakglass/dynamodb.go Update(), add the same validation pattern before PutItem:
   ```go
   // Get current item to validate state transition
   current, err := s.Get(ctx, event.ID)
   if err != nil {
       if errors.Is(err, ErrEventNotFound) {
           return fmt.Errorf("%s: %w", event.ID, ErrEventNotFound)
       }
       return err
   }

   // Validate state transition
   if !current.Status.ValidTransition(event.Status) {
       return fmt.Errorf("%s to %s: %w", current.Status, event.Status, ErrInvalidStateTransition)
   }
   ```
  </action>
  <verify>go build ./... && go test ./breakglass/... -v</verify>
  <done>breakglass store validates state transitions, ErrInvalidStateTransition returned for invalid transitions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./session/... -v` passes
- [ ] `go test ./request/... -v` passes
- [ ] `go test ./breakglass/... -v` passes
- [ ] session/dynamodb.go Update() saves originalUpdatedAt before overwriting
- [ ] request and breakglass stores validate state transitions before Update()
</verification>

<success_criteria>
- Session store optimistic locking bug fixed
- State transition validation added to request and breakglass stores
- Invalid state transitions return ErrInvalidStateTransition
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/131-dynamodb-security/131-01-SUMMARY.md`
</output>
