---
phase: 123-policy-push-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [policy/loader.go, cli/policy.go, cli/policy_test.go]
autonomous: true
---

<objective>
Implement `sentinel policy push` command to validate and upload policy to SSM with confirmation and backup.

Purpose: Complete the policy editing workflow (pull → edit → push) for policy developers.
Output: CLI command with validation, backup fetching, and confirmation prompt.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/121-policy-schema-enhancements/121-01-SUMMARY.md
@.planning/phases/122-policy-pull-command/122-01-SUMMARY.md

# Relevant source files:
@policy/loader.go
@policy/validate.go
@cli/policy.go
@bootstrap/executor.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend SSMAPI interface with PutParameter</name>
  <files>policy/loader.go</files>
  <action>
Add PutParameter method to existing SSMAPI interface in policy/loader.go:
```go
PutParameter(ctx context.Context, params *ssm.PutParameterInput, optFns ...func(*ssm.Options)) (*ssm.PutParameterOutput, error)
```

This extends the existing interface rather than creating a new one, following the pattern that SSMAPI already exists and is used by NewLoaderWithClient.

The interface will now support both read (GetParameter) and write (PutParameter) operations for the policy CLI commands.
  </action>
  <verify>go build ./policy/... succeeds with no errors</verify>
  <done>SSMAPI interface includes PutParameter method</done>
</task>

<task type="auto">
  <name>Task 2: Implement PolicyPushCommand</name>
  <files>cli/policy.go</files>
  <action>
Add PolicyPushCommand to cli/policy.go with the following behavior:

1. **Input struct** (PolicyPushCommandInput):
   - Profile string (positional arg - target profile)
   - InputFile string (positional arg - path to policy YAML file)
   - PolicyRoot string (--policy-root flag, default bootstrap.DefaultPolicyRoot)
   - PolicyParameter string (--policy-parameter flag, explicit SSM path override)
   - Region string (--region flag)
   - AWSProfile string (--aws-profile flag)
   - NoBackup bool (--no-backup flag, skip fetching existing policy as backup)
   - Force bool (--force flag, skip confirmation prompt)
   - Stdin/Stdout/Stderr *os.File (for testing)
   - SSMClient policy.SSMAPI (for testing)

2. **Command flow**:
   a. Read policy file from disk
   b. Validate policy using policy.ValidatePolicy(data)
   c. If validation fails, print error and exit 1
   d. Determine SSM parameter path (PolicyParameter override or derived from profile)
   e. If not --no-backup, attempt to fetch existing policy and display backup info
   f. If not --force, show confirmation prompt with:
      - Parameter path being written to
      - Backup status (exists/new)
      - "Proceed? [y/N]: " prompt
   g. On confirmation, call PutParameter with Overwrite=true
   h. Print success message to stderr

3. **Error handling**:
   - File not found: exit 1 with helpful message
   - Validation error: exit 1 with prefixed error (parse/validation)
   - SSM write error: exit 1 with error and suggestions
   - User cancellation: exit 0 with "Cancelled" message

4. **Registration**: Add push subcommand under policyCmd in ConfigurePolicyCommand.

Use types.ParameterTypeString (not SecureString) matching bootstrap/executor.go pattern.
Wrap SSM client from NewLoader pattern - create ssm.NewFromConfig(awsCfg) directly since Loader doesn't expose write.
  </action>
  <verify>go build ./cli/... succeeds with no errors</verify>
  <done>PolicyPushCommand registered and compiles, handles validation and SSM write</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for PolicyPushCommand</name>
  <files>cli/policy_test.go</files>
  <action>
Extend cli/policy_test.go with tests for PolicyPushCommand:

1. **Extend MockSSMClient** to implement PutParameter:
   - Add PutParameterFunc field for test injection
   - Add PutParameterInput capture for verification

2. **Test cases**:
   - TestPolicyPushCommand_Success: valid file, mock SSM succeeds
   - TestPolicyPushCommand_ValidationError: invalid policy YAML
   - TestPolicyPushCommand_FileNotFound: missing input file
   - TestPolicyPushCommand_SSMError: PutParameter fails
   - TestPolicyPushCommand_NoBackupFlag: --no-backup skips Get
   - TestPolicyPushCommand_ForceFlag: --force skips confirmation
   - TestPolicyPushCommand_PolicyParameterOverride: explicit path used
   - TestPolicyPushCommand_BackupFetch: existing policy fetched as backup

3. **Test helpers**:
   - Create temp file with valid/invalid policy content
   - Use bytes.Buffer for stdin to inject "y\n" for confirmation
   - Capture stderr for message verification

4. **Verification**:
   - Verify PutParameter called with correct path and content
   - Verify Overwrite=true in PutParameterInput
   - Verify exit codes match expected behavior
  </action>
  <verify>go test -v ./cli/... -run PolicyPush passes all tests</verify>
  <done>All policy push tests pass with coverage for success, validation, and error paths</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds with no errors
- [ ] `go test ./policy/...` passes (SSMAPI interface change backward compatible)
- [ ] `go test ./cli/... -run Policy` passes all policy command tests
- [ ] `go vet ./...` passes
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- SSMAPI interface extended with PutParameter
- PolicyPushCommand validates policy before upload
- Confirmation prompt works correctly
- Tests cover success, validation error, SSM error, and flag variations
</success_criteria>

<output>
After completion, create `.planning/phases/123-policy-push-command/123-01-SUMMARY.md`
</output>
