---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [cmd/sentinel/main.go, cli/sentinel.go]
autonomous: true
---

<objective>
Create Sentinel CLI skeleton with kingpin framework, establishing the command structure that will host policy-aware credential commands.

Purpose: Establish the CLI entry point and shared state struct that all Sentinel commands will use.
Output: Working `sentinel` binary with version command, following existing aws-vault patterns.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow:
@main.go
@cli/global.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Sentinel entry point</name>
  <files>cmd/sentinel/main.go</files>
  <action>
Create `cmd/sentinel/main.go` following the pattern from `main.go`:
- Import kingpin/v2 (NOT cobra - the codebase uses kingpin despite roadmap mentioning cobra)
- Create kingpin app with name "sentinel" and description "Intent-aware access control for AWS credentials"
- Add Version variable for compile-time injection
- Call ConfigureSentinelGlobals to set up shared state
- Parse args with kingpin.MustParse

Keep it minimal - just the entry point shell. Do NOT register commands yet beyond version (that's built into kingpin via app.Version()).
  </action>
  <verify>go build -o /tmp/sentinel ./cmd/sentinel && /tmp/sentinel --version</verify>
  <done>sentinel binary builds and responds to --version flag</done>
</task>

<task type="auto">
  <name>Task 2: Create Sentinel globals struct</name>
  <files>cli/sentinel.go</files>
  <action>
Create `cli/sentinel.go` following the pattern from `cli/global.go`:
- Define Sentinel struct with fields:
  - Debug bool (--debug flag)
  - KeyringConfig keyring.Config (for accessing aws-vault keyring)
  - KeyringBackend string (which backend to use)
  - keyringImpl keyring.Keyring (cached keyring instance)
  - awsConfigFile *vault.ConfigFile (cached config)
- Copy keyringConfigDefaults from global.go (same keyring service name "aws-vault" to share credentials)
- Create ConfigureSentinelGlobals(app *kingpin.Application) *Sentinel function that:
  - Sets up --debug flag
  - Sets up --backend flag with available backends
  - Sets up keychain/secret-service/pass/file configuration flags (copy from global.go)
  - Adds PreAction to control debug logging
- Add Keyring() and AwsConfigFile() accessor methods (same pattern as AwsVault struct)

This struct will be passed to all Sentinel commands, just like AwsVault is passed to aws-vault commands.
  </action>
  <verify>go build ./cmd/sentinel ./cli</verify>
  <done>Sentinel struct defined with global configuration, ConfigureSentinelGlobals compiles</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./cmd/sentinel` succeeds
- [ ] `./cmd/sentinel/sentinel --version` shows "dev" (default version)
- [ ] `./cmd/sentinel/sentinel --help` shows global flags (--debug, --backend, etc.)
- [ ] No linter errors: `make lint` passes (or golangci-lint run)
</verification>

<success_criteria>

- sentinel binary builds and runs
- --version and --help work
- Sentinel struct follows AwsVault pattern
- Shares aws-vault keyring configuration
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
