---
phase: 117-api-rate-limiting
plan: 02
type: execute
wave: 2
depends_on: ["117-01"]
files_modified: [sentinel/server.go, sentinel/server_test.go, ratelimit/security_test.go]
autonomous: true
---

<objective>
Add rate limiting to credential server and comprehensive security testing.

Purpose: Protect the credential server endpoint from abuse and ensure rate limiting is security-hardened across both Lambda TVM and credential server.
Output: Credential server with rate limiting middleware, security regression tests for rate limiting behavior.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase - rate limiting types
@.planning/phases/117-api-rate-limiting/117-01-SUMMARY.md

# Credential server to extend
@sentinel/server.go

# Rate limiting types from Plan 01
@ratelimit/types.go
@ratelimit/memory.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rate limiting middleware to credential server</name>
  <files>sentinel/server.go, sentinel/server_test.go</files>
  <action>
Add rate limiting to the Sentinel credential server:

1. In SentinelServerConfig, add rate limiting configuration:
   ```go
   // RateLimiter is the optional rate limiter for credential requests.
   // If nil, rate limiting is disabled.
   RateLimiter ratelimit.RateLimiter

   // RateLimitConfig is used to create a default rate limiter if RateLimiter is nil.
   // If both are nil, rate limiting is disabled.
   RateLimitConfig *ratelimit.Config
   ```

2. In NewSentinelServer, initialize rate limiter if config provided:
   ```go
   // Initialize rate limiter if configured
   if config.RateLimiter == nil && config.RateLimitConfig != nil {
       limiter, err := ratelimit.NewMemoryRateLimiter(*config.RateLimitConfig)
       if err != nil {
           return nil, fmt.Errorf("failed to create rate limiter: %w", err)
       }
       config.RateLimiter = limiter
   }
   ```

3. Create rate limiting middleware function:
   ```go
   // withRateLimiting is middleware that enforces rate limits per remote address.
   func withRateLimiting(limiter ratelimit.RateLimiter, next http.HandlerFunc) http.HandlerFunc {
       return func(w http.ResponseWriter, r *http.Request) {
           if limiter != nil {
               // Use remote address as rate limit key
               // For localhost server, this is always 127.0.0.1 but still provides burst protection
               key := r.RemoteAddr
               allowed, retryAfter, err := limiter.Allow(r.Context(), key)
               if err != nil {
                   log.Printf("WARNING: Rate limit check failed: %v", err)
                   // Fail open - allow the request
               } else if !allowed {
                   log.Printf("RATE_LIMITED: addr=%s retry_after=%v", key, retryAfter)
                   w.Header().Set("Retry-After", fmt.Sprintf("%.0f", retryAfter.Seconds()))
                   writeErrorMessage(w, "Rate limit exceeded", http.StatusTooManyRequests)
                   return
               }
           }
           next.ServeHTTP(w, r)
       }
   }
   ```

4. Wire up middleware in NewSentinelServer (after auth check):
   ```go
   // Middleware chain: logging -> auth -> rate limit -> handler
   s.server.Handler = withLogging(
       withAuthorizationCheck(s.authToken,
           withRateLimiting(config.RateLimiter,
               router.ServeHTTP)))
   ```

5. Add Retry-After header in rate limit response (RFC 7231 compliance).

6. In Shutdown, call Close() on rate limiter if it implements io.Closer.

Tests:
- Test rate limiting rejects requests after limit exceeded
- Test Retry-After header is set correctly
- Test rate limiter errors result in fail-open behavior
- Test nil rate limiter works (disabled)
  </action>
  <verify>go test ./sentinel/... -v -run TestServer</verify>
  <done>Credential server rate limiting working with tests, 429 returned with Retry-After header</done>
</task>

<task type="auto">
  <name>Task 2: Create security regression tests for rate limiting</name>
  <files>ratelimit/security_test.go</files>
  <action>
Create comprehensive security tests for rate limiting:

1. Test: Rate limit cannot be bypassed by varying key slightly
   - Verify same normalized key is rate limited consistently
   - For Lambda: IAM ARN normalization (case sensitivity)

2. Test: Window boundary handling is secure
   - Requests at window boundary don't allow double-counting exploit
   - Sliding window doesn't leak extra requests

3. Test: Concurrent requests respect limits
   - 100 concurrent requests with limit of 10 should only allow 10
   - Use sync.WaitGroup and goroutines to test race conditions

4. Test: Memory exhaustion prevention
   - Rate limiter with many unique keys doesn't exhaust memory
   - Cleanup goroutine removes expired entries
   - Test with 10000+ unique keys, verify memory is bounded

5. Test: Fail-open behavior is consistent
   - Simulate rate limiter internal errors
   - Verify requests are allowed (fail-open)
   - Log warning is emitted

6. Test: Zero/negative config values are rejected
   - RequestsPerWindow <= 0 should error
   - Window <= 0 should error

Add comment header: "Security regression tests for rate limiting to prevent abuse."

Follow patterns from breakglass/ratelimit_security_test.go.
  </action>
  <verify>go test ./ratelimit/... -v -run TestSecurity</verify>
  <done>Security regression tests passing, covering bypass attempts and edge cases</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./ratelimit/... -v -race` passes
- [ ] `go test ./sentinel/... -v` passes
- [ ] Security tests cover bypass attempts and edge cases
- [ ] Both Lambda TVM and credential server have rate limiting
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Credential server returns 429 with Retry-After header when rate limited
- Security tests verify rate limiting cannot be bypassed
- Both endpoints protected against abuse
</success_criteria>

<output>
After completion, create `.planning/phases/117-api-rate-limiting/117-02-SUMMARY.md`
</output>
