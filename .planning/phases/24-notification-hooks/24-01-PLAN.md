---
phase: 24-notification-hooks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [notification/types.go, notification/notifier.go, notification/types_test.go]
autonomous: true
---

<objective>
Define notification event types, Notifier interface, and multi-notifier for composing notification targets.

Purpose: Establish the foundation for pluggable notification delivery on request lifecycle events.
Output: notification package with Event types, Notifier interface, and MultiNotifier for composing targets.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@request/types.go
@request/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification event types</name>
  <files>notification/types.go</files>
  <action>
Create notification/types.go with:

1. EventType string type with constants:
   - EventRequestCreated = "request.created"
   - EventRequestApproved = "request.approved"
   - EventRequestDenied = "request.denied"
   - EventRequestExpired = "request.expired"
   - EventRequestCancelled = "request.cancelled"
   - Add IsValid() method

2. Event struct with fields:
   - Type EventType
   - Request *request.Request (the request that triggered the event)
   - Timestamp time.Time
   - Actor string (who triggered - requester for create/cancel, approver for approve/deny, "system" for expired)

3. NewEvent(eventType EventType, req *request.Request, actor string) *Event constructor

Follow existing type patterns from request/types.go and policy/types.go (string type with IsValid method).
  </action>
  <verify>go build ./notification/... && go test ./notification/... -v</verify>
  <done>EventType constants defined, Event struct with constructor, IsValid method works</done>
</task>

<task type="auto">
  <name>Task 2: Create Notifier interface and MultiNotifier</name>
  <files>notification/notifier.go, notification/types_test.go</files>
  <action>
Add to notification/notifier.go:

1. Notifier interface:
   - Notify(ctx context.Context, event *Event) error

2. MultiNotifier struct:
   - notifiers []Notifier field
   - Implements Notifier interface
   - Notify calls all notifiers, collects errors, returns joined errors if any fail
   - Use errors.Join for combining multiple errors

3. NewMultiNotifier(notifiers ...Notifier) *MultiNotifier constructor
   - Filter out nil notifiers for convenience

4. NoopNotifier struct that implements Notifier (for testing/disabled notifications):
   - Notify returns nil always

Create notification/types_test.go with:
- TestEventTypeIsValid for all event types
- TestNewEvent verifies constructor
- TestMultiNotifier with mock notifiers
- TestNoopNotifier does nothing
  </action>
  <verify>go test ./notification/... -v -cover</verify>
  <done>Notifier interface defined, MultiNotifier composes notifiers, tests pass with coverage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./notification/...` passes
- [ ] Event types follow existing codebase patterns
- [ ] Notifier interface is minimal and testable
</verification>

<success_criteria>

- All tasks completed
- notification package created with types, interface, and multi-notifier
- Tests verify EventType validation, Event construction, MultiNotifier behavior
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/24-notification-hooks/24-01-SUMMARY.md`
</output>
