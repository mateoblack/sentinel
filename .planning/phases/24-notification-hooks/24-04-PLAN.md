---
phase: 24-notification-hooks
plan: 04
type: execute
wave: 3
depends_on: ["24-02", "24-03"]
files_modified: [notification/store.go, notification/store_test.go, cli/request.go, cli/approve.go, cli/deny.go]
autonomous: true
---

<objective>
Create NotifyStore wrapper that fires notifications on request state transitions and wire into CLI commands.

Purpose: Integrate notification delivery into the request lifecycle automatically.
Output: NotifyStore that wraps Store and fires events, CLI commands wired with notification support.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@notification/types.go
@notification/notifier.go
@request/store.go
@request/dynamodb.go
@cli/request.go
@cli/approve.go
@cli/deny.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NotifyStore wrapper</name>
  <files>notification/store.go, notification/store_test.go</files>
  <action>
Create notification/store.go:

1. NotifyStore struct:
   - store request.Store (wrapped store)
   - notifier Notifier (notification target)

2. NewNotifyStore(store request.Store, notifier Notifier) *NotifyStore:
   - If notifier is nil, use NoopNotifier

3. Implement request.Store interface by delegating to wrapped store:
   - Create: after successful store.Create, fire EventRequestCreated with actor=req.Requester
   - Get: delegate directly, no notification
   - Update: detect status transitions and fire appropriate event:
     - If old status was pending and new is approved → EventRequestApproved with actor=req.Approver
     - If old status was pending and new is denied → EventRequestDenied with actor=req.Approver
     - If old status was pending and new is cancelled → EventRequestCancelled with actor=req.Requester
     - If old status was pending and new is expired → EventRequestExpired with actor="system"
   - Delete: delegate directly, no notification
   - ListByRequester, ListByStatus, ListByProfile: delegate directly

4. For Update notification logic:
   - Get current request before update to check old status
   - Only fire notification if update succeeds
   - Fire notification async (goroutine) so it doesn't block the update
   - Log notification errors but don't fail the operation

Create notification/store_test.go:
- Mock store and mock notifier
- TestNotifyStore_Create fires EventRequestCreated
- TestNotifyStore_Update_Approved fires EventRequestApproved
- TestNotifyStore_Update_Denied fires EventRequestDenied
- TestNotifyStore_Update_Cancelled fires EventRequestCancelled
- TestNotifyStore_Update_NoTransition doesn't fire (e.g., updating justification)
- TestNotifyStore_Get_NoNotification
- Verify actor is set correctly for each event type
  </action>
  <verify>go test ./notification/... -v -run NotifyStore</verify>
  <done>NotifyStore fires notifications on state transitions with correct event types and actors</done>
</task>

<task type="auto">
  <name>Task 2: Add notification config and wire into CLI</name>
  <files>cli/request.go, cli/approve.go, cli/deny.go</files>
  <action>
Update CLI commands to support notification configuration:

1. In cli/request.go (RequestCommandInput):
   - Add Notifier notification.Notifier field (optional, nil = no notifications)
   - When creating store, wrap with NotifyStore if Notifier is set
   - The notification fires on Create

2. In cli/approve.go (ApproveCommandInput):
   - Add Notifier notification.Notifier field
   - Wrap store with NotifyStore if Notifier is set
   - The notification fires on Update (status → approved)

3. In cli/deny.go (DenyCommandInput):
   - Add Notifier notification.Notifier field
   - Wrap store with NotifyStore if Notifier is set
   - The notification fires on Update (status → denied)

Pattern: Commands accept optional Notifier. If set, wrap their Store with NotifyStore before use.

Note: Actual notifier construction from environment/config will be done in main.go or a separate config phase. For now, the CLI commands just accept the Notifier interface.
  </action>
  <verify>go build ./... && go test ./cli/... -v -run "Request|Approve|Deny"</verify>
  <done>CLI commands accept Notifier and wrap store with NotifyStore when provided</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./...` passes
- [ ] NotifyStore fires correct events for each transition
- [ ] CLI commands support optional notification
- [ ] Notifications are async and don't block operations
</verification>

<success_criteria>

- All tasks completed
- NotifyStore wraps Store and fires events on transitions
- CLI commands accept Notifier for notification support
- Tests verify notification behavior
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/24-notification-hooks/24-04-SUMMARY.md`
</output>
