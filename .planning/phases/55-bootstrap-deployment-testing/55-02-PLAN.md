---
phase: 55-bootstrap-deployment-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bootstrap/executor_test.go
  - bootstrap/status_test.go
autonomous: true
---

<objective>
Add SSM integration tests for executor and status checker with end-to-end workflow verification.

Purpose: Verify bootstrap workflow integrity (plan → apply → status) and test SSM integration edge cases like pagination, concurrent operations, and error recovery.
Output: Comprehensive integration tests for executor and status components.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@bootstrap/executor.go
@bootstrap/status.go
@bootstrap/executor_test.go
@bootstrap/status_test.go
@testutil/mock_aws.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add status checker pagination and edge case tests</name>
  <files>bootstrap/status_test.go</files>
  <action>Add comprehensive tests for StatusChecker.GetStatus:

**Pagination tests:**
- Empty response (no parameters)
- Single page response
- Multi-page response (mock NextToken handling)
- Large number of parameters (10+)

**Edge cases:**
- Parameters with special characters in name (valid SSM chars)
- Parameters with Version = 0
- Parameters with nil LastModifiedDate
- extractProfileName with various path formats:
  - Trailing slash on policyRoot
  - No trailing slash
  - Deeply nested paths
  - Path same as policyRoot (edge case)

**Error handling:**
- SSM API returns error (access denied, throttling)
- Context cancellation mid-pagination

Use testutil.MockSSMClient.GetParametersByPathFunc for mocking.</action>
  <verify>go test -v ./bootstrap/... -run "Status" passes</verify>
  <done>StatusChecker tests cover pagination, edge cases, and error handling</done>
</task>

<task type="auto">
  <name>Task 2: Add executor workflow and concurrent operation tests</name>
  <files>bootstrap/executor_test.go</files>
  <action>Add tests for Executor.Apply workflow integrity:

**Workflow integrity:**
- Create end-to-end test: create plan → apply → verify result structure
- Test that placeholder policy YAML is valid (parse it with policy.ParsePolicy)
- Verify parameter type is always String (not SecureString)

**Concurrent operations:**
- Simulate concurrent applies to same parameter (first succeeds, second gets AlreadyExists)
- Use t.Parallel() with unique parameter names
- Verify thread-safe behavior of result aggregation

**Error recovery:**
- Test partial failure (some succeed, some fail)
- Verify Failed slice contains correct error messages
- Test that errors don't leak sensitive information

**Update error edge case:**
- Test StateUpdate with overwrite failure
- Verify error wrapping for update failures

Use testutil.MockSSMClient.PutParameterFunc for mocking with state tracking.</action>
  <verify>go test -v ./bootstrap/... -run "Executor" passes, go test -race ./bootstrap/... passes</verify>
  <done>Executor tests cover workflow integrity, concurrent operations, and error recovery</done>
</task>

<task type="auto">
  <name>Task 3: Add end-to-end bootstrap workflow integration test</name>
  <files>bootstrap/executor_test.go</files>
  <action>Add integration test that exercises the full bootstrap workflow:

**TestBootstrapWorkflow_EndToEnd:**
1. Create BootstrapConfig with multiple profiles
2. Use Planner to create plan (mock some existing, some new)
3. Use Executor to apply plan
4. Use StatusChecker to verify results
5. Assert:
   - All created parameters appear in status
   - Existing parameters show correct version
   - Plan summary matches execution results

Use a shared mock that maintains state across Planner, Executor, and StatusChecker calls (in-memory parameter store simulation).

**Mock state implementation:**
- Map[string]*Parameter to simulate SSM state
- GetParameter reads from map
- PutParameter writes to map (with version increment)
- GetParametersByPath lists from map

This validates the three components work together correctly.</action>
  <verify>go test -v ./bootstrap/... -run "EndToEnd" passes</verify>
  <done>End-to-end workflow test validates planner → executor → status integration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test -v ./bootstrap/...` passes all tests
- [ ] `go test -cover ./bootstrap/...` shows >98% coverage
- [ ] `go test -race ./bootstrap/...` passes with no race conditions
- [ ] End-to-end test validates full bootstrap workflow
</verification>

<success_criteria>
- All tasks completed
- Bootstrap package maintains >98% coverage
- Pagination handling fully tested
- Concurrent operation safety verified with race detector
- End-to-end workflow test passes
</success_criteria>

<output>
After completion, create `.planning/phases/55-bootstrap-deployment-testing/55-02-SUMMARY.md`
</output>
