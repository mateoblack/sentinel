---
phase: 88-approval-table-provisioning
plan: 02
type: execute
wave: 2
depends_on: ["88-01"]
files_modified: [infrastructure/provisioner.go, infrastructure/provisioner_test.go]
autonomous: true
---

<objective>
Implement DynamoDB table creation with GSIs for approval workflow infrastructure.

Purpose: Create provisioning logic that translates TableSchema into DynamoDB CreateTable API calls, handles idempotency (table exists), waits for ACTIVE status, and configures TTL.
Output: TableProvisioner with Create(), Plan(), and table status checking methods.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/88-approval-table-provisioning/88-01-SUMMARY.md

Existing patterns:
@bootstrap/executor.go (execution pattern for SSM)
@errors/suggestions.go (DynamoDB error handling with WrapDynamoDBError)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TableProvisioner with DynamoDB operations</name>
  <files>infrastructure/provisioner.go</files>
  <action>
Create TableProvisioner for DynamoDB table provisioning:

1. Define dynamoDBProvisionerAPI interface (for testability):
   - CreateTable(ctx, input) (*CreateTableOutput, error)
   - DescribeTable(ctx, input) (*DescribeTableOutput, error)
   - UpdateTimeToLive(ctx, input) (*UpdateTimeToLiveOutput, error)

2. TableProvisioner struct:
   - client dynamoDBProvisionerAPI
   - region string

3. Constructor:
   - NewTableProvisioner(cfg aws.Config, region string) *TableProvisioner
   - Uses dynamodb.NewFromConfig(cfg)

4. ProvisionResult struct:
   - TableName string
   - Status string (CREATED, EXISTS, FAILED)
   - ARN string (table ARN if created/exists)
   - Error error (if failed)

5. Methods:

   a) Create(ctx, schema TableSchema) (*ProvisionResult, error)
   - Check if table exists via DescribeTable
   - If exists and ACTIVE: return EXISTS status with ARN
   - If exists but not ACTIVE: wait for ACTIVE (polling with backoff)
   - If not exists: call CreateTable with schema translated to DynamoDB input
   - Wait for table to become ACTIVE (use waiter or polling)
   - Configure TTL via UpdateTimeToLive if TTLAttribute set
   - Return CREATED status with ARN
   - Wrap errors using sentinelerrors.WrapDynamoDBError

   b) Plan(ctx, schema TableSchema) (*ProvisionPlan, error)
   - Check if table exists
   - Return plan showing what would be created (table, GSIs, TTL config)
   - ProvisionPlan struct: WouldCreate bool, TableName, GSIs []string, TTLAttribute

   c) TableStatus(ctx, tableName string) (string, error)
   - Return current table status (ACTIVE, CREATING, etc.) or "NOT_FOUND"

6. Helper: schemaToCreateTableInput(schema TableSchema) *dynamodb.CreateTableInput
   - Translate TableSchema to DynamoDB API input
   - Set KeySchema from PartitionKey/SortKey
   - Set AttributeDefinitions for all keys used in table and GSIs
   - Set GlobalSecondaryIndexes with Projection type ALL
   - Set BillingMode from schema

Follow existing error patterns: use sentinelerrors.WrapDynamoDBError for all DynamoDB errors.
Use backoff for waiting: start 1s, max 30s, total timeout 5 minutes.
  </action>
  <verify>go build ./infrastructure/... compiles without errors</verify>
  <done>TableProvisioner with Create(), Plan(), TableStatus() methods. Handles idempotency and waits for ACTIVE.</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive unit tests for provisioner</name>
  <files>infrastructure/provisioner_test.go</files>
  <action>
Create unit tests for TableProvisioner using mock DynamoDB client:

1. Mock client:
   - mockDynamoDBProvisionerClient with function fields for each API call
   - Can inject responses and errors

2. Test Create():
   - Table doesn't exist: creates table, waits for ACTIVE, configures TTL, returns CREATED
   - Table exists and ACTIVE: returns EXISTS with ARN (no create attempted)
   - Table exists but CREATING: waits for ACTIVE, returns EXISTS
   - CreateTable fails with access denied: returns wrapped error
   - CreateTable fails with other error: returns wrapped error
   - Wait timeout: returns error after polling limit
   - TTL configuration fails: returns error (table created but TTL failed)

3. Test Plan():
   - Table doesn't exist: returns WouldCreate=true with details
   - Table exists: returns WouldCreate=false
   - DescribeTable fails: returns error

4. Test TableStatus():
   - Table exists: returns status string
   - Table not found: returns "NOT_FOUND"
   - API error: returns wrapped error

5. Test schemaToCreateTableInput():
   - Correctly translates partition key
   - Correctly translates sort key when present
   - Correctly translates GSIs
   - Sets billing mode
   - AttributeDefinitions includes all unique keys

Use table-driven tests. Target >90% coverage on provisioner.go.
  </action>
  <verify>go test -v -cover ./infrastructure/... shows >90% coverage</verify>
  <done>All provisioner paths tested with mock client. Error cases covered.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./infrastructure/...` succeeds
- [ ] `go test -v ./infrastructure/...` passes all tests
- [ ] `go test -cover ./infrastructure/...` shows >90% coverage
- [ ] No gofmt issues: `gofmt -l infrastructure/`
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Create() handles idempotency (existing tables)
- Plan() shows accurate preview without making changes
- Errors wrapped with sentinelerrors for consistent UX
</success_criteria>

<output>
After completion, create `.planning/phases/88-approval-table-provisioning/88-02-SUMMARY.md`
</output>
