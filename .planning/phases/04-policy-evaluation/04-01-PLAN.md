---
phase: 04-policy-evaluation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified: [policy/evaluate.go, policy/evaluate_test.go]
autonomous: true
---

<objective>
Implement rule matching engine that evaluates credential requests against policy rules.

Purpose: Core decision logic that determines whether a credential request should be allowed or denied based on policy rules. This is the "brain" of Sentinel - the enforcement point.
Output: Evaluate() function with Request and Decision types, comprehensive test coverage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior work this plan depends on:
@policy/types.go - Policy, Rule, Condition, TimeWindow, HourRange, Effect types
@policy/validate.go - Validation patterns, hourFormatRegex

# Existing patterns:
# - Effect type with EffectAllow, EffectDeny constants
# - Condition has Profiles []string, Users []string, Time *TimeWindow
# - TimeWindow has Days []Weekday, Hours *HourRange, Timezone string
# - Weekday constants and IsValid() method
</context>

<feature>
  <name>Rule Matching Engine</name>
  <files>policy/evaluate.go, policy/evaluate_test.go</files>
  <behavior>
    Request contains: User (string), Profile (string), Time (time.Time)

    Evaluate(policy *Policy, req *Request) Decision:
    - Iterate rules in order
    - For each rule, check if ALL conditions match:
      - Profiles: req.Profile in rule.Conditions.Profiles (or empty = matches all)
      - Users: req.User in rule.Conditions.Users (or empty = matches all)
      - Time: req.Time within TimeWindow (days, hours, timezone)
    - First matching rule determines outcome
    - If no rules match: default deny

    Test cases:
    - Allow rule with matching profile → Decision{Effect: allow, MatchedRule: rule.Name}
    - Deny rule with matching user → Decision{Effect: deny, MatchedRule: rule.Name}
    - Multiple rules, first match wins
    - Empty profiles condition matches any profile
    - Empty users condition matches any user
    - Time window: day matches → allow
    - Time window: day doesn't match → skip rule
    - Time window: hour within range → allow
    - Time window: hour outside range → skip rule
    - Time window with timezone conversion
    - No matching rules → default deny with MatchedRule: ""
  </behavior>
  <implementation>
    Request struct:
    - User string
    - Profile string
    - Time time.Time

    Decision struct:
    - Effect Effect
    - MatchedRule string (name of rule that matched, empty if default deny)
    - Reason string (from matched rule, or "no matching rule" for default)

    Evaluate function:
    - Loop through policy.Rules
    - Call matchesConditions(rule.Conditions, req) for each
    - matchesConditions checks profiles, users, time
    - Time matching: convert req.Time to rule timezone, check day and hours
    - Return first match or default deny

    Helper functions:
    - matchesConditions(c Condition, req *Request) bool
    - matchesProfiles(profiles []string, profile string) bool
    - matchesUsers(users []string, user string) bool
    - matchesTimeWindow(tw *TimeWindow, t time.Time) bool
    - matchesDays(days []Weekday, t time.Time) bool
    - matchesHours(hr *HourRange, t time.Time) bool
    - parseHourMinute(s string) (hour, minute int) - reuse hourFormatRegex
  </implementation>
</feature>

<verification>
```bash
go test -v ./policy/... -run TestEvaluate
```
All tests pass, coverage for happy paths and edge cases.
</verification>

<success_criteria>
- RED: Failing tests written for all behavior cases
- GREEN: Evaluate() implementation passes all tests
- REFACTOR: Clean helper functions, no duplication
- All 2-3 commits present (test, feat, refactor)
</success_criteria>

<output>
After completion, create `.planning/phases/04-policy-evaluation/04-01-SUMMARY.md`
</output>
