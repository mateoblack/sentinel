---
phase: 04-policy-evaluation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified: [policy/evaluate.go, policy/evaluate_test.go]
autonomous: true
---

<objective>
Enhance Decision result with full matched rule context for logging and debugging.

Purpose: Provide rich context about why a decision was made - essential for audit trails and troubleshooting policy issues.
Output: Enhanced Decision type with complete rule context, additional test coverage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan output (must exist):
@.planning/phases/04-policy-evaluation/04-01-SUMMARY.md

# Files from 04-01:
@policy/evaluate.go
@policy/evaluate_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rule context to Decision</name>
  <files>policy/evaluate.go</files>
  <action>
    Enhance Decision struct with additional context fields:
    - RuleIndex int - position of matched rule in policy (0-based, -1 if no match)
    - Conditions *Condition - copy of matched rule's conditions for logging
    - EvaluatedAt time.Time - timestamp when evaluation occurred

    Update Evaluate() to populate these fields:
    - RuleIndex from loop counter
    - Conditions from matched rule (nil for default deny)
    - EvaluatedAt from time.Now() at start of function

    Add String() method to Decision for human-readable output:
    - Format: "ALLOW by rule 'name' (index N)" or "DENY by rule 'name' (index N)"
    - For default deny: "DENY (no matching rule)"
  </action>
  <verify>go build ./policy/...</verify>
  <done>Decision struct has RuleIndex, Conditions, EvaluatedAt fields; String() method exists</done>
</task>

<task type="auto">
  <name>Task 2: Add tests for enhanced context</name>
  <files>policy/evaluate_test.go</files>
  <action>
    Add test cases for new Decision fields:
    - TestDecisionContext_MatchedRule: verify RuleIndex, Conditions populated correctly
    - TestDecisionContext_DefaultDeny: verify RuleIndex is -1, Conditions is nil
    - TestDecisionContext_EvaluatedAt: verify timestamp is reasonable (within 1 second of now)
    - TestDecision_String: verify String() output format for allow, deny, and default deny

    Use table-driven tests following existing patterns in policy/*_test.go.
  </action>
  <verify>go test -v ./policy/... -run TestDecision</verify>
  <done>All new context tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test -v ./policy/...` - all tests pass
- [ ] `go build ./policy/...` - builds without errors
- [ ] Decision.String() produces readable output
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Decision provides full context for logging
- 2 commits: feat (context fields), test (context tests)
</success_criteria>

<output>
After completion, create `.planning/phases/04-policy-evaluation/04-02-SUMMARY.md`
</output>
