---
phase: 52-breakglass-security-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [breakglass/state_security_test.go]
autonomous: true
---

<objective>
Add security-focused tests for break-glass state machine that verify state transition security and temporal constraints.

Purpose: Validate the state machine enforces security invariants - terminal states are immutable, only valid transitions occur, and expiry is enforced.
Output: New test file with state machine security tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-test-infrastructure/50-02-SUMMARY.md

@breakglass/types.go
@breakglass/validate.go
@breakglass/checker.go
@breakglass/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add terminal state immutability tests</name>
  <files>breakglass/state_security_test.go</files>
  <action>
Create new test file `breakglass/state_security_test.go` with state machine security tests.

Test terminal state immutability:
- TestCanTransitionTo_ClosedIsImmutable: StatusClosed cannot transition to any state (active, expired, closed)
- TestCanTransitionTo_ExpiredIsImmutable: StatusExpired cannot transition to any state
- TestCanTransitionTo_TerminalToTerminalBlocked: closed -> expired and expired -> closed both blocked

Test valid transitions:
- TestCanTransitionTo_ActiveToClosed: active -> closed is valid
- TestCanTransitionTo_ActiveToExpired: active -> expired is valid
- TestCanTransitionTo_ActiveToActiveBlocked: active -> active is not valid (not a transition)

Test invalid status handling:
- TestCanTransitionTo_InvalidStatusFrom: Unknown status cannot transition
- TestCanTransitionTo_InvalidStatusTo: Cannot transition to unknown status
- TestCanTransitionTo_EmptyStatus: Empty string status is rejected

Use exhaustive table-driven tests covering all status combinations.
  </action>
  <verify>go test -v -run "TestCanTransitionTo" ./breakglass/</verify>
  <done>Terminal state tests pass, verifying immutability of closed/expired states</done>
</task>

<task type="auto">
  <name>Task 2: Add event validity and expiry tests</name>
  <files>breakglass/state_security_test.go</files>
  <action>
Add event validity and expiry security tests to `breakglass/state_security_test.go`:

Test isBreakGlassValid invariants:
- TestIsBreakGlassValid_ActiveAndFutureExpiry: Both conditions required for validity
- TestIsBreakGlassValid_ActiveButPastExpiry: Active status but expired time = invalid
- TestIsBreakGlassValid_FutureExpiryButClosed: Future expiry but closed status = invalid
- TestIsBreakGlassValid_ExactlyAtExpiry: Expiry at current moment = invalid (after check)

Test FindActiveBreakGlass security:
- TestFindActiveBreakGlass_ExpiredEventFiltered: Event with past ExpiresAt is filtered even if Status=active
- TestFindActiveBreakGlass_ClosedEventFiltered: Event with Status=closed is filtered even if ExpiresAt future
- TestFindActiveBreakGlass_OnlyValidEventReturned: Among multiple events, only valid one returned
- TestFindActiveBreakGlass_NoStackingAllowed: Cannot have multiple active events for same invoker+profile (if store prevents)

Test time boundary:
- TestIsBreakGlassValid_OneNanosecondBeforeExpiry: Just before expiry = valid
- TestIsBreakGlassValid_OneNanosecondAfterExpiry: Just after expiry = invalid
  </action>
  <verify>go test -v -run "TestIsBreakGlassValid|TestFindActiveBreakGlass.*Filter" ./breakglass/</verify>
  <done>Event validity tests pass, verifying expiry enforcement and status checking</done>
</task>

<task type="auto">
  <name>Task 3: Add status enum security tests</name>
  <files>breakglass/state_security_test.go</files>
  <action>
Add status and reason code enum security tests to `breakglass/state_security_test.go`:

Test BreakGlassStatus exhaustiveness:
- TestBreakGlassStatus_AllValidStatuses: active, closed, expired all return IsValid() == true
- TestBreakGlassStatus_InvalidStrings: "Active" (capitalized), "pending", "unknown", "" all return IsValid() == false
- TestBreakGlassStatus_IsTerminal_Exhaustive: Only closed and expired are terminal
- TestBreakGlassStatus_String_Identity: String() returns the expected string value

Test ReasonCode exhaustiveness:
- TestReasonCode_AllValidCodes: incident, maintenance, security, recovery, other all valid
- TestReasonCode_InvalidStrings: "INCIDENT" (caps), "urgent", "emergency", "" all invalid
- TestReasonCode_String_Identity: String() returns expected values

Test enum type safety:
- TestBreakGlassStatus_TypeSafety: Cannot accidentally use ReasonCode as BreakGlassStatus
- TestReasonCode_TypeSafety: Cannot accidentally use BreakGlassStatus as ReasonCode

Use table-driven tests for exhaustive coverage of all valid values and common invalid inputs.
  </action>
  <verify>go test -v -run "TestBreakGlassStatus_|TestReasonCode_" ./breakglass/</verify>
  <done>Enum tests pass, verifying type safety and exhaustive value coverage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All new tests pass: `go test -v ./breakglass/...`
- [ ] No regressions in existing tests
- [ ] Coverage maintained or improved: `go test -cover ./breakglass/...`
</verification>

<success_criteria>

- All 3 task test suites pass
- Terminal state immutability verified (closed/expired cannot transition)
- Event validity properly enforces expiry time
- Status and reason code enums are exhaustively tested
- No state machine bypass possible
</success_criteria>

<output>
After completion, create `.planning/phases/52-breakglass-security-testing/52-02-SUMMARY.md`
</output>
