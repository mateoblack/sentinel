---
phase: 52-breakglass-security-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [breakglass/ratelimit_security_test.go]
autonomous: true
---

<objective>
Add security-focused tests for break-glass rate limiting that verify security invariants beyond functional correctness.

Purpose: Validate rate limiting enforces security boundaries - check ordering, boundary conditions, and edge cases that could lead to rate limit bypass.
Output: New test file with security invariant tests for rate limiting logic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50-test-infrastructure/50-02-SUMMARY.md

@breakglass/ratelimit.go
@breakglass/checker.go
@breakglass/ratelimit_test.go
@breakglass/checker_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add rate limit check order security tests</name>
  <files>breakglass/ratelimit_security_test.go</files>
  <action>
Create new test file `breakglass/ratelimit_security_test.go` with security invariant tests.

Test check order enforcement (security-critical ordering):
- TestCheckRateLimit_Order_CooldownBeforeQuota: Verify cooldown is checked before user/profile quota (early exit on cooldown failure)
- TestCheckRateLimit_Order_UserQuotaBeforeProfileQuota: Verify user quota is checked before profile quota
- TestCheckRateLimit_Order_EscalationDoesNotBlock: Verify escalation threshold flags but never blocks access

Use mock store that tracks call order to verify check sequence. Each test should:
1. Configure a policy with all limits set
2. Use mock that records which methods are called and in what order
3. Verify the check short-circuits at the correct point

Pattern: Use a call-tracking mock with `Calls []string` that appends method names.
  </action>
  <verify>go test -v -run "TestCheckRateLimit_Order" ./breakglass/</verify>
  <done>Check order tests pass, verifying cooldown -> user quota -> profile quota -> escalation order</done>
</task>

<task type="auto">
  <name>Task 2: Add rate limit boundary condition tests</name>
  <files>breakglass/ratelimit_security_test.go</files>
  <action>
Add boundary condition tests to `breakglass/ratelimit_security_test.go`:

Test quota boundary conditions:
- TestCheckRateLimit_Boundary_ExactlyAtUserLimit: count == MaxPerUser should block (>= comparison)
- TestCheckRateLimit_Boundary_OneBelowUserLimit: count == MaxPerUser-1 should allow
- TestCheckRateLimit_Boundary_ExactlyAtProfileLimit: count == MaxPerProfile should block
- TestCheckRateLimit_Boundary_OneBelowProfileLimit: count == MaxPerProfile-1 should allow

Test cooldown boundary conditions:
- TestCheckRateLimit_Boundary_ExactlyAtCooldown: elapsed == Cooldown should allow (cooldown period elapsed)
- TestCheckRateLimit_Boundary_OneNanosecondBeforeCooldown: elapsed == Cooldown-1ns should block
- TestCheckRateLimit_Boundary_ZeroElapsed: elapsed == 0 should block

Test quota window boundaries:
- TestCheckRateLimit_Boundary_EventAtWindowStart: Event exactly at window boundary should count
- TestCheckRateLimit_Boundary_EventBeforeWindow: Event 1ns before window should not count

Use table-driven tests with precise time values. These tests verify >= and < comparisons are correct.
  </action>
  <verify>go test -v -run "TestCheckRateLimit_Boundary" ./breakglass/</verify>
  <done>Boundary tests pass, verifying exact boundary behavior for quotas and cooldowns</done>
</task>

<task type="auto">
  <name>Task 3: Add rate limit rule matching security tests</name>
  <files>breakglass/ratelimit_security_test.go</files>
  <action>
Add rule matching security tests to `breakglass/ratelimit_security_test.go`:

Test first-match-wins invariant:
- TestFindRateLimitRule_FirstMatchWins_Strict: With overlapping rules (specific then wildcard), specific rule applies
- TestFindRateLimitRule_FirstMatchWins_WildcardFirst: If wildcard comes first, it applies even when specific would match
- TestFindRateLimitRule_ProfileCaseSensitive: Profile matching is case-sensitive ("Production" != "production")

Test edge cases:
- TestFindRateLimitRule_EmptyProfile: Empty profile string should only match wildcard rules
- TestFindRateLimitRule_MultipleWildcards: First wildcard wins
- TestFindRateLimitRule_NoRulesAfterMatch: Rules after first match are never evaluated (use mock to verify)

Test combined scenarios:
- TestCheckRateLimit_DifferentRulesForDifferentProfiles: Verify correct rule applied per profile
- TestCheckRateLimit_RateLimitNotAppliedWhenNoMatch: No matching rule = no rate limit (security decision)
  </action>
  <verify>go test -v -run "TestFindRateLimitRule_|TestCheckRateLimit_.*Rules" ./breakglass/</verify>
  <done>Rule matching tests pass, verifying first-match-wins and case sensitivity</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All new tests pass: `go test -v ./breakglass/...`
- [ ] No regressions in existing tests
- [ ] Coverage maintained or improved: `go test -cover ./breakglass/...`
</verification>

<success_criteria>

- All 3 task test suites pass
- Check order invariants verified (cooldown -> quota -> escalation)
- Boundary conditions verified (exact limits, cooldown edges)
- Rule matching invariants verified (first-match-wins, case sensitivity)
- No rate limit bypass possible through boundary manipulation
</success_criteria>

<output>
After completion, create `.planning/phases/52-breakglass-security-testing/52-01-SUMMARY.md`
</output>
