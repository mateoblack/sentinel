---
phase: 127-breakglass-mfa
plan: 03
type: execute
wave: 2
depends_on: ["127-01"]
files_modified:
  - mfa/security_test.go
  - cmd/sentinel/main.go
autonomous: true
---

<objective>
Add security regression tests for MFA bypass prevention and integrate MFA configuration into Sentinel CLI.

Purpose: Ensure MFA cannot be bypassed through various attack vectors and provide CLI configuration for MFA verifiers.
Output: Comprehensive security tests and CLI flag/environment configuration for MFA.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/127-breakglass-mfa/127-01-SUMMARY.md
@cmd/sentinel/main.go
@mfa/types.go
@mfa/totp.go
@mfa/sms.go

# Security test patterns from existing codebase:
# - TestSecurity_ prefix for security-focused tests
# - Explicit SECURITY comments explaining attack scenario
# - Test both positive (attack blocked) and negative (normal operation) cases
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MFA security regression tests</name>
  <files>mfa/security_test.go</files>
  <action>
Create comprehensive security tests for MFA verifiers:

1. **TestSecurity_TOTP_ReplayAttack**:
   - SECURITY: Verify TOTP codes cannot be replayed after use
   - For stateless TOTP, codes are valid for their time window (30s)
   - Test that same code works within window (expected behavior)
   - Document that TOTP replay window is inherent to RFC 6238

2. **TestSecurity_TOTP_BruteForce**:
   - SECURITY: Verify brute force is impractical
   - Document: 6-digit code = 1M combinations
   - Document: 30-second window limits attempts
   - Test: Invalid codes are rejected (foundation for rate limiting)

3. **TestSecurity_TOTP_ClockSkew**:
   - SECURITY: Verify skew doesn't open excessive window
   - Test with skew=1: codes from t-30s, t, t+30s valid
   - Test with skew=0: only current period valid
   - Verify skew=2+ is rejected in config validation (if implemented)

4. **TestSecurity_SMS_ChallengeReuse**:
   - SECURITY: Verify SMS challenge cannot be reused after verification
   - Create challenge, verify with correct code
   - Attempt second verification with same challenge ID
   - Verify second attempt fails (challenge consumed)

5. **TestSecurity_SMS_ChallengeExpiry**:
   - SECURITY: Verify expired challenges are rejected
   - Create challenge, wait for expiry (mock time)
   - Attempt verification after expiry
   - Verify attempt fails with expiry error

6. **TestSecurity_SMS_TimingAttack**:
   - SECURITY: Verify code comparison is timing-safe
   - Use AST inspection (like existing security tests) to verify:
     - `subtle.ConstantTimeCompare` is used for code comparison
     - No early return on partial match
   - Reference: sentinel/security_integration_test.go pattern

7. **TestSecurity_SMS_ChallengeIDGuessing**:
   - SECURITY: Verify challenge IDs are unguessable
   - Verify challenge ID is 16 hex chars (64 bits entropy)
   - Verify random IDs don't collide in reasonable sample (1000 IDs)

8. **TestSecurity_MFA_MethodDowngrade**:
   - SECURITY: Verify cannot downgrade from policy-required method
   - Policy requires MFA with methods: ["totp"]
   - Attempt to use SMS method
   - Verify rejection (method not allowed)

9. **TestSecurity_MFA_BypassWithEmptyCode**:
   - SECURITY: Verify empty code doesn't bypass verification
   - Attempt verify with empty string code
   - Verify rejection (invalid code, not bypass)

All tests should include:
- `// SECURITY: ...` comment explaining the attack being prevented
- Clear assertion messages indicating security violation if test fails
  </action>
  <verify>go test ./mfa -run TestSecurity -v</verify>
  <done>Security regression tests cover replay, brute force, timing attacks, and bypass attempts</done>
</task>

<task type="auto">
  <name>Task 2: Add MFA configuration to Sentinel CLI</name>
  <files>cmd/sentinel/main.go</files>
  <action>
Wire MFA verifiers into Sentinel CLI main.go:

1. **Add MFA configuration environment variables**:
   ```go
   // MFA Configuration
   // SENTINEL_MFA_TOTP_SECRETS_PARAM - SSM parameter path for TOTP secrets JSON
   //   Format: {"user1": {"secret": "BASE32SECRET"}, "user2": {...}}
   // SENTINEL_MFA_SMS_PHONES_PARAM - SSM parameter path for SMS phone numbers JSON
   //   Format: {"user1": "+1XXXXXXXXXX", "user2": "+1YYYYYYYYYY"}
   ```

2. **Add MFA loader function**:
   ```go
   // loadMFAVerifiers creates MFA verifiers from environment configuration.
   // Returns nil if no MFA configuration is present (MFA disabled).
   func loadMFAVerifiers(ctx context.Context, awsCfg aws.Config) (mfa.Verifier, error) {
       totpParam := os.Getenv("SENTINEL_MFA_TOTP_SECRETS_PARAM")
       smsParam := os.Getenv("SENTINEL_MFA_SMS_PHONES_PARAM")

       if totpParam == "" && smsParam == "" {
           return nil, nil // MFA not configured
       }

       var verifiers []mfa.Verifier
       ssmClient := ssm.NewFromConfig(awsCfg)

       // Load TOTP secrets if configured
       if totpParam != "" {
           secrets, err := loadTOTPSecrets(ctx, ssmClient, totpParam)
           if err != nil {
               return nil, fmt.Errorf("load TOTP secrets: %w", err)
           }
           verifiers = append(verifiers, mfa.NewTOTPVerifier(secrets))
       }

       // Load SMS phones if configured
       if smsParam != "" {
           phones, err := loadSMSPhones(ctx, ssmClient, smsParam)
           if err != nil {
               return nil, fmt.Errorf("load SMS phones: %w", err)
           }
           verifiers = append(verifiers, mfa.NewSMSVerifier(awsCfg, phones))
       }

       // Return composite verifier if multiple configured
       if len(verifiers) == 1 {
           return verifiers[0], nil
       }
       return mfa.NewMultiVerifier(verifiers...), nil
   }
   ```

3. **Add helper functions**:
   ```go
   func loadTOTPSecrets(ctx context.Context, client ssmAPI, paramPath string) (map[string]mfa.TOTPConfig, error) {
       // Get parameter from SSM
       // Parse JSON to map[string]mfa.TOTPConfig
       // Return parsed config
   }

   func loadSMSPhones(ctx context.Context, client ssmAPI, paramPath string) (map[string]string, error) {
       // Get parameter from SSM
       // Parse JSON to map[string]string
       // Return parsed config
   }
   ```

4. **Add MultiVerifier to mfa package** (if not already):
   ```go
   // MultiVerifier tries verifiers in order until one succeeds.
   type MultiVerifier struct {
       verifiers []Verifier
   }

   func NewMultiVerifier(verifiers ...Verifier) *MultiVerifier {
       return &MultiVerifier{verifiers: verifiers}
   }

   func (m *MultiVerifier) Challenge(ctx context.Context, userID string) (*MFAChallenge, error) {
       // Try first verifier that works
       for _, v := range m.verifiers {
           challenge, err := v.Challenge(ctx, userID)
           if err == nil {
               return challenge, nil
           }
       }
       return nil, errors.New("no verifier could issue challenge")
   }

   func (m *MultiVerifier) Verify(ctx context.Context, challengeID string, code string) (bool, error) {
       // Try all verifiers (TOTP is stateless, SMS has challenge ID)
       for _, v := range m.verifiers {
           valid, err := v.Verify(ctx, challengeID, code)
           if err == nil && valid {
               return true, nil
           }
       }
       return false, nil
   }
   ```

5. **Wire into breakglass command setup**:
   - In ConfigureBreakGlassCommand or command action, load MFA verifier
   - Pass to BreakGlassCommandInput.MFAVerifier

Note: This follows the existing pattern of environment-variable-driven configuration in cmd/sentinel/main.go. The SSM storage pattern matches TOTP secrets and phone numbers being sensitive data.
  </action>
  <verify>go build ./cmd/sentinel && SENTINEL_MFA_TOTP_SECRETS_PARAM="" SENTINEL_MFA_SMS_PHONES_PARAM="" ./sentinel breakglass --help</verify>
  <done>MFA verifiers load from SSM configuration and wire into break-glass command</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./mfa -run TestSecurity -v` passes all security tests
- [ ] `go build ./cmd/sentinel` succeeds
- [ ] Security tests cover replay, timing, and bypass attacks
- [ ] MFA configuration loads from environment/SSM
</verification>

<success_criteria>

- All tasks completed
- Security regression tests pass
- CLI loads MFA configuration from environment
- MFA verifiers wire into break-glass command
</success_criteria>

<output>
After completion, create `.planning/phases/127-breakglass-mfa/127-03-SUMMARY.md`
</output>
