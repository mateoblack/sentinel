---
phase: 127-breakglass-mfa
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mfa/types.go
  - mfa/types_test.go
  - mfa/totp.go
  - mfa/totp_test.go
  - mfa/sms.go
  - mfa/sms_test.go
autonomous: true
---

<objective>
Create MFA verification infrastructure with TOTP and SMS providers for break-glass secondary verification.

Purpose: Foundation for break-glass MFA enforcement. Provides verifier interface and two implementations (TOTP, SMS) that can be composed for multi-factor verification.
Output: New `mfa/` package with types, TOTP verifier, and SMS verifier using SNS direct publish.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@notification/sns.go
@breakglass/types.go

# SNS SMS Direct Publishing:
# - Use PhoneNumber parameter (not TopicArn) for direct SMS
# - E.164 format required (+1XXXXXXXXXX)
# - MessageAttributes for SMS type: { "AWS.SNS.SMS.SMSType": { DataType: "String", StringValue: "Transactional" } }
#
# TOTP (RFC 6238):
# - Use crypto/hmac and crypto/sha1 for HMAC-SHA1
# - Standard 30-second time step, 6-digit codes
# - Base32-encoded secrets (RFC 4648)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MFA types and verifier interface</name>
  <files>mfa/types.go, mfa/types_test.go</files>
  <action>
Create new `mfa/` package with core types:

1. **MFAMethod type** (string alias with validation):
   - `MethodTOTP MFAMethod = "totp"` - Time-based One-Time Password
   - `MethodSMS MFAMethod = "sms"` - SMS code delivery
   - Add `IsValid() bool` method

2. **MFAChallenge struct**:
   - `ID string` - unique challenge ID (16 hex chars like break-glass ID)
   - `Method MFAMethod` - which method was used
   - `Target string` - phone number (SMS) or empty (TOTP)
   - `Code string` - the generated code (for SMS, stored for verification)
   - `ExpiresAt time.Time` - when challenge expires (5 minutes default)
   - `CreatedAt time.Time`
   - Add `IsExpired() bool` method

3. **Verifier interface**:
   ```go
   type Verifier interface {
       // Challenge initiates MFA. For TOTP, returns empty challenge (user provides code).
       // For SMS, sends code and returns challenge with ID for verification.
       Challenge(ctx context.Context, userID string) (*MFAChallenge, error)

       // Verify checks if the provided code is valid for the challenge.
       // For TOTP, challengeID is ignored (stateless verification).
       Verify(ctx context.Context, challengeID string, code string) (bool, error)
   }
   ```

4. **Constants**:
   - `DefaultChallengeTTL = 5 * time.Minute`
   - `CodeLength = 6`

5. **NewChallengeID() string** - generates 16-char hex ID (same pattern as break-glass)

Tests: Validate MFAMethod.IsValid(), MFAChallenge.IsExpired(), NewChallengeID() format.
  </action>
  <verify>go build ./mfa && go test ./mfa -run TestMFA -v</verify>
  <done>MFA types compile and pass validation tests</done>
</task>

<task type="auto">
  <name>Task 2: Implement TOTP verifier (RFC 6238)</name>
  <files>mfa/totp.go, mfa/totp_test.go</files>
  <action>
Create TOTP verifier implementation:

1. **TOTPConfig struct**:
   - `Secret string` - Base32-encoded shared secret (per-user, from config)
   - `Digits int` - Number of digits (default 6)
   - `Period int` - Time step in seconds (default 30)
   - `Skew int` - Allow codes from adjacent time steps (default 1 for clock drift)

2. **TOTPVerifier struct**:
   - `secrets map[string]TOTPConfig` - userID -> config (loaded from break-glass policy)

3. **NewTOTPVerifier(secrets map[string]TOTPConfig) *TOTPVerifier**

4. **Challenge implementation** (TOTP is stateless):
   - Return empty MFAChallenge with Method=MethodTOTP
   - User must provide code from their authenticator app

5. **Verify implementation**:
   - Lookup user's secret from secrets map
   - Generate valid codes for current time step +/- skew
   - Use crypto/hmac with sha1 for HMAC-SHA1 (RFC 6238 default)
   - Return (true, nil) if code matches any valid code
   - Return (false, nil) if code doesn't match (not an error)
   - Return (false, error) if user not found in secrets

6. **Internal generateTOTP(secret string, counter uint64, digits int) string**:
   - Decode Base32 secret
   - Compute HMAC-SHA1(secret, counter as 8-byte big-endian)
   - Dynamic truncation per RFC 4226
   - Return zero-padded digit string

Tests:
- Test with known RFC 6238 test vectors
- Test skew handling (codes from adjacent periods valid)
- Test invalid codes rejected
- Test unknown user returns error
  </action>
  <verify>go test ./mfa -run TestTOTP -v</verify>
  <done>TOTP verifier passes RFC 6238 test vectors and handles clock skew</done>
</task>

<task type="auto">
  <name>Task 3: Implement SMS verifier using SNS direct publish</name>
  <files>mfa/sms.go, mfa/sms_test.go</files>
  <action>
Create SMS verifier implementation:

1. **SMSAPI interface** (for testing):
   ```go
   type SMSAPI interface {
       Publish(ctx context.Context, params *sns.PublishInput, optFns ...func(*sns.Options)) (*sns.PublishOutput, error)
   }
   ```

2. **SMSConfig struct**:
   - `PhoneNumbers map[string]string` - userID -> E.164 phone number

3. **SMSVerifier struct**:
   - `client SMSAPI` - SNS client
   - `phones map[string]string` - userID -> phone number
   - `challenges map[string]*smsChallenge` - challengeID -> challenge (in-memory, protected by mutex)
   - `mu sync.RWMutex`

4. **smsChallenge struct** (internal):
   - `code string` - the sent code
   - `expiresAt time.Time`

5. **NewSMSVerifier(cfg aws.Config, phones map[string]string) *SMSVerifier**

6. **Challenge implementation**:
   - Lookup user's phone number (error if not found)
   - Generate 6-digit random code using crypto/rand
   - Store challenge with 5-minute TTL
   - Send SMS via SNS direct publish:
     ```go
     client.Publish(ctx, &sns.PublishInput{
         PhoneNumber: aws.String(phoneNumber), // E.164 format
         Message:     aws.String(fmt.Sprintf("Sentinel break-glass verification code: %s", code)),
         MessageAttributes: map[string]types.MessageAttributeValue{
             "AWS.SNS.SMS.SMSType": {
                 DataType:    aws.String("String"),
                 StringValue: aws.String("Transactional"),
             },
         },
     })
     ```
   - Return MFAChallenge with ID, Method=MethodSMS, Target=phone (masked)

7. **Verify implementation**:
   - Lookup challenge by ID (error if not found)
   - Check expiry (return false if expired, delete challenge)
   - Compare codes using crypto/subtle.ConstantTimeCompare (timing-safe)
   - Delete challenge after verification (one-time use)
   - Return (true, nil) on match, (false, nil) on mismatch

8. **maskPhone(phone string) string** - show last 4 digits only (e.g., "***-***-1234")

Tests with mock SMSAPI:
- Test successful SMS send and verify
- Test expired challenge rejected
- Test invalid code rejected
- Test challenge used only once
- Test unknown user returns error
- Test timing-safe comparison (verify constant-time is used)
  </action>
  <verify>go test ./mfa -run TestSMS -v</verify>
  <done>SMS verifier sends codes and verifies with timing-safe comparison</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./mfa` succeeds
- [ ] `go test ./mfa -v` passes all tests
- [ ] `go vet ./mfa` reports no issues
- [ ] TOTP test vectors match RFC 6238 expected values
- [ ] SMS verifier uses timing-safe comparison
</verification>

<success_criteria>

- All tasks completed
- MFA package compiles and passes tests
- TOTP implementation matches RFC 6238
- SMS implementation uses SNS direct publish
- Timing-safe comparison for code verification
</success_criteria>

<output>
After completion, create `.planning/phases/127-breakglass-mfa/127-01-SUMMARY.md`
</output>
