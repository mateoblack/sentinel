---
phase: 127-breakglass-mfa
plan: 02
type: execute
wave: 2
depends_on: ["127-01"]
files_modified:
  - breakglass/policy.go
  - breakglass/policy_test.go
  - cli/breakglass.go
  - cli/breakglass_test.go
  - logging/breakglass.go
  - logging/breakglass_test.go
autonomous: false
---

<objective>
Integrate MFA verification into break-glass flow with policy-based requirements and audit logging.

Purpose: Enforce secondary verification before granting emergency access, preventing abuse of break-glass privilege.
Output: Extended break-glass policy with MFA requirements, updated CLI command with MFA challenge/verify flow, and MFA verification logging.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/127-breakglass-mfa/127-01-SUMMARY.md
@breakglass/policy.go
@cli/breakglass.go
@logging/breakglass.go

# MFA types from 127-01:
# - mfa.Verifier interface with Challenge() and Verify()
# - mfa.MFAMethod (totp, sms)
# - mfa.MFAChallenge struct
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend break-glass policy with MFA requirements</name>
  <files>breakglass/policy.go, breakglass/policy_test.go</files>
  <action>
Add MFA configuration to break-glass policy:

1. **Add MFARequirement struct** to policy.go:
   ```go
   // MFARequirement specifies MFA enforcement for break-glass.
   type MFARequirement struct {
       // Required enables MFA verification before break-glass access.
       // If true, users must complete MFA challenge before invoking break-glass.
       Required bool `yaml:"required" json:"required"`

       // Methods lists allowed MFA methods (empty = all methods allowed).
       // Valid values: "totp", "sms"
       Methods []string `yaml:"methods,omitempty" json:"methods,omitempty"`
   }
   ```

2. **Add MFA field to BreakGlassPolicyRule**:
   ```go
   type BreakGlassPolicyRule struct {
       // ... existing fields ...

       // MFA specifies multi-factor authentication requirements.
       // If nil, MFA is not required for this rule.
       MFA *MFARequirement `yaml:"mfa,omitempty" json:"mfa,omitempty"`
   }
   ```

3. **Add validation in rule.validate()**:
   - If MFA.Required is true and Methods is non-empty, validate each method is "totp" or "sms"
   - Allow empty Methods (means any method is acceptable)

4. **Add helper function**:
   ```go
   // RequiresMFA returns true if the rule requires MFA verification.
   func (r *BreakGlassPolicyRule) RequiresMFA() bool {
       return r.MFA != nil && r.MFA.Required
   }

   // IsMethodAllowed returns true if the given MFA method is allowed by the rule.
   // Returns true if no method restrictions (empty Methods list).
   func (r *BreakGlassPolicyRule) IsMethodAllowed(method string) bool {
       if r.MFA == nil || len(r.MFA.Methods) == 0 {
           return true
       }
       for _, m := range r.MFA.Methods {
           if m == method {
               return true
           }
       }
       return false
   }
   ```

Tests:
- Test rule with MFA required and methods specified validates
- Test rule with invalid MFA method fails validation
- Test RequiresMFA() returns correct value
- Test IsMethodAllowed() with various configurations
  </action>
  <verify>go test ./breakglass -run TestBreakGlassPolicy -v</verify>
  <done>Break-glass policy supports MFA requirements with method restrictions</done>
</task>

<task type="auto">
  <name>Task 2: Add MFA challenge/verify flow to break-glass command</name>
  <files>cli/breakglass.go, cli/breakglass_test.go</files>
  <action>
Integrate MFA verification into break-glass command:

1. **Add MFA fields to BreakGlassCommandInput**:
   ```go
   type BreakGlassCommandInput struct {
       // ... existing fields ...

       // MFAVerifier is an optional verifier for MFA challenges.
       // If nil and policy requires MFA, command will fail.
       MFAVerifier mfa.Verifier

       // MFACode is the pre-provided MFA code (for non-interactive use).
       // If empty and MFA required, prompts for code.
       MFACode string

       // MFAMethod specifies which MFA method to use (totp, sms).
       // If empty and multiple methods allowed, defaults to first in policy list.
       MFAMethod string
   }
   ```

2. **Add CLI flags**:
   - `--mfa-code` - Pre-provide MFA code (for scripting)
   - `--mfa-method` - Specify method preference (totp, sms)

3. **Update BreakGlassCommand flow** (after policy check, before rate limit check):
   ```go
   // Check if MFA is required
   if rule != nil && rule.RequiresMFA() {
       if input.MFAVerifier == nil {
           return errors.New("MFA required but no verifier configured")
       }

       // Determine method
       method := input.MFAMethod
       if method == "" && len(rule.MFA.Methods) > 0 {
           method = rule.MFA.Methods[0] // default to first allowed
       }
       if !rule.IsMethodAllowed(method) {
           return fmt.Errorf("MFA method %q not allowed by policy", method)
       }

       // For SMS: initiate challenge first
       var challengeID string
       if method == string(mfa.MethodSMS) {
           challenge, err := input.MFAVerifier.Challenge(ctx, username)
           if err != nil {
               return fmt.Errorf("failed to send MFA challenge: %w", err)
           }
           challengeID = challenge.ID
           fmt.Fprintf(os.Stderr, "MFA code sent to %s\n", challenge.Target)
       }

       // Get code (from flag or prompt)
       code := input.MFACode
       if code == "" {
           fmt.Fprint(os.Stderr, "Enter MFA code: ")
           // Read from stdin (simple line read, no echo)
           var inputCode string
           fmt.Scanln(&inputCode)
           code = strings.TrimSpace(inputCode)
       }

       // Verify
       valid, err := input.MFAVerifier.Verify(ctx, challengeID, code)
       if err != nil {
           return fmt.Errorf("MFA verification failed: %w", err)
       }
       if !valid {
           return errors.New("invalid MFA code")
       }
   }
   ```

4. **Add MFA verification to output** (for audit trail):
   - Add `MFAVerified bool` and `MFAMethod string` to BreakGlassCommandOutput
   - Include in JSON output when MFA was used

Tests with mock verifier:
- Test break-glass succeeds when MFA not required
- Test break-glass fails when MFA required but no verifier
- Test break-glass succeeds with valid MFA code
- Test break-glass fails with invalid MFA code
- Test method restriction enforcement
- Test pre-provided code via --mfa-code flag
  </action>
  <verify>go test ./cli -run TestBreakGlass -v</verify>
  <done>Break-glass command supports MFA challenge/verify flow with method selection</done>
</task>

<task type="auto">
  <name>Task 3: Add MFA verification to break-glass audit logging</name>
  <files>logging/breakglass.go, logging/breakglass_test.go</files>
  <action>
Extend break-glass logging to capture MFA verification:

1. **Add MFA fields to BreakGlassLogEntry**:
   ```go
   type BreakGlassLogEntry struct {
       // ... existing fields ...

       // MFA fields (omitempty for backward compatibility)
       MFARequired bool   `json:"mfa_required,omitempty"`
       MFAMethod   string `json:"mfa_method,omitempty"`
       MFAVerified bool   `json:"mfa_verified,omitempty"`
   }
   ```

2. **Add MFAInfo parameter to NewBreakGlassLogEntry** or create variant:
   ```go
   // WithMFA returns a copy of the log entry with MFA information added.
   func (e *BreakGlassLogEntry) WithMFA(required bool, method string, verified bool) *BreakGlassLogEntry {
       copy := *e
       copy.MFARequired = required
       copy.MFAMethod = method
       copy.MFAVerified = verified
       return &copy
   }
   ```

3. **Update CLI to log MFA info**:
   - When MFA was required and verified, call entry.WithMFA(true, method, true)
   - Log the enhanced entry

Tests:
- Test MFA fields included in JSON output when set
- Test MFA fields omitted when not set (omitempty)
- Test WithMFA creates proper copy with fields set
  </action>
  <verify>go test ./logging -run TestBreakGlass -v</verify>
  <done>Break-glass audit logs include MFA verification details</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>MFA-protected break-glass flow with TOTP/SMS verification and audit logging</what-built>
  <how-to-verify>
    1. Review the MFA integration in cli/breakglass.go
    2. Verify policy parsing with MFA requirements in breakglass/policy.go
    3. Check logging captures MFA verification in logging/breakglass.go
    4. Confirm test coverage for MFA paths
    5. Run: go test ./breakglass ./cli ./logging -v | grep -E "(PASS|FAIL)"
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./breakglass -run TestBreakGlassPolicy -v` passes
- [ ] `go test ./cli -run TestBreakGlass -v` passes
- [ ] `go test ./logging -run TestBreakGlass -v` passes
- [ ] MFA fields use omitempty for backward compatibility
</verification>

<success_criteria>

- All tasks completed
- Break-glass policy supports MFA requirements
- CLI command enforces MFA when policy requires it
- Audit logs capture MFA verification
- User approved MFA flow design
</success_criteria>

<output>
After completion, create `.planning/phases/127-breakglass-mfa/127-02-SUMMARY.md`
</output>
