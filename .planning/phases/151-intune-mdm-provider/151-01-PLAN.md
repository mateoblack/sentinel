---
phase: 151-intune-mdm-provider
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [mdm/intune.go, mdm/intune_test.go, lambda/config.go]
autonomous: true
---

<objective>
Implement Microsoft Intune MDM provider for device posture verification via Microsoft Graph API.

Purpose: Enable Sentinel Lambda TVM to verify device compliance status through Microsoft Intune, supporting enterprises using Intune for device management alongside the existing Jamf Pro provider.

Output: Working IntuneProvider implementing the mdm.Provider interface with OAuth2 client credentials authentication and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# MDM provider interface and patterns:
@mdm/provider.go
@mdm/types.go
@mdm/jamf.go
@mdm/jamf_test.go

# Lambda TVM integration:
@lambda/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement IntuneProvider with OAuth2 authentication</name>
  <files>mdm/intune.go</files>
  <action>
Create IntuneProvider implementing mdm.Provider interface. Structure:

1. **OAuth2 token management**:
   - Azure AD token endpoint: `https://login.microsoftonline.com/{tenantID}/oauth2/v2.0/token`
   - Client credentials flow (client_id, client_secret, scope=https://graph.microsoft.com/.default)
   - Token caching: store token with expiration, refresh when expired or within 5 min of expiry
   - Thread-safe token access (sync.RWMutex)

2. **IntuneProvider struct**:
   ```go
   type IntuneProvider struct {
       httpClient  intuneAPI
       tenantID    string
       clientID    string
       clientSecret string  // From MDMConfig.APIToken
       timeout     time.Duration

       // Token cache (thread-safe)
       tokenMu     sync.RWMutex
       accessToken string
       tokenExpiry time.Time
   }
   ```

3. **NewIntuneProvider constructor**:
   - Require: BaseURL (not used but validates config), APIToken (client_secret), TenantID
   - TenantID is required (Azure AD tenant GUID)
   - Parse clientID:clientSecret from APIToken (format: "client_id:client_secret")
   - Apply default timeout if not specified

4. **Name() method**: Return "intune"

5. **getAccessToken(ctx) method**:
   - Check cached token validity (expiry minus 5 min buffer)
   - If valid, return cached token
   - Otherwise, POST to token endpoint with client_credentials grant
   - Parse JSON response: {"access_token": "...", "expires_in": 3600, ...}
   - Cache token with calculated expiry time
   - Return token or error

6. **LookupDevice(ctx, deviceID) method**:
   - Get access token (handles refresh)
   - Query: GET https://graph.microsoft.com/v1.0/deviceManagement/managedDevices?$filter=azureADDeviceId eq '{deviceID}'
   - Also try: $filter=deviceName eq '{deviceID}' as fallback (some orgs use device name)
   - Authorization: Bearer {token}
   - Accept: application/json
   - Handle HTTP status codes:
     - 401/403 → ErrMDMAuthFailed
     - 404 or empty results → ErrDeviceNotFound
     - 5xx or timeout → ErrMDMUnavailable
   - Parse response and map to MDMDeviceInfo

7. **Response types** (local to intune.go):
   ```go
   type intuneTokenResponse struct {
       AccessToken string `json:"access_token"`
       ExpiresIn   int    `json:"expires_in"`  // seconds
       TokenType   string `json:"token_type"`
   }

   type intuneDevicesResponse struct {
       Value []intuneDevice `json:"value"`
   }

   type intuneDevice struct {
       ID                string `json:"id"`
       DeviceName        string `json:"deviceName"`
       ComplianceState   string `json:"complianceState"`  // "compliant", "noncompliant", "inGracePeriod", "unknown"
       LastSyncDateTime  string `json:"lastSyncDateTime"` // ISO8601
       OperatingSystem   string `json:"operatingSystem"`
       OSVersion         string `json:"osVersion"`
       AzureADDeviceId   string `json:"azureADDeviceId"`
       IsEncrypted       bool   `json:"isEncrypted"`
       JailBroken        string `json:"jailBroken"`
   }
   ```

8. **Compliance mapping**:
   - Enrolled: true if device found in response
   - Compliant: complianceState == "compliant"
   - ComplianceDetails: non-empty if not compliant (e.g., "Device compliance state: noncompliant")

**AVOID:**
- Don't use BaseURL for Graph API (always use https://graph.microsoft.com)
- Don't store tokens in plain struct without mutex (race condition)
- Don't hardcode v1.0 in multiple places (use constant)
  </action>
  <verify>go build ./mdm/... compiles without errors</verify>
  <done>IntuneProvider implements mdm.Provider interface, OAuth2 token management works, LookupDevice queries Graph API</done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive tests for IntuneProvider</name>
  <files>mdm/intune_test.go</files>
  <action>
Create tests following the patterns in jamf_test.go:

1. **TestNewIntuneProvider**:
   - nil config returns error
   - missing TenantID returns error
   - missing APIToken returns error
   - invalid APIToken format (not client_id:client_secret) returns error
   - valid config creates provider
   - default timeout applied when not specified
   - custom timeout applied when specified

2. **TestIntuneProvider_getAccessToken**:
   - Mock HTTP server returns valid token response
   - Token cached on subsequent calls (verify only one HTTP request)
   - Token refreshed when expired
   - 401 response returns ErrMDMAuthFailed
   - Network error returns ErrMDMUnavailable
   - Invalid JSON returns error

3. **TestIntuneProvider_LookupDevice_Success**:
   - Mock server returns valid device with complianceState="compliant"
   - Verify Authorization header has Bearer token
   - Verify MDMDeviceInfo fields populated correctly
   - Verify MDMProvider="intune"

4. **TestIntuneProvider_LookupDevice_NonCompliant**:
   - Mock server returns device with complianceState="noncompliant"
   - Verify Compliant=false and ComplianceDetails populated

5. **TestIntuneProvider_LookupDevice_NotFound**:
   - Mock server returns empty {"value": []}
   - Verify ErrDeviceNotFound returned

6. **TestIntuneProvider_LookupDevice_AuthFailed**:
   - 401 returns ErrMDMAuthFailed wrapped in MDMError
   - 403 returns ErrMDMAuthFailed wrapped in MDMError

7. **TestIntuneProvider_LookupDevice_Timeout**:
   - Server delays beyond timeout
   - ErrMDMUnavailable returned

8. **TestIntuneProvider_LookupDevice_EmptyDeviceID**:
   - Empty string deviceID returns ErrDeviceNotFound

9. **TestIntuneProvider_ImplementsProviderInterface**:
   - Compile-time check: var _ Provider = provider

10. **Test token expiry handling**:
    - First call caches token
    - Call within expiry uses cache
    - Call after expiry refreshes

Use httptest.NewServer for mock HTTP responses. Follow exact patterns from jamf_test.go for consistency.
  </action>
  <verify>go test ./mdm/... -v passes all tests including new Intune tests</verify>
  <done>All Intune provider tests pass, test coverage includes success/error/edge cases</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Intune provider with Lambda TVM config</name>
  <files>lambda/config.go</files>
  <action>
Update LoadConfigFromEnv to support Intune provider:

1. **Add TenantID environment variable constant**:
   ```go
   EnvMDMTenantID = "SENTINEL_MDM_TENANT_ID"  // Azure AD tenant ID for Intune
   ```

2. **Update MDM provider switch in LoadConfigFromEnv**:
   Replace the current Intune case:
   ```go
   case "intune":
       // Intune requires TenantID for Azure AD authentication
       tenantID := os.Getenv(EnvMDMTenantID)
       if tenantID == "" {
           return nil, fmt.Errorf("%s required for Intune provider", EnvMDMTenantID)
       }
       mdmConfig.TenantID = tenantID
       provider, err := mdm.NewIntuneProvider(mdmConfig)
       if err != nil {
           return nil, fmt.Errorf("failed to create Intune MDM provider: %w", err)
       }
       cfg.MDMProvider = provider
   ```

3. **APIToken format for Intune**:
   The MDM API token for Intune should be in format "client_id:client_secret"
   stored in Secrets Manager. Document this in the log message:
   ```go
   log.Printf("INFO: Intune MDM provider initialized (tenant: %s)", tenantID)
   ```

4. **Update existing log warning** to remove "not yet implemented" message since we're implementing it now.

**AVOID:**
- Don't change existing Jamf or Kandji logic
- Don't modify the MDMConfig struct (TenantID field already exists in mdm/types.go)
  </action>
  <verify>go build ./lambda/... compiles without errors</verify>
  <done>Lambda config supports SENTINEL_MDM_PROVIDER=intune with SENTINEL_MDM_TENANT_ID required</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./mdm/...` succeeds
- [ ] `go build ./lambda/...` succeeds
- [ ] `go test ./mdm/... -v` passes all tests
- [ ] `go vet ./mdm/... ./lambda/...` reports no issues
- [ ] IntuneProvider implements mdm.Provider interface (compile-time check in test)
</verification>

<success_criteria>

- IntuneProvider fully implements mdm.Provider interface
- OAuth2 client credentials flow authenticates with Azure AD
- Device lookup queries Microsoft Graph API with proper filtering
- complianceState mapped correctly to MDMDeviceInfo.Compliant
- All error cases handled (auth, not found, timeout, network)
- Lambda TVM config supports intune provider type
- Test coverage matches Jamf provider patterns
</success_criteria>

<output>
After completion, create `.planning/phases/151-intune-mdm-provider/151-01-SUMMARY.md`
</output>
