---
phase: 78-server-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [sentinel/server.go, sentinel/server_test.go]
autonomous: true
---

<objective>
Create the core Sentinel credential server that evaluates policy on every credential request.

Purpose: Enable real-time credential revocation by checking policy before each credential issuance rather than once at startup.
Output: SentinelServer type in sentinel/server.go with policy-aware credential handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key source files to understand existing patterns:
@server/ecsserver.go
@cli/sentinel_exec.go
@cli/sentinel_provider.go
@policy/evaluate.go
@logging/decision_log.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SentinelServer type with policy-aware credential serving</name>
  <files>sentinel/server.go</files>
  <action>
Create sentinel/server.go with:

1. SentinelServerConfig struct containing:
   - ProfileName (string) - AWS profile to serve credentials for
   - PolicyParameter (string) - SSM parameter path for policy
   - Region (string) - AWS region
   - NoSession (bool) - Skip STS session token
   - SessionDuration (time.Duration) - Credential duration
   - User (string) - Username for SourceIdentity (from STS GetCallerIdentity at server startup)
   - Logger (logging.Logger) - For decision logging
   - Store (request.Store) - Optional approval request store
   - BreakGlassStore (breakglass.Store) - Optional break-glass store
   - PolicyLoader (policy.Loader) - Cached policy loader
   - Sentinel (*cli.Sentinel) - For credential retrieval
   - LazyLoad (bool) - Defer credential prefetch

2. SentinelServer struct containing:
   - listener (net.Listener)
   - authToken (string)
   - server (http.Server)
   - config (SentinelServerConfig)

3. NewSentinelServer(ctx context.Context, config SentinelServerConfig, authToken string, port int) (*SentinelServer, error):
   - Listen on 127.0.0.1:{port} (0 for auto-assign)
   - Generate random authToken if empty (use generateRandomString() pattern from server/ecsserver.go)
   - Prefetch credentials to ensure validity unless LazyLoad
   - Set up HTTP router with withLogging and withAuthorizationCheck middleware (copy from server/ecsserver.go)
   - Route "/" to DefaultRoute (policy-gated credential serving)

4. DefaultRoute(w http.ResponseWriter, r *http.Request):
   - Build policy.Request{User: config.User, Profile: config.ProfileName, Time: time.Now()}
   - Load policy via config.PolicyLoader.Load(ctx, config.PolicyParameter)
   - Evaluate policy: decision := policy.Evaluate(loadedPolicy, policyRequest)
   - If decision.Effect == policy.EffectDeny:
     - Check approved request via request.FindApprovedRequest (if Store != nil)
     - Check active break-glass via breakglass.FindActiveBreakGlass (if BreakGlassStore != nil)
     - If neither found: write 403 error with JSON {"Message": "Policy denied access"}, log decision, return
   - If allowed (or approved/break-glass override):
     - Generate requestID via identity.NewRequestID()
     - Build SentinelCredentialRequest with User, RequestID for SourceIdentity
     - Retrieve credentials via config.Sentinel.GetCredentialsWithSourceIdentity()
     - Log decision with CredentialIssuanceFields
     - Write credentials JSON (same format as server/ecsserver.go: AccessKeyId, SecretAccessKey, Token, Expiration)

5. Helper methods:
   - BaseURL() string - returns http://{listener.Addr()}
   - AuthToken() string - returns authToken
   - Serve() error - calls server.Serve(listener)
   - Shutdown(ctx context.Context) error - graceful shutdown

Key patterns to follow:
- Use same JSON response format as server/ecsserver.go for SDK compatibility
- Use same authorization header pattern (withAuthorizationCheck)
- Use iso8601.Format() for Expiration timestamp
- Log with log.Printf for debug output
  </action>
  <verify>go build ./sentinel/... compiles without errors</verify>
  <done>SentinelServer type exists with policy evaluation on each credential request</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for SentinelServer policy evaluation</name>
  <files>sentinel/server_test.go</files>
  <action>
Create sentinel/server_test.go with tests for:

1. TestSentinelServer_PolicyAllow - policy allows, credentials served
2. TestSentinelServer_PolicyDeny - policy denies, 403 returned
3. TestSentinelServer_PolicyDenyWithApproval - policy denies, approved request exists, credentials served
4. TestSentinelServer_PolicyDenyWithBreakGlass - policy denies, active break-glass exists, credentials served
5. TestSentinelServer_AuthorizationRequired - missing auth token returns 403
6. TestSentinelServer_DecisionLogging - verify decision logs are written for allow and deny

Test infrastructure needed:
- MockLogger that captures LogDecision calls
- MockPolicyLoader that returns configurable policy
- MockRequestStore and MockBreakGlassStore from testutil
- MockSentinel that returns configurable credentials

Pattern: Use httptest.Server or direct handler calls with httptest.NewRecorder.
  </action>
  <verify>go test ./sentinel/... -run Server -v passes all tests</verify>
  <done>Unit tests cover policy allow, deny, approval override, break-glass override, and auth scenarios</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./sentinel/... succeeds
- [ ] go test ./sentinel/... -run Server passes
- [ ] No race conditions: go test ./sentinel/... -race passes
</verification>

<success_criteria>

- SentinelServer type created with policy evaluation per request
- Authorization token middleware protects endpoint
- Decision logging works for all outcomes
- Tests cover allow, deny, approval, break-glass scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/78-server-infrastructure/78-01-SUMMARY.md`
</output>
