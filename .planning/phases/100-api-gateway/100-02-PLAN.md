---
phase: 100-api-gateway
plan: 02
type: execute
wave: 2
depends_on: ["100-01"]
files_modified: [lambda/config.go, lambda/handler.go, cmd/lambda-tvm/main.go]
autonomous: true
---

<objective>
Integrate routing and profile discovery into Lambda entry point.

Purpose: Wire up the Router in main.go so API Gateway can use multiple paths, and add profile root configuration.
Output: Lambda entry point uses Router, supporting both credential vending and profile discovery.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/100-api-gateway/100-01-PLAN.md

Lambda files to update:
@lambda/config.go
@cmd/lambda-tvm/main.go

New files from 100-01:
@lambda/routes.go
@lambda/profiles.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add policy root configuration</name>
  <files>lambda/config.go</files>
  <action>
Update `lambda/config.go` to add PolicyRoot configuration for profile discovery:

1. Add environment variable constant:
   ```go
   const (
       // ... existing constants ...
       EnvPolicyRoot = "SENTINEL_POLICY_ROOT"
   )
   ```

2. Add PolicyRoot field to TVMConfig:
   ```go
   type TVMConfig struct {
       // ... existing fields ...

       // PolicyRoot is the SSM path root for policy discovery (e.g., "/sentinel/policies").
       // Used by profile discovery endpoint.
       // If empty, defaults to extracting from PolicyParameter.
       PolicyRoot string
   }
   ```

3. Update LoadConfigFromEnv to set PolicyRoot:
   ```go
   func LoadConfigFromEnv(ctx context.Context) (*TVMConfig, error) {
       cfg := &TVMConfig{
           // ... existing assignments ...
           PolicyRoot: os.Getenv(EnvPolicyRoot),
       }

       // ... existing code ...

       // Derive policy root from policy parameter if not explicitly set
       // e.g., "/sentinel/policies/production" -> "/sentinel/policies"
       if cfg.PolicyRoot == "" && cfg.PolicyParameter != "" {
           cfg.PolicyRoot = extractPolicyRoot(cfg.PolicyParameter)
       }

       return cfg, nil
   }
   ```

4. Add extractPolicyRoot helper:
   ```go
   // extractPolicyRoot extracts the policy root directory from a full parameter path.
   // For example, "/sentinel/policies/production" -> "/sentinel/policies".
   func extractPolicyRoot(parameterPath string) string {
       lastSlash := strings.LastIndex(parameterPath, "/")
       if lastSlash <= 0 {
           return "/sentinel/policies" // Default fallback
       }
       return parameterPath[:lastSlash]
   }
   ```

Add import for "strings".
  </action>
  <verify>
  - `gofmt -e lambda/config.go` shows no syntax errors
  - EnvPolicyRoot constant defined
  - PolicyRoot field in TVMConfig
  - extractPolicyRoot function exists
  </verify>
  <done>
  - PolicyRoot configuration field added
  - Environment variable SENTINEL_POLICY_ROOT supported
  - Auto-derived from PolicyParameter when not set
  </done>
</task>

<task type="auto">
  <name>Task 2: Update NewHandler factory</name>
  <files>lambda/handler.go</files>
  <action>
Update `lambda/handler.go` to support lazy initialization:

1. Change NewHandler to accept optional config:
   ```go
   // NewHandler creates a new TVM handler.
   // If cfg is nil, configuration will be loaded from environment on first request.
   func NewHandler(cfg ...*TVMConfig) *Handler {
       if len(cfg) > 0 && cfg[0] != nil {
           return &Handler{Config: cfg[0]}
       }
       return &Handler{}
   }
   ```

2. Add lazy config initialization in HandleRequest (at the start):
   ```go
   func (h *Handler) HandleRequest(ctx context.Context, req events.APIGatewayV2HTTPRequest) (events.APIGatewayV2HTTPResponse, error) {
       // Lazy-load config from environment if not provided
       if h.Config == nil {
           cfg, err := LoadConfigFromEnv(ctx)
           if err != nil {
               return errorResponse(http.StatusInternalServerError, "CONFIG_ERROR",
                   "Failed to load configuration: "+err.Error())
           }
           h.Config = cfg
       }

       // ... rest of existing code ...
   }
   ```

This allows main.go to create handler without config, with config loaded on first request (supports Lambda cold start optimization).
  </action>
  <verify>
  - `gofmt -e lambda/handler.go` shows no syntax errors
  - NewHandler accepts optional config
  - HandleRequest lazy-loads config
  </verify>
  <done>
  - Handler supports lazy config initialization
  - Config loaded from environment on first request if not provided
  - Backward compatible with explicit config
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Lambda entry point with Router</name>
  <files>cmd/lambda-tvm/main.go</files>
  <action>
Update `cmd/lambda-tvm/main.go` to use Router:

```go
// Package main is the entry point for the Lambda TVM.
package main

import (
    "context"
    "log"

    "github.com/aws/aws-lambda-go/events"
    "github.com/aws/aws-lambda-go/lambda"
    "github.com/aws/aws-sdk-go-v2/config"
    "github.com/aws/aws-sdk-go-v2/service/ssm"
    tvmhandler "github.com/byteness/aws-vault/v7/lambda"
)

// Version is set at build time via ldflags
var Version = "dev"

// Global router (initialized lazily)
var router *tvmhandler.Router

func main() {
    lambda.Start(handleRequest)
}

// handleRequest routes API Gateway requests to appropriate handlers.
// Router is initialized lazily on first request for cold start optimization.
func handleRequest(ctx context.Context, req events.APIGatewayV2HTTPRequest) (events.APIGatewayV2HTTPResponse, error) {
    // Lazy-initialize router on first request
    if router == nil {
        var err error
        router, err = initRouter(ctx)
        if err != nil {
            log.Printf("ERROR: Failed to initialize router: %v", err)
            return tvmhandler.ErrorResponse(500, "INIT_ERROR", "Failed to initialize handler")
        }
    }

    return router.Route(ctx, req)
}

// initRouter creates the Router with handler and profile discovery.
func initRouter(ctx context.Context) (*tvmhandler.Router, error) {
    // Load config from environment
    cfg, err := tvmhandler.LoadConfigFromEnv(ctx)
    if err != nil {
        return nil, err
    }

    // Create credential handler
    handler := tvmhandler.NewHandler(cfg)

    // Create profile discovery if policy root is configured
    var profiler *tvmhandler.ProfileDiscovery
    if cfg.PolicyRoot != "" {
        awsCfg, err := config.LoadDefaultConfig(ctx)
        if err != nil {
            log.Printf("Warning: failed to create SSM client for profile discovery: %v", err)
        } else {
            ssmClient := ssm.NewFromConfig(awsCfg)
            profiler = tvmhandler.NewProfileDiscovery(ssmClient, cfg.PolicyRoot)
        }
    }

    return tvmhandler.NewRouter(handler, profiler), nil
}
```

Also add an exported ErrorResponse function to handler.go for use by main:
```go
// ErrorResponse creates an error response (exported for main.go).
// This is a convenience wrapper around errorResponse.
func ErrorResponse(statusCode int, code, message string) (events.APIGatewayV2HTTPResponse, error) {
    return errorResponse(statusCode, code, message)
}
```
  </action>
  <verify>
  - `gofmt -e cmd/lambda-tvm/main.go` shows no syntax errors
  - `go build ./cmd/lambda-tvm/...` succeeds
  </verify>
  <done>
  - Lambda entry point uses Router
  - Lazy initialization for cold start optimization
  - Profile discovery enabled when PolicyRoot is configured
  - Credential vending and profile discovery both work via single Lambda
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `gofmt -e lambda/*.go cmd/lambda-tvm/main.go` shows no syntax errors
- [ ] `go build ./cmd/lambda-tvm/...` succeeds
- [ ] `go test ./lambda/... -v` passes all tests
</verification>

<success_criteria>

- Lambda entry point routes to correct handlers
- Profile discovery uses SSM GetParametersByPath
- PolicyRoot derived from PolicyParameter when not set
- Config loaded lazily for cold start optimization
</success_criteria>

<output>
After completion, create `.planning/phases/100-api-gateway/100-02-SUMMARY.md`
</output>
