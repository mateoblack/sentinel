---
phase: 100-api-gateway
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [lambda/routes.go, lambda/routes_test.go, lambda/profiles.go, lambda/profiles_test.go]
autonomous: true
---

<objective>
Add routing support and profile discovery endpoint to Lambda TVM.

Purpose: Enable multi-path API Gateway deployment with credential vending at root and profile discovery at /profiles.
Output: Router infrastructure and profile discovery endpoint matching shell/shell.go pattern.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/99-policy-session-integration/99-04-SUMMARY.md

Lambda handler files:
@lambda/handler.go
@lambda/config.go
@lambda/types.go

Shell profile discovery pattern to follow:
@shell/shell.go (lines 59-96 for GetProfiles)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create routing infrastructure</name>
  <files>lambda/routes.go</files>
  <action>
Create `lambda/routes.go` with a Router type that dispatches to different handlers based on path:

```go
package lambda

import (
    "context"
    "net/http"
    "strings"

    "github.com/aws/aws-lambda-go/events"
)

// Router dispatches API Gateway requests to appropriate handlers based on path.
// Supports:
//   - GET /           -> credential vending (profile query param required)
//   - POST /          -> credential vending (profile query param required)
//   - GET /profiles   -> profile discovery
type Router struct {
    handler  *Handler
    profiler *ProfileDiscovery
}

// NewRouter creates a new Router with the given handler and profiler.
func NewRouter(handler *Handler, profiler *ProfileDiscovery) *Router {
    return &Router{
        handler:  handler,
        profiler: profiler,
    }
}

// Route handles an API Gateway v2 HTTP request and routes to appropriate handler.
func (r *Router) Route(ctx context.Context, req events.APIGatewayV2HTTPRequest) (events.APIGatewayV2HTTPResponse, error) {
    // Normalize path (remove trailing slash)
    path := strings.TrimSuffix(req.RawPath, "/")
    if path == "" {
        path = "/"
    }

    // Route based on path
    switch path {
    case "/", "":
        // Credential vending endpoint
        return r.handler.HandleRequest(ctx, req)
    case "/profiles":
        // Profile discovery endpoint
        if r.profiler == nil {
            return errorResponse(http.StatusNotImplemented, "NOT_IMPLEMENTED",
                "Profile discovery is not configured")
        }
        return r.profiler.HandleRequest(ctx, req)
    default:
        return errorResponse(http.StatusNotFound, "NOT_FOUND",
            "Unknown path: "+path)
    }
}
```

The Router pattern allows API Gateway to use a single Lambda for multiple paths, reducing cold starts and simplifying deployment.
  </action>
  <verify>
  - `gofmt -e lambda/routes.go` shows no syntax errors
  - Router type has NewRouter, Route methods
  </verify>
  <done>
  - Router dispatches / to credential handler
  - Router dispatches /profiles to profile discovery
  - Unknown paths return 404
  </done>
</task>

<task type="auto">
  <name>Task 2: Create profile discovery handler</name>
  <files>lambda/profiles.go</files>
  <action>
Create `lambda/profiles.go` with profile discovery using SSM GetParametersByPath (following shell/shell.go pattern):

```go
package lambda

import (
    "context"
    "encoding/json"
    "net/http"
    "strings"

    "github.com/aws/aws-lambda-go/events"
    "github.com/aws/aws-sdk-go-v2/aws"
    "github.com/aws/aws-sdk-go-v2/service/ssm"
)

// ProfileInfo holds information about a discoverable Sentinel profile.
type ProfileInfo struct {
    Name       string `json:"name"`        // Profile name (e.g., "production")
    PolicyPath string `json:"policy_path"` // Full SSM path (e.g., "/sentinel/policies/production")
}

// ProfileDiscoveryResponse is the response format for /profiles endpoint.
type ProfileDiscoveryResponse struct {
    Profiles []ProfileInfo `json:"profiles"`
    Root     string        `json:"root"` // Policy root path used for discovery
}

// ssmAPI defines the SSM operations used by ProfileDiscovery.
// This interface enables testing with mock implementations.
type ssmAPI interface {
    GetParametersByPath(ctx context.Context, params *ssm.GetParametersByPathInput, optFns ...func(*ssm.Options)) (*ssm.GetParametersByPathOutput, error)
}

// ProfileDiscovery handles the /profiles endpoint for discovering available Sentinel profiles.
type ProfileDiscovery struct {
    ssm        ssmAPI
    policyRoot string // SSM path root for policies (e.g., "/sentinel/policies")
}

// NewProfileDiscovery creates a new ProfileDiscovery with the given SSM client and policy root.
func NewProfileDiscovery(client ssmAPI, policyRoot string) *ProfileDiscovery {
    return &ProfileDiscovery{
        ssm:        client,
        policyRoot: policyRoot,
    }
}

// HandleRequest handles a profile discovery request.
// Returns a list of available profiles from SSM.
func (p *ProfileDiscovery) HandleRequest(ctx context.Context, req events.APIGatewayV2HTTPRequest) (events.APIGatewayV2HTTPResponse, error) {
    // Only GET method allowed
    if req.RequestContext.HTTP.Method != "GET" {
        return errorResponse(http.StatusMethodNotAllowed, "METHOD_NOT_ALLOWED",
            "Only GET method is allowed for /profiles")
    }

    // Discover profiles from SSM
    profiles, err := p.discoverProfiles(ctx)
    if err != nil {
        return errorResponse(http.StatusInternalServerError, "SSM_ERROR",
            "Failed to discover profiles: "+err.Error())
    }

    // Build response
    resp := &ProfileDiscoveryResponse{
        Profiles: profiles,
        Root:     p.policyRoot,
    }

    body, err := json.Marshal(resp)
    if err != nil {
        return errorResponse(http.StatusInternalServerError, "MARSHAL_ERROR",
            "Failed to marshal response")
    }

    return events.APIGatewayV2HTTPResponse{
        StatusCode: http.StatusOK,
        Headers: map[string]string{
            "Content-Type": "application/json; charset=utf-8",
        },
        Body: string(body),
    }, nil
}

// discoverProfiles queries SSM for all policy parameters under the root path.
// This is similar to shell.ShellGenerator.GetProfiles but returns simplified info.
func (p *ProfileDiscovery) discoverProfiles(ctx context.Context) ([]ProfileInfo, error) {
    var profiles []ProfileInfo
    var nextToken *string

    for {
        input := &ssm.GetParametersByPathInput{
            Path:      aws.String(p.policyRoot),
            Recursive: aws.Bool(false), // Only direct children (profiles are at top level)
            NextToken: nextToken,
        }

        output, err := p.ssm.GetParametersByPath(ctx, input)
        if err != nil {
            return nil, err
        }

        // Process parameters from this page
        for _, param := range output.Parameters {
            path := aws.ToString(param.Name)
            name := extractProfileName(p.policyRoot, path)

            profiles = append(profiles, ProfileInfo{
                Name:       name,
                PolicyPath: path,
            })
        }

        // Check for more pages
        if output.NextToken == nil {
            break
        }
        nextToken = output.NextToken
    }

    return profiles, nil
}

// extractProfileName extracts the profile name from a full parameter path.
// For example, "/sentinel/policies/production" -> "production".
func extractProfileName(policyRoot, paramPath string) string {
    // Remove trailing slash from policyRoot if present
    policyRoot = strings.TrimSuffix(policyRoot, "/")

    // Remove the policy root prefix and leading slash
    name := strings.TrimPrefix(paramPath, policyRoot)
    name = strings.TrimPrefix(name, "/")

    return name
}
```

The profile discovery follows the same pattern as shell/shell.go's GetProfiles, enabling clients to discover which profiles are available for credential vending.
  </action>
  <verify>
  - `gofmt -e lambda/profiles.go` shows no syntax errors
  - ProfileDiscovery type has NewProfileDiscovery, HandleRequest, discoverProfiles
  </verify>
  <done>
  - ProfileInfo struct with JSON tags
  - ProfileDiscoveryResponse with profiles array and root
  - SSM-based profile discovery via GetParametersByPath
  - Pagination support for large profile sets
  </done>
</task>

<task type="auto">
  <name>Task 3: Add router and profile tests</name>
  <files>lambda/routes_test.go, lambda/profiles_test.go</files>
  <action>
Create `lambda/routes_test.go`:

```go
package lambda

import (
    "context"
    "net/http"
    "testing"

    "github.com/aws/aws-lambda-go/events"
)

func TestRouter_Route_RootPath(t *testing.T) {
    // Create mock handler that returns success
    handler := &Handler{Config: &TVMConfig{}}
    router := NewRouter(handler, nil)

    tests := []struct {
        name string
        path string
    }{
        {"root with slash", "/"},
        {"root empty", ""},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            req := events.APIGatewayV2HTTPRequest{
                RawPath: tt.path,
            }
            // Handler will fail due to missing config, but route is correct
            resp, _ := router.Route(context.Background(), req)
            // Verify it didn't return 404 (route was found)
            if resp.StatusCode == http.StatusNotFound {
                t.Errorf("expected route to be found for path %q", tt.path)
            }
        })
    }
}

func TestRouter_Route_ProfilesPath(t *testing.T) {
    handler := &Handler{Config: &TVMConfig{}}

    // Without profiler
    router := NewRouter(handler, nil)
    req := events.APIGatewayV2HTTPRequest{
        RawPath: "/profiles",
    }
    resp, _ := router.Route(context.Background(), req)
    if resp.StatusCode != http.StatusNotImplemented {
        t.Errorf("expected 501 when profiler is nil, got %d", resp.StatusCode)
    }
}

func TestRouter_Route_UnknownPath(t *testing.T) {
    handler := &Handler{Config: &TVMConfig{}}
    router := NewRouter(handler, nil)

    req := events.APIGatewayV2HTTPRequest{
        RawPath: "/unknown",
    }
    resp, _ := router.Route(context.Background(), req)
    if resp.StatusCode != http.StatusNotFound {
        t.Errorf("expected 404 for unknown path, got %d", resp.StatusCode)
    }
}
```

Create `lambda/profiles_test.go`:

```go
package lambda

import (
    "context"
    "encoding/json"
    "net/http"
    "testing"

    "github.com/aws/aws-lambda-go/events"
    "github.com/aws/aws-sdk-go-v2/aws"
    "github.com/aws/aws-sdk-go-v2/service/ssm"
    "github.com/aws/aws-sdk-go-v2/service/ssm/types"
)

// mockSSMClient implements ssmAPI for testing.
type mockSSMClient struct {
    params []types.Parameter
    err    error
}

func (m *mockSSMClient) GetParametersByPath(ctx context.Context, input *ssm.GetParametersByPathInput, optFns ...func(*ssm.Options)) (*ssm.GetParametersByPathOutput, error) {
    if m.err != nil {
        return nil, m.err
    }
    return &ssm.GetParametersByPathOutput{
        Parameters: m.params,
    }, nil
}

func TestProfileDiscovery_HandleRequest_Success(t *testing.T) {
    client := &mockSSMClient{
        params: []types.Parameter{
            {Name: aws.String("/sentinel/policies/dev")},
            {Name: aws.String("/sentinel/policies/production")},
        },
    }

    profiler := NewProfileDiscovery(client, "/sentinel/policies")

    req := events.APIGatewayV2HTTPRequest{
        RequestContext: events.APIGatewayV2HTTPRequestContext{
            HTTP: events.APIGatewayV2HTTPRequestContextHTTPDescription{
                Method: "GET",
            },
        },
    }

    resp, err := profiler.HandleRequest(context.Background(), req)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    if resp.StatusCode != http.StatusOK {
        t.Errorf("expected 200, got %d", resp.StatusCode)
    }

    var result ProfileDiscoveryResponse
    if err := json.Unmarshal([]byte(resp.Body), &result); err != nil {
        t.Fatalf("failed to unmarshal response: %v", err)
    }

    if len(result.Profiles) != 2 {
        t.Errorf("expected 2 profiles, got %d", len(result.Profiles))
    }

    if result.Profiles[0].Name != "dev" {
        t.Errorf("expected first profile 'dev', got %s", result.Profiles[0].Name)
    }
}

func TestProfileDiscovery_HandleRequest_MethodNotAllowed(t *testing.T) {
    client := &mockSSMClient{}
    profiler := NewProfileDiscovery(client, "/sentinel/policies")

    req := events.APIGatewayV2HTTPRequest{
        RequestContext: events.APIGatewayV2HTTPRequestContext{
            HTTP: events.APIGatewayV2HTTPRequestContextHTTPDescription{
                Method: "POST",
            },
        },
    }

    resp, _ := profiler.HandleRequest(context.Background(), req)
    if resp.StatusCode != http.StatusMethodNotAllowed {
        t.Errorf("expected 405, got %d", resp.StatusCode)
    }
}

func TestExtractProfileName(t *testing.T) {
    tests := []struct {
        root     string
        path     string
        expected string
    }{
        {"/sentinel/policies", "/sentinel/policies/dev", "dev"},
        {"/sentinel/policies/", "/sentinel/policies/production", "production"},
        {"/custom/path", "/custom/path/test-profile", "test-profile"},
    }

    for _, tt := range tests {
        result := extractProfileName(tt.root, tt.path)
        if result != tt.expected {
            t.Errorf("extractProfileName(%q, %q) = %q, want %q",
                tt.root, tt.path, result, tt.expected)
        }
    }
}
```
  </action>
  <verify>
  - `gofmt -e lambda/routes_test.go lambda/profiles_test.go` shows no syntax errors
  - `go test ./lambda/... -run "Router|Profile" -v` passes
  </verify>
  <done>
  - Router tests for /, /profiles, and unknown paths
  - ProfileDiscovery tests with mock SSM client
  - extractProfileName unit tests
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `gofmt -e lambda/*.go` shows no syntax errors
- [ ] `go build ./lambda/...` succeeds
- [ ] `go test ./lambda/... -v` passes all tests
</verification>

<success_criteria>

- Router dispatches requests to appropriate handlers based on path
- Profile discovery returns available profiles from SSM
- Tests cover routing and profile discovery scenarios
- Ready for Phase 100-02 config integration
</success_criteria>

<output>
After completion, create `.planning/phases/100-api-gateway/100-01-SUMMARY.md`
</output>
