---
phase: 100-api-gateway
plan: 03
type: execute
wave: 2
depends_on: ["100-01"]
files_modified: [lambda/authorizer.go, lambda/authorizer_test.go]
autonomous: true
---

<objective>
Create Lambda authorizer for session revocation on sensitive APIs.

Purpose: Enable downstream APIs to verify Sentinel session validity before processing requests, supporting instant revocation.
Output: Lambda authorizer code that extracts session ID from credentials and validates against DynamoDB.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Session revocation pattern from server mode:
@sentinel/server.go (lines 276-287 for revocation check)
@session/store.go
@session/types.go

Lambda session integration:
@lambda/session.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Lambda authorizer handler</name>
  <files>lambda/authorizer.go</files>
  <action>
Create `lambda/authorizer.go` with a Lambda authorizer for session validation:

```go
// Package lambda provides the Lambda handler for the Token Vending Machine (TVM).
package lambda

import (
    "context"
    "errors"
    "fmt"
    "log"
    "os"
    "strings"

    "github.com/aws/aws-lambda-go/events"
    "github.com/aws/aws-sdk-go-v2/config"
    "github.com/byteness/aws-vault/v7/session"
)

// Authorizer environment variables.
const (
    // EnvAuthorizerSessionTable is the DynamoDB table name for session lookup.
    EnvAuthorizerSessionTable = "SENTINEL_SESSION_TABLE"
)

// AuthorizerErrors returned by the Lambda authorizer.
var (
    ErrMissingSessionID   = errors.New("missing SentinelSessionID in request")
    ErrSessionRevoked     = errors.New("session has been revoked")
    ErrSessionNotFound    = errors.New("session not found")
    ErrSessionTableNotSet = errors.New("SENTINEL_SESSION_TABLE not configured")
)

// Authorizer handles Lambda authorizer requests for session validation.
// This enables sensitive downstream APIs to validate Sentinel session status
// before processing requests, supporting instant revocation.
//
// Usage pattern:
//  1. TVM vends credentials with SentinelSessionID session tag
//  2. Downstream API uses Lambda authorizer to validate session
//  3. If session is revoked, authorizer returns deny
//  4. Revocation propagates instantly (no credential expiry wait)
type Authorizer struct {
    store     session.Store
    tableName string
}

// NewAuthorizer creates a new Authorizer with the given session store.
func NewAuthorizer(store session.Store, tableName string) *Authorizer {
    return &Authorizer{
        store:     store,
        tableName: tableName,
    }
}

// NewAuthorizerFromEnv creates an Authorizer using environment variables.
// Returns error if SENTINEL_SESSION_TABLE is not set.
func NewAuthorizerFromEnv(ctx context.Context) (*Authorizer, error) {
    tableName := os.Getenv(EnvAuthorizerSessionTable)
    if tableName == "" {
        return nil, ErrSessionTableNotSet
    }

    // Load AWS config
    awsCfg, err := config.LoadDefaultConfig(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to load AWS config: %w", err)
    }

    // Create DynamoDB session store
    store := session.NewDynamoDBStore(awsCfg, tableName)

    return &Authorizer{
        store:     store,
        tableName: tableName,
    }, nil
}

// HandleRequest processes a Lambda authorizer request.
// Extracts SentinelSessionID from the request and validates against DynamoDB.
//
// The authorizer looks for session ID in this order:
//  1. Request headers: X-Sentinel-Session-ID
//  2. Query string parameter: sentinel_session_id
//  3. STS session tag: extracted from caller ARN (if available)
//
// Returns IAM policy allowing or denying the request.
func (a *Authorizer) HandleRequest(ctx context.Context, req events.APIGatewayV2CustomAuthorizerV2Request) (events.APIGatewayV2CustomAuthorizerSimpleResponse, error) {
    // Extract session ID from request
    sessionID := a.extractSessionID(req)
    if sessionID == "" {
        log.Printf("DENY: No SentinelSessionID found in request")
        return denyResponse(), nil
    }

    // Check session revocation
    revoked, err := session.IsSessionRevoked(ctx, a.store, sessionID)
    if err != nil {
        // Fail-closed: errors result in deny for security
        log.Printf("DENY: Failed to check session %s: %v", sessionID, err)
        return denyResponse(), nil
    }

    if revoked {
        log.Printf("DENY: Session %s is revoked", sessionID)
        return denyResponse(), nil
    }

    log.Printf("ALLOW: Session %s is valid", sessionID)
    return allowResponse(), nil
}

// extractSessionID extracts the Sentinel session ID from the request.
// Checks headers first, then query parameters.
func (a *Authorizer) extractSessionID(req events.APIGatewayV2CustomAuthorizerV2Request) string {
    // Check headers (case-insensitive)
    for key, value := range req.Headers {
        if strings.EqualFold(key, "X-Sentinel-Session-ID") {
            return value
        }
    }

    // Check query parameters
    if sessionID, ok := req.QueryStringParameters["sentinel_session_id"]; ok {
        return sessionID
    }

    // Session ID not found in request
    return ""
}

// allowResponse creates an allow response.
func allowResponse() events.APIGatewayV2CustomAuthorizerSimpleResponse {
    return events.APIGatewayV2CustomAuthorizerSimpleResponse{
        IsAuthorized: true,
    }
}

// denyResponse creates a deny response.
func denyResponse() events.APIGatewayV2CustomAuthorizerSimpleResponse {
    return events.APIGatewayV2CustomAuthorizerSimpleResponse{
        IsAuthorized: false,
    }
}

// ValidateSession is a convenience function for validating a session ID.
// Returns nil if session is valid, error otherwise.
func (a *Authorizer) ValidateSession(ctx context.Context, sessionID string) error {
    if sessionID == "" {
        return ErrMissingSessionID
    }

    revoked, err := session.IsSessionRevoked(ctx, a.store, sessionID)
    if err != nil {
        if errors.Is(err, session.ErrSessionNotFound) {
            return ErrSessionNotFound
        }
        return fmt.Errorf("failed to check session: %w", err)
    }

    if revoked {
        return ErrSessionRevoked
    }

    return nil
}
```

The authorizer enables the instant revocation pattern described in APIGW-05:
- Downstream APIs deploy this Lambda authorizer
- Authorizer validates SentinelSessionID against DynamoDB
- Revoked sessions are immediately rejected
- No waiting for credential expiry
  </action>
  <verify>
  - `gofmt -e lambda/authorizer.go` shows no syntax errors
  - Authorizer type has HandleRequest, ValidateSession methods
  </verify>
  <done>
  - Lambda authorizer for session validation
  - Session ID extraction from headers and query params
  - Fail-closed security (errors = deny)
  - ValidateSession convenience function
  </done>
</task>

<task type="auto">
  <name>Task 2: Add authorizer tests</name>
  <files>lambda/authorizer_test.go</files>
  <action>
Create `lambda/authorizer_test.go`:

```go
package lambda

import (
    "context"
    "errors"
    "testing"

    "github.com/aws/aws-lambda-go/events"
    "github.com/byteness/aws-vault/v7/session"
)

func TestAuthorizer_HandleRequest_ValidSession(t *testing.T) {
    store := newMockSessionStore()
    store.sessions["test-session-id"] = &session.ServerSession{
        ID:     "test-session-id",
        Status: session.StatusActive,
    }

    auth := NewAuthorizer(store, "test-table")

    req := events.APIGatewayV2CustomAuthorizerV2Request{
        Headers: map[string]string{
            "X-Sentinel-Session-ID": "test-session-id",
        },
    }

    resp, err := auth.HandleRequest(context.Background(), req)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    if !resp.IsAuthorized {
        t.Error("expected authorized response for valid session")
    }
}

func TestAuthorizer_HandleRequest_RevokedSession(t *testing.T) {
    store := newMockSessionStore()
    store.sessions["revoked-session"] = &session.ServerSession{
        ID:     "revoked-session",
        Status: session.StatusRevoked,
    }

    auth := NewAuthorizer(store, "test-table")

    req := events.APIGatewayV2CustomAuthorizerV2Request{
        Headers: map[string]string{
            "X-Sentinel-Session-ID": "revoked-session",
        },
    }

    resp, err := auth.HandleRequest(context.Background(), req)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    if resp.IsAuthorized {
        t.Error("expected denied response for revoked session")
    }
}

func TestAuthorizer_HandleRequest_MissingSessionID(t *testing.T) {
    store := newMockSessionStore()
    auth := NewAuthorizer(store, "test-table")

    req := events.APIGatewayV2CustomAuthorizerV2Request{
        Headers: map[string]string{},
    }

    resp, err := auth.HandleRequest(context.Background(), req)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    if resp.IsAuthorized {
        t.Error("expected denied response when session ID is missing")
    }
}

func TestAuthorizer_HandleRequest_QueryParam(t *testing.T) {
    store := newMockSessionStore()
    store.sessions["query-session"] = &session.ServerSession{
        ID:     "query-session",
        Status: session.StatusActive,
    }

    auth := NewAuthorizer(store, "test-table")

    req := events.APIGatewayV2CustomAuthorizerV2Request{
        QueryStringParameters: map[string]string{
            "sentinel_session_id": "query-session",
        },
    }

    resp, err := auth.HandleRequest(context.Background(), req)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    if !resp.IsAuthorized {
        t.Error("expected authorized response for session ID in query param")
    }
}

func TestAuthorizer_HandleRequest_StoreError(t *testing.T) {
    store := newMockSessionStore()
    store.getErr = errors.New("DynamoDB error")

    auth := NewAuthorizer(store, "test-table")

    req := events.APIGatewayV2CustomAuthorizerV2Request{
        Headers: map[string]string{
            "X-Sentinel-Session-ID": "any-session",
        },
    }

    resp, err := auth.HandleRequest(context.Background(), req)
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }

    // Fail-closed: errors result in deny
    if resp.IsAuthorized {
        t.Error("expected denied response on store error (fail-closed)")
    }
}

func TestAuthorizer_ValidateSession(t *testing.T) {
    store := newMockSessionStore()
    store.sessions["valid-session"] = &session.ServerSession{
        ID:     "valid-session",
        Status: session.StatusActive,
    }
    store.sessions["revoked-session"] = &session.ServerSession{
        ID:     "revoked-session",
        Status: session.StatusRevoked,
    }

    auth := NewAuthorizer(store, "test-table")

    tests := []struct {
        name      string
        sessionID string
        wantErr   error
    }{
        {"empty session ID", "", ErrMissingSessionID},
        {"valid session", "valid-session", nil},
        {"revoked session", "revoked-session", ErrSessionRevoked},
        {"not found", "unknown", ErrSessionNotFound},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := auth.ValidateSession(context.Background(), tt.sessionID)
            if tt.wantErr != nil {
                if !errors.Is(err, tt.wantErr) {
                    t.Errorf("ValidateSession(%q) = %v, want %v", tt.sessionID, err, tt.wantErr)
                }
            } else if err != nil {
                t.Errorf("ValidateSession(%q) = %v, want nil", tt.sessionID, err)
            }
        })
    }
}

func TestExtractSessionID_HeaderCaseInsensitive(t *testing.T) {
    store := newMockSessionStore()
    auth := NewAuthorizer(store, "test-table")

    tests := []struct {
        headerKey string
        expected  string
    }{
        {"X-Sentinel-Session-ID", "test-id"},
        {"x-sentinel-session-id", "test-id"},
        {"X-SENTINEL-SESSION-ID", "test-id"},
    }

    for _, tt := range tests {
        req := events.APIGatewayV2CustomAuthorizerV2Request{
            Headers: map[string]string{
                tt.headerKey: "test-id",
            },
        }
        result := auth.extractSessionID(req)
        if result != tt.expected {
            t.Errorf("extractSessionID with header %q = %q, want %q",
                tt.headerKey, result, tt.expected)
        }
    }
}
```
  </action>
  <verify>
  - `gofmt -e lambda/authorizer_test.go` shows no syntax errors
  - `go test ./lambda/... -run Authorizer -v` passes
  </verify>
  <done>
  - Tests for valid/revoked/missing sessions
  - Query parameter extraction test
  - Fail-closed behavior on store error
  - ValidateSession function tests
  - Case-insensitive header extraction
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `gofmt -e lambda/authorizer*.go` shows no syntax errors
- [ ] `go build ./lambda/...` succeeds
- [ ] `go test ./lambda/... -run Authorizer -v` passes all tests
</verification>

<success_criteria>

- Lambda authorizer validates session ID against DynamoDB
- Session ID extracted from headers or query params
- Fail-closed security (errors = deny)
- Tests cover all validation scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/100-api-gateway/100-03-SUMMARY.md`
</output>
