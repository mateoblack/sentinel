---
phase: 143-policy-linting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [policy/lint.go, policy/lint_test.go, cli/policy.go, cli/policy_test.go]
autonomous: true
---

<objective>
Implement policy linter with three lint checks integrated into existing `sentinel policy validate` command.

Purpose: Help users catch common policy mistakes (allow-before-deny conflicts, unreachable rules, overlapping time windows) before deployment.
Output: New lint.go package with LintPolicy function, updated policy validate command with lint warnings.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/143-policy-linting/143-CONTEXT.md

# Prior phase for policy validate command
@.planning/phases/125-policy-validate-command/125-01-SUMMARY.md

# Current implementation
@policy/types.go
@policy/validate.go
@cli/policy.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement LintPolicy function with three checks</name>
  <files>policy/lint.go</files>
  <action>
Create new lint.go file in policy package with:

1. **LintIssue type** with fields:
   - Type string (one of: "allow-before-deny", "unreachable-rule", "overlapping-time-windows")
   - RuleIndex int (0-indexed position of problematic rule)
   - RuleName string
   - Message string (compiler-style terse description)

2. **LintPolicy(p *Policy) []LintIssue** function that runs all three checks:

3. **Allow-before-deny check** (`checkAllowBeforeDeny`):
   - For each rule with effect "allow", scan SUBSEQUENT rules for "deny" with SAME profile(s)
   - Empty profiles list = wildcard (matches all profiles), so empty deny after specific allow is fine
   - But specific allow followed by same-profile deny is a conflict
   - Example conflict: allow on profile=["prod"] followed by deny on profile=["prod"]
   - Message format: "allow rule 'X' at index N precedes deny rule 'Y' for same profiles"

4. **Unreachable rules check** (`checkUnreachableRules`):
   - A rule is unreachable if a previous rule has LESS RESTRICTIVE or EQUAL conditions
   - Less restrictive = empty list (wildcard) beats specific list
   - Check: if earlier rule has empty users/profiles/time AND same effect, later rules with those conditions won't match
   - Note: Different effects make rules reachable (deny-all followed by allow-specific is fine)
   - Message format: "rule 'X' at index N is unreachable (shadowed by rule 'Y' at index M)"

5. **Overlapping time windows check** (`checkOverlappingTimeWindows`):
   - For rules with SAME profiles AND DIFFERENT effects, check if time windows overlap
   - Time window overlap = same days AND overlapping hour ranges
   - Hour range overlap: max(start1, start2) < min(end1, end2)
   - Only flag when effects differ (creates ambiguous behavior)
   - Message format: "rules 'X' and 'Y' have overlapping time windows with different effects"

Implementation notes:
- Keep checks simple and fast (iterate through rules once per check)
- Return empty slice if no issues found
- Each check is a separate unexported function called by LintPolicy
- Use helper `profilesOverlap(a, b []string) bool` where empty list overlaps with anything
  </action>
  <verify>go build ./policy compiles successfully</verify>
  <done>LintPolicy function exists with all three checks implemented</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive lint tests</name>
  <files>policy/lint_test.go</files>
  <action>
Create lint_test.go with tests for each lint check:

1. **TestLintPolicy_AllowBeforeDeny**:
   - Case: allow profile=["prod"] followed by deny profile=["prod"] → issue detected
   - Case: allow profile=["prod"] followed by deny profile=["staging"] → no issue
   - Case: deny before allow for same profile → no issue (correct order)
   - Case: allow on empty profiles followed by deny on specific → no issue

2. **TestLintPolicy_UnreachableRules**:
   - Case: allow users=[] profiles=[] followed by allow users=["bob"] → unreachable
   - Case: deny profiles=[] followed by deny profiles=["prod"] → unreachable
   - Case: allow profiles=[] followed by deny profiles=[] → reachable (different effects)
   - Case: allow profiles=["prod"] followed by allow profiles=["staging"] → reachable (different profiles)

3. **TestLintPolicy_OverlappingTimeWindows**:
   - Case: allow 09:00-17:00 Mon-Fri followed by deny 12:00-18:00 Mon-Fri → overlap detected
   - Case: allow 09:00-12:00 followed by deny 13:00-17:00 → no overlap
   - Case: allow Mon-Tue followed by deny Wed-Thu → no overlap
   - Case: same time windows but same effect → no issue (not ambiguous)

4. **TestLintPolicy_NoIssues**:
   - Well-formed policy with deny-first pattern returns empty slice

5. **TestLintPolicy_MultipleIssues**:
   - Policy with all three types of issues returns all of them

Use table-driven tests where appropriate. Each test should create a Policy struct directly (no YAML parsing needed).
  </action>
  <verify>go test ./policy -run TestLintPolicy -v passes</verify>
  <done>All lint check scenarios covered with passing tests</done>
</task>

<task type="auto">
  <name>Task 3: Integrate linting into policy validate command</name>
  <files>cli/policy.go</files>
  <action>
Modify PolicyValidateCommand in cli/policy.go to:

1. After schema validation passes, call `policy.LintPolicy(p)` on the parsed policy
2. If lint issues found, output them in compiler-style format to stderr:
   ```
   lint: allow-before-deny: rule 'allow-prod' at index 1 precedes deny rule 'deny-all' for same profiles
   lint: unreachable-rule: rule 'backup-allow' at index 3 is unreachable (shadowed by rule 'allow-all' at index 0)
   ```
3. Format: `lint: {type}: {message}` - one line per issue
4. Lint warnings do NOT change exit code (exit 0 if schema valid, regardless of lint issues)
5. If --quiet flag is set, suppress lint output too (only show errors)
6. After all validation and linting, if valid without lint issues: "Policy is valid"
7. If valid WITH lint issues: no success message (the lint warnings are the output)

The key insight from CONTEXT.md: linting is integrated into existing validate command, not separate.
  </action>
  <verify>go build ./cli compiles successfully</verify>
  <done>sentinel policy validate shows lint warnings when issues detected</done>
</task>

<task type="auto">
  <name>Task 4: Add CLI integration tests for lint output</name>
  <files>cli/policy_test.go</files>
  <action>
Add tests to cli/policy_test.go for lint integration:

1. **TestPolicyValidateCommand_LintWarnings**:
   - Valid policy with lint issues → exit 0, lint warnings on stderr
   - Valid policy without lint issues → exit 0, "Policy is valid" message
   - Invalid policy → exit 1, no lint output (fails before linting)

2. **TestPolicyValidateCommand_LintQuiet**:
   - Valid policy with lint issues + --quiet → exit 0, no output

3. **TestPolicyValidateCommand_LintOutput_Format**:
   - Verify exact output format: `lint: {type}: {message}`

Create test YAML files inline using string constants (no test fixtures needed).
  </action>
  <verify>go test ./cli -run TestPolicyValidateCommand_Lint -v passes</verify>
  <done>CLI lint integration fully tested</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./policy -run TestLintPolicy -v` passes all lint tests
- [ ] `go test ./cli -run TestPolicyValidateCommand -v` passes all CLI tests
- [ ] Lint output format is compiler-style: `lint: {type}: {message}`
</verification>

<success_criteria>

- LintPolicy function detects all three issue types
- Integration into policy validate command complete
- Lint warnings shown but don't affect exit code
- All tests pass
- Compiler-style terse output format
</success_criteria>

<output>
After completion, create `.planning/phases/143-policy-linting/143-01-SUMMARY.md`
</output>
