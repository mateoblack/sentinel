---
phase: 53-approval-workflow-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - request/state_security_test.go
autonomous: true
---

<objective>
Add security-focused tests for the approval request state machine.

Purpose: Ensure terminal state immutability, validate state transition boundaries, and verify concurrent state change handling.
Output: Comprehensive state machine security test suite in request/state_security_test.go
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@request/types.go
@request/validate.go
@request/validate_test.go
@testutil/mock_stores.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Terminal state immutability security tests</name>
  <files>request/state_security_test.go</files>
  <action>
Create request/state_security_test.go with security-focused tests:

1. **Terminal state immutability exhaustive test:**
   - For each terminal status (approved, denied, expired, cancelled):
     - Verify CanTransitionTo returns false for ALL possible target statuses
     - Include invalid/malformed status strings
   - Table-driven exhaustive test ensures no bypass paths

2. **Status enum exhaustive coverage:**
   - Test all 5 status values: pending, approved, denied, expired, cancelled
   - Verify IsValid() correctly identifies valid vs invalid statuses
   - Test empty string, whitespace, case variations (e.g., "APPROVED", "Pending")
   - Test SQL/NoSQL injection patterns in status strings: "'; DROP TABLE", "$ne: null"

3. **State transition boundary tests:**
   - Verify exactly 4 valid transitions exist (pending -> each terminal)
   - Verify pending -> pending is rejected
   - Verify all terminal -> * are rejected (4 x 5 = 20 tests)
   - Use t.Run for clear subtest names

Follow existing test patterns in validate_test.go. Use table-driven tests with descriptive names.
  </action>
  <verify>go test -v ./request/... -run Security | grep -E "^(---|PASS|FAIL)"</verify>
  <done>All terminal state immutability tests pass, no bypass paths exist</done>
</task>

<task type="auto">
  <name>Task 2: Concurrent state transition security tests</name>
  <files>request/state_security_test.go</files>
  <action>
Add concurrent state transition tests to request/state_security_test.go:

1. **Race condition detection test:**
   - Create a request in pending state
   - Launch multiple goroutines (10) attempting simultaneous transitions to different terminal states
   - Use sync.WaitGroup and countdown latch pattern for synchronized start
   - Verify exactly one transition succeeds (first-writer-wins)
   - Verify request ends in exactly one terminal state

2. **Double-approval prevention test:**
   - Create approved request
   - Attempt to approve again from multiple goroutines
   - Verify all re-approval attempts are rejected
   - Verify approver field remains unchanged

3. **Expiration race test:**
   - Create pending request near expiration
   - Simultaneously attempt approval and expiration
   - Verify only one transition succeeds
   - Verify no mixed state (e.g., approved with expiration-related fields)

Use MockRequestStore from testutil. Set UpdateFunc to track call order and enforce first-writer-wins semantics. Run with -race flag to detect data races.
  </action>
  <verify>go test -race -v ./request/... -run Concurrent | grep -E "^(---|PASS|FAIL)"</verify>
  <done>Race conditions tested, first-writer-wins enforced, no data races detected</done>
</task>

<task type="auto">
  <name>Task 3: Request validation security edge cases</name>
  <files>request/state_security_test.go</files>
  <action>
Add validation security edge cases to request/state_security_test.go:

1. **Input sanitization tests:**
   - Test requester/profile with special characters: newlines, null bytes, unicode
   - Test justification with HTML/script injection patterns
   - Test ID with non-hex characters, mixed case, unicode look-alikes
   - Verify validation rejects or safely handles malformed input

2. **Boundary condition tests at security boundaries:**
   - Duration exactly at MaxDuration (8h) - should pass
   - Duration at MaxDuration + 1ns - should fail
   - Justification at MinJustificationLength (10) exactly - should pass
   - Justification at MinJustificationLength - 1 - should fail
   - Use table-driven tests for exhaustive coverage

3. **Timestamp manipulation tests:**
   - Test with future timestamps (CreatedAt > now)
   - Test with ExpiresAt before CreatedAt (impossible state)
   - Test with UpdatedAt before CreatedAt
   - Document whether these are validated (informational)

Focus on security-relevant edge cases that could bypass validation or cause unexpected behavior.
  </action>
  <verify>go test -v ./request/... -run "Security|Edge" | grep -E "^(---|PASS|FAIL)"</verify>
  <done>All validation security edge cases tested, no bypass vectors found</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go test -race ./request/... passes
- [ ] Coverage for request package â‰¥85%
- [ ] All security tests follow table-driven pattern
- [ ] No panics or unexpected behavior with malformed input
</verification>

<success_criteria>
- All tasks completed
- Terminal state immutability proven exhaustively
- Concurrent state transition behavior documented and tested
- Input validation security edge cases covered
- Tests pass with -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/53-approval-workflow-testing/53-01-SUMMARY.md`
</output>
