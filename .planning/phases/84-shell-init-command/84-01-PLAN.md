---
phase: 84-shell-init-command
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [shell/shell.go, shell/shell_test.go, cli/shell_init.go, cli/shell_init_test.go, cmd/sentinel/main.go]
autonomous: true
---

<objective>
Implement `sentinel shell init` command that generates shell wrapper functions for all configured Sentinel profiles.

Purpose: Reduce daily boilerplate by allowing users to run `eval "$(sentinel shell init)"` once in their shell profile to get auto-generated functions like `sentinel-production()` for each configured profile.

Output:
- shell/ package with ProfileInfo types and shell script generation logic
- cli/shell_init.go with ConfigureShellInitCommand and ShellInitCommand functions
- Tests achieving >80% coverage
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow:
@bootstrap/status.go          # SSM GetParametersByPath for profile discovery
@cli/status.go                # CLI command structure with StatusChecker injection
@cli/sentinel_exec.go         # The exec command we wrap with generated functions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shell package with profile discovery and script generation</name>
  <files>shell/shell.go, shell/shell_test.go</files>
  <action>
Create shell/ package with:

1. **ProfileInfo struct** (reuse pattern from bootstrap/status.go):
```go
type ProfileInfo struct {
    Name       string // Profile name (e.g., "production")
    PolicyPath string // Full SSM path (e.g., "/sentinel/policies/production")
}
```

2. **ShellGenerator struct** with ssmShellAPI interface:
```go
type ssmShellAPI interface {
    GetParametersByPath(ctx context.Context, params *ssm.GetParametersByPathInput, optFns ...func(*ssm.Options)) (*ssm.GetParametersByPathOutput, error)
}

type ShellGenerator struct {
    ssm ssmShellAPI
}

func NewShellGenerator(cfg aws.Config) *ShellGenerator
func newShellGeneratorWithClient(client ssmShellAPI) *ShellGenerator // for testing
```

3. **GetProfiles method** - List all profiles under policy root:
```go
func (g *ShellGenerator) GetProfiles(ctx context.Context, policyRoot string) ([]ProfileInfo, error)
```
Uses GetParametersByPath with Recursive=false (same as bootstrap/status.go pattern).

4. **GenerateScript method** - Generate shell script for given format:
```go
type ShellFormat string
const (
    FormatBash ShellFormat = "bash"
    FormatZsh  ShellFormat = "zsh"
)

func GenerateScript(profiles []ProfileInfo, policyRoot string, format ShellFormat) string
```

Generated script format (bash/zsh compatible):
```bash
# Sentinel shell functions - generated by sentinel shell init
# Add to your .bashrc/.zshrc: eval "$(sentinel shell init)"

sentinel-production() {
    sentinel exec --profile production --policy-parameter /sentinel/policies/production -- "$@"
}

sentinel-staging() {
    sentinel exec --profile staging --policy-parameter /sentinel/policies/staging -- "$@"
}
```

Function naming: `sentinel-{profile-name}` where profile name is sanitized (replace non-alphanumeric with hyphens).

5. **Tests** in shell_test.go:
- TestGetProfiles_ReturnsProfiles
- TestGetProfiles_EmptyResult
- TestGetProfiles_Pagination (NextToken handling)
- TestGenerateScript_Bash_MultipleProfiles
- TestGenerateScript_Zsh_SingleProfile
- TestGenerateScript_EmptyProfiles (returns comment only)
- Test profile name sanitization (special characters)
  </action>
  <verify>go test ./shell/... -v -cover shows >80% coverage and all tests pass</verify>
  <done>shell/ package exists with GetProfiles and GenerateScript, tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI shell init command</name>
  <files>cli/shell_init.go, cli/shell_init_test.go, cmd/sentinel/main.go</files>
  <action>
Create cli/shell_init.go following status.go patterns:

1. **ShellInitCommandInput struct**:
```go
type ShellInitCommandInput struct {
    PolicyRoot string      // SSM path prefix (default: /sentinel/policies)
    Region     string      // AWS region for SSM
    AWSProfile string      // AWS profile for credentials
    Format     string      // "bash" or "zsh" (default: auto-detect from SHELL env)

    // For testing
    ShellGenerator *shell.ShellGenerator
    Stdout         *os.File
    Stderr         *os.File
}
```

2. **ConfigureShellInitCommand** - Register under `sentinel shell init`:
```go
func ConfigureShellInitCommand(app *kingpin.Application, s *Sentinel) {
    // Create "shell" parent command if not exists
    shellCmd := app.GetCommand("shell")
    if shellCmd == nil {
        shellCmd = app.Command("shell", "Shell integration commands")
    }

    // Create "init" subcommand
    cmd := shellCmd.Command("init", "Generate shell functions for Sentinel profiles")

    cmd.Flag("policy-root", "SSM parameter path prefix for policies").
        Default(bootstrap.DefaultPolicyRoot).
        StringVar(&input.PolicyRoot)

    cmd.Flag("region", "AWS region for SSM operations").
        StringVar(&input.Region)

    cmd.Flag("aws-profile", "AWS profile for credentials").
        StringVar(&input.AWSProfile)

    cmd.Flag("format", "Output format: bash, zsh (default: auto-detect from $SHELL)").
        StringVar(&input.Format)

    // Action calls ShellInitCommand
}
```

3. **ShellInitCommand function**:
- Load AWS config (with profile/region if specified)
- Create ShellGenerator (or use injected one for tests)
- Call GetProfiles to discover profiles
- Auto-detect shell format from $SHELL env if not specified
- Call GenerateScript with detected format
- Print script to stdout (for eval)
- Print summary to stderr (profile count, usage hint)

4. **Shell format auto-detection**:
```go
func detectShellFormat() shell.ShellFormat {
    shellEnv := os.Getenv("SHELL")
    if strings.Contains(shellEnv, "zsh") {
        return shell.FormatZsh
    }
    return shell.FormatBash // Default
}
```

5. **Wire up in main.go** - Add after existing shell-related commands:
```go
cli.ConfigureShellInitCommand(app, s)
```

6. **Tests** in cli/shell_init_test.go:
- TestShellInitCommand_GeneratesScript (mock ShellGenerator)
- TestShellInitCommand_AutoDetectsBash
- TestShellInitCommand_AutoDetectsZsh
- TestShellInitCommand_NoProfiles (handles empty gracefully)
- TestShellInitCommand_ErrorHandling (SSM errors)
  </action>
  <verify>go test ./cli/... -run ShellInit -v && go build ./cmd/sentinel/...</verify>
  <done>sentinel shell init command exists, compiles, and generates shell functions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./shell/... -v -cover` passes with >80% coverage
- [ ] `go test ./cli/... -run ShellInit -v` passes
- [ ] `go build ./cmd/sentinel/...` succeeds
- [ ] `./cmd/sentinel/sentinel shell init --help` shows usage
- [ ] Running `sentinel shell init` with mock or real SSM produces valid shell script
</verification>

<success_criteria>
- shell/ package created with ShellGenerator, GetProfiles, GenerateScript
- cli/shell_init.go created with ConfigureShellInitCommand, ShellInitCommand
- Tests pass with >80% coverage on new code
- Command registered in cmd/sentinel/main.go
- Generated shell functions follow format: `sentinel-{profile}() { sentinel exec ... }`
</success_criteria>

<output>
After completion, create `.planning/phases/84-shell-init-command/84-01-SUMMARY.md`
</output>
