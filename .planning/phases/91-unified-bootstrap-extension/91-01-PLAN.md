---
phase: 91-unified-bootstrap-extension
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [cli/bootstrap.go, cli/bootstrap_test.go]
autonomous: true
---

<objective>
Extend `sentinel init bootstrap` with `--with-approvals`, `--with-breakglass`, `--with-sessions`, and `--all` flags to provision DynamoDB tables alongside SSM policy parameters.

Purpose: Enable one-command infrastructure provisioning for all Sentinel features.
Output: Extended bootstrap command that creates SSM parameters AND DynamoDB tables in a single operation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@cli/bootstrap.go
@cli/init_approvals.go
@cli/init_breakglass.go
@cli/init_sessions.go
@infrastructure/schema.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --with-* flags to bootstrap command</name>
  <files>cli/bootstrap.go</files>
  <action>
Add new flags to BootstrapCommandInput struct and ConfigureBootstrapCommand:
- WithApprovals bool - creates sentinel-requests table
- WithBreakGlass bool - creates sentinel-breakglass table
- WithSessions bool - creates sentinel-sessions table
- WithAll bool - shorthand for enabling all three
- ApprovalTableName string (default "sentinel-requests")
- BreakGlassTableName string (default "sentinel-breakglass")
- SessionTableName string (default "sentinel-sessions")

In ConfigureBootstrapCommand, add kingpin flags:
```go
cmd.Flag("with-approvals", "Also create DynamoDB approval requests table").
    BoolVar(&input.WithApprovals)

cmd.Flag("with-breakglass", "Also create DynamoDB break-glass events table").
    BoolVar(&input.WithBreakGlass)

cmd.Flag("with-sessions", "Also create DynamoDB server sessions table").
    BoolVar(&input.WithSessions)

cmd.Flag("all", "Create all optional DynamoDB tables (approvals, breakglass, sessions)").
    BoolVar(&input.WithAll)

cmd.Flag("approval-table", "Name for approval requests table").
    Default(DefaultApprovalTableName).
    StringVar(&input.ApprovalTableName)

cmd.Flag("breakglass-table", "Name for break-glass events table").
    Default(DefaultBreakGlassTableName).
    StringVar(&input.BreakGlassTableName)

cmd.Flag("session-table", "Name for server sessions table").
    Default(DefaultSessionTableName).
    StringVar(&input.SessionTableName)
```

Also add Provisioner *infrastructure.TableProvisioner field to input struct for testing.
  </action>
  <verify>go build ./cmd/sentinel succeeds</verify>
  <done>Bootstrap command accepts --with-approvals, --with-breakglass, --with-sessions, --all flags</done>
</task>

<task type="auto">
  <name>Task 2: Implement table provisioning in BootstrapCommand</name>
  <files>cli/bootstrap.go</files>
  <action>
After the existing SSM apply logic in BootstrapCommand, add DynamoDB table provisioning:

1. Resolve --all flag into individual flags:
```go
if input.WithAll {
    input.WithApprovals = true
    input.WithBreakGlass = true
    input.WithSessions = true
}
```

2. After SSM apply (or in plan-only mode after SSM plan), provision tables if any --with-* flag is set:
```go
// Provision DynamoDB tables if requested
if input.WithApprovals || input.WithBreakGlass || input.WithSessions {
    if !input.JSONOutput {
        fmt.Fprintln(stdout, "\n"+strings.Repeat("=", 60))
        fmt.Fprintln(stdout, "DynamoDB Tables")
        fmt.Fprintln(stdout, strings.Repeat("=", 60))
    }

    // Get or create provisioner
    provisioner := input.Provisioner
    if provisioner == nil {
        provisioner = infrastructure.NewTableProvisioner(awsCfg, input.Region)
    }

    // Provision each requested table
    tableErrors := []error{}

    if input.WithApprovals {
        err := provisionTable(ctx, provisioner, infrastructure.ApprovalTableSchema(input.ApprovalTableName),
            "Approvals", input.PlanOnly, stdout, stderr)
        if err != nil {
            tableErrors = append(tableErrors, err)
        }
    }

    if input.WithBreakGlass {
        err := provisionTable(ctx, provisioner, infrastructure.BreakGlassTableSchema(input.BreakGlassTableName),
            "Break-Glass", input.PlanOnly, stdout, stderr)
        if err != nil {
            tableErrors = append(tableErrors, err)
        }
    }

    if input.WithSessions {
        err := provisionTable(ctx, provisioner, infrastructure.SessionTableSchema(input.SessionTableName),
            "Sessions", input.PlanOnly, stdout, stderr)
        if err != nil {
            tableErrors = append(tableErrors, err)
        }
    }

    // Report any table errors but don't fail the whole operation
    if len(tableErrors) > 0 && !input.JSONOutput {
        fmt.Fprintf(stderr, "\nWarning: %d table(s) failed to provision\n", len(tableErrors))
    }
}
```

3. Add helper function provisionTable:
```go
// provisionTable provisions a single DynamoDB table.
// Returns nil on success or table-already-exists, error on failure.
func provisionTable(ctx context.Context, provisioner *infrastructure.TableProvisioner,
    schema infrastructure.TableSchema, label string, planOnly bool, stdout, stderr *os.File) error {

    if planOnly {
        plan, err := provisioner.Plan(ctx, schema)
        if err != nil {
            fmt.Fprintf(stderr, "  X %s: failed to plan: %v\n", label, err)
            return err
        }
        if plan.WouldCreate {
            fmt.Fprintf(stdout, "  + %s table: %s\n", label, plan.TableName)
        } else {
            fmt.Fprintf(stdout, "  = %s table: %s (exists)\n", label, plan.TableName)
        }
        return nil
    }

    result, err := provisioner.Create(ctx, schema)
    if err != nil {
        fmt.Fprintf(stderr, "  X %s table: %v\n", label, err)
        return err
    }

    switch result.Status {
    case infrastructure.StatusCreated:
        fmt.Fprintf(stdout, "  + %s table: %s (created)\n", label, schema.TableName)
    case infrastructure.StatusExists:
        fmt.Fprintf(stdout, "  = %s table: %s (exists)\n", label, schema.TableName)
    case infrastructure.StatusFailed:
        fmt.Fprintf(stderr, "  X %s table: %v\n", label, result.Error)
        return result.Error
    }

    return nil
}
```

4. Add import for "github.com/byteness/aws-vault/v7/infrastructure" at top of file.

5. IMPORTANT: Table provisioning uses same confirmation as SSM (no separate prompt). User confirms once for entire operation.

6. IMPORTANT: Tables require --region flag. If --with-* flags used but --region not set, print error and return early:
```go
if (input.WithApprovals || input.WithBreakGlass || input.WithSessions) && input.Region == "" {
    fmt.Fprintln(stderr, "Error: --region is required when provisioning DynamoDB tables")
    return fmt.Errorf("--region is required when provisioning DynamoDB tables")
}
```
  </action>
  <verify>go build ./cmd/sentinel && go vet ./cli/...</verify>
  <done>BootstrapCommand provisions DynamoDB tables when --with-* flags set</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for bootstrap table provisioning</name>
  <files>cli/bootstrap_test.go</files>
  <action>
Add tests for the new table provisioning functionality. Use the existing mock patterns from init_approvals_test.go:

1. TestBootstrapCommand_WithApprovalsFlag - verify approvals table created when --with-approvals
2. TestBootstrapCommand_WithAllFlag - verify all three tables created when --all
3. TestBootstrapCommand_TableRequiresRegion - verify error when --with-* without --region
4. TestBootstrapCommand_TablePlanOnly - verify tables shown in plan mode without creating

Use mock infrastructure.TableProvisioner by adding Provisioner field to input. The provisioner should have Plan() and Create() methods that can be mocked.

For mocking, create a simple test helper:
```go
type mockTableProvisioner struct {
    PlanResult   *infrastructure.TablePlan
    PlanErr      error
    CreateResult *infrastructure.TableResult
    CreateErr    error
    PlanCalls    []infrastructure.TableSchema
    CreateCalls  []infrastructure.TableSchema
}

func (m *mockTableProvisioner) Plan(ctx context.Context, schema infrastructure.TableSchema) (*infrastructure.TablePlan, error) {
    m.PlanCalls = append(m.PlanCalls, schema)
    return m.PlanResult, m.PlanErr
}

func (m *mockTableProvisioner) Create(ctx context.Context, schema infrastructure.TableSchema) (*infrastructure.TableResult, error) {
    m.CreateCalls = append(m.CreateCalls, schema)
    return m.CreateResult, m.CreateErr
}
```

Test cases:
- --with-approvals creates approvals table
- --with-all creates all three tables
- --with-approvals without --region returns error
- --plan with --with-approvals shows plan without creating
  </action>
  <verify>go test ./cli/... -run TestBootstrapCommand -v</verify>
  <done>Tests pass for all --with-* flag scenarios</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./cmd/sentinel` succeeds
- [ ] `go test ./cli/... -run TestBootstrapCommand` passes
- [ ] `go vet ./cli/...` has no warnings
- [ ] Bootstrap command shows help with new flags: `go run ./cmd/sentinel init bootstrap --help`
</verification>

<success_criteria>
- All tasks completed
- Bootstrap command accepts --with-approvals, --with-breakglass, --with-sessions, --all flags
- Tables created when flags set (or shown in plan mode)
- Error returned when --with-* used without --region
- Tests verify flag behavior
</success_criteria>

<output>
After completion, create `.planning/phases/91-unified-bootstrap-extension/91-01-SUMMARY.md`
</output>
