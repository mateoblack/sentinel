---
phase: 126-policy-integrity
plan: 02
type: execute
wave: 2
depends_on: ["126-01"]
files_modified: [policy/verifying_loader.go, policy/verifying_loader_test.go, cli/policy_sign.go, cli/policy_sign_test.go]
autonomous: true
---

<objective>
Implement signed policy verification loader and CLI signing commands.

Purpose: Enable signature-aware policy loading that rejects tampered policies, plus CLI commands for signing and verifying policies locally and during push operations.

Output: VerifyingLoader that enforces signature validation, policy sign/verify CLI commands, push --sign integration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan output (must exist before execution):
@.planning/phases/126-policy-integrity/126-01-SUMMARY.md

# Existing patterns:
@policy/loader.go
@policy/cache.go
@cli/policy.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create verifying policy loader</name>
  <files>policy/verifying_loader.go, policy/verifying_loader_test.go</files>
  <action>
Create policy/verifying_loader.go with:

1. **VerifyingLoader struct**:
```go
type VerifyingLoader struct {
    loader    PolicyLoader   // Underlying loader for policy YAML
    sigLoader PolicyLoader   // Loader for signature parameters (same interface, different prefix)
    signer    *PolicySigner  // For signature verification
    enforce   bool           // If true, reject unsigned policies. If false, warn only.
}
```

2. **Constructor options**:
```go
type VerifyingLoaderOption func(*VerifyingLoader)

func WithEnforcement(enforce bool) VerifyingLoaderOption {
    return func(v *VerifyingLoader) { v.enforce = enforce }
}

func NewVerifyingLoader(policyLoader, sigLoader PolicyLoader, signer *PolicySigner, opts ...VerifyingLoaderOption) *VerifyingLoader
```

3. **Load(ctx context.Context, parameterName string) (*Policy, error)** method:
   a. Load policy YAML from policyLoader
   b. Compute signature parameter name: SignatureParameterName(parameterName)
   c. Load signature from sigLoader (handle ErrPolicyNotFound for missing signature)
   d. If signature exists:
      - Parse SignatureMetadata from JSON
      - Verify signature using signer.Verify()
      - If invalid: return error "policy signature verification failed"
      - If valid: return policy
   e. If signature missing:
      - If enforce=true: return error "policy not signed (signature enforcement enabled)"
      - If enforce=false: log warning "policy %s has no signature, loading without verification", return policy

4. **Error types**:
```go
var (
    ErrSignatureInvalid    = errors.New("policy signature verification failed")
    ErrSignatureMissing    = errors.New("policy signature missing")
    ErrSignatureEnforced   = errors.New("policy not signed (signature enforcement enabled)")
)
```

Create policy/verifying_loader_test.go with:
- TestVerifyingLoader_Load_ValidSignature (happy path)
- TestVerifyingLoader_Load_InvalidSignature (returns error)
- TestVerifyingLoader_Load_MissingSignature_NotEnforced (warns, succeeds)
- TestVerifyingLoader_Load_MissingSignature_Enforced (returns error)
- TestVerifyingLoader_Load_PolicyNotFound (passthrough error)
- Use mock PolicyLoader and PolicySigner
  </action>
  <verify>go test ./policy/... -run TestVerifyingLoader -v</verify>
  <done>VerifyingLoader with fail-closed signature verification, enforcement modes, comprehensive test coverage</done>
</task>

<task type="auto">
  <name>Task 2: Create policy sign CLI command</name>
  <files>cli/policy_sign.go, cli/policy_sign_test.go</files>
  <action>
Create cli/policy_sign.go with:

1. **ConfigurePolicySign command** (subcommand of policy):
```go
func ConfigurePolicySign(app *kingpin.Application, cfg *GlobalFlags) {
    cmd := app.GetCommand("policy").Command("sign", "Sign a policy file with KMS")
    // Flags:
    // --key-id (required): KMS key ARN or alias
    // --output/-o (optional): Output file for signature (default: stdout)
    // Policy file as positional argument
}
```

2. **PolicySignCommand struct**:
   - keyID string
   - outputFile string
   - policyFile string

3. **Run() error** method:
   a. Read policy file
   b. Validate policy parses correctly (fail early on invalid YAML)
   c. Create PolicySigner with keyID
   d. Sign policy YAML â†’ raw signature bytes
   e. Create SignatureMetadata (keyID, algorithm, timestamp, policy hash)
   f. Marshal metadata to JSON
   g. Combine signature bytes (base64) + metadata into output format:
      ```json
      {
        "signature": "<base64>",
        "metadata": { "key_id": "...", "algorithm": "...", "signed_at": "...", "policy_hash": "..." }
      }
      ```
   h. Write to outputFile or stdout

4. **ConfigurePolicyVerify command**:
```go
func ConfigurePolicyVerify(app *kingpin.Application, cfg *GlobalFlags) {
    cmd := app.GetCommand("policy").Command("verify", "Verify a policy signature locally")
    // --key-id (required): KMS key for verification
    // --signature/-s (required): Signature file (JSON format from sign command)
    // Policy file as positional argument
}
```

5. **PolicyVerifyCommand struct and Run()**:
   a. Read policy file and signature file
   b. Parse signature JSON
   c. Validate policy hash matches metadata
   d. Create PolicySigner and verify signature
   e. Exit 0 if valid (print "Signature valid"), exit 1 if invalid (print "Signature invalid: <reason>")

Create cli/policy_sign_test.go with:
- TestPolicySignCommand_Run_Success (mock KMS, verify output format)
- TestPolicySignCommand_Run_InvalidPolicy (parse error)
- TestPolicySignCommand_Run_KMSError
- TestPolicyVerifyCommand_Run_Valid
- TestPolicyVerifyCommand_Run_Invalid
- TestPolicyVerifyCommand_Run_HashMismatch
  </action>
  <verify>go test ./cli/... -run "TestPolicySign|TestPolicyVerify" -v</verify>
  <done>policy sign and policy verify CLI commands with proper exit codes, JSON output format, test coverage</done>
</task>

<task type="auto">
  <name>Task 3: Extend policy push with signing support</name>
  <files>cli/policy.go, cli/policy_test.go</files>
  <action>
Extend existing cli/policy.go to add --sign flag to push command:

1. **Add flag to PolicyPushCommand**:
   - --sign: Sign policy before pushing (requires --key-id)
   - --key-id: KMS key for signing (required if --sign is set)

2. **Update PolicyPushCommand.Run()**:
   a. If --sign is set:
      - Validate --key-id provided (error if missing)
      - Create PolicySigner
      - Sign policy YAML
      - Create SignatureMetadata
      - Compute signature parameter name
      - Push signature to SSM (SignatureParameterPrefix + profile)
      - Then push policy to SSM (existing behavior)
   b. If --sign is not set:
      - Existing behavior (push policy only)
      - Add info message: "Note: Policy pushed without signature. Use --sign to enable signature verification."

3. **Update confirmation prompt** when --sign is set:
   - Show both parameters being written: policy AND signature

4. **Handle push failure**:
   - If signature push succeeds but policy push fails, warn about inconsistent state
   - Recommend re-running with --sign to fix

Update cli/policy_test.go with:
- TestPolicyPushCommand_Run_WithSign (mock both SSM calls)
- TestPolicyPushCommand_Run_WithSign_MissingKeyID (error)
- TestPolicyPushCommand_Run_WithSign_SignaturePushFails
- TestPolicyPushCommand_Run_WithSign_PolicyPushFails (warning about inconsistency)
  </action>
  <verify>go test ./cli/... -run TestPolicyPush -v</verify>
  <done>policy push --sign with signature upload, proper error handling, confirmation prompt shows both parameters</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./policy/... ./cli/...` succeeds
- [ ] `go test ./policy/... -run TestVerifyingLoader` passes
- [ ] `go test ./cli/... -run "TestPolicySign|TestPolicyVerify|TestPolicyPush"` passes
- [ ] `go vet ./policy/... ./cli/...` reports no issues
- [ ] New CLI commands appear in `go run ./cmd/sentinel policy --help`
</verification>

<success_criteria>

- VerifyingLoader validates signatures with configurable enforcement
- policy sign command creates detached signatures
- policy verify command validates signatures locally
- policy push --sign uploads both policy and signature
- Fail-closed behavior when enforcement enabled
- All new code has test coverage
</success_criteria>

<output>
After completion, create `.planning/phases/126-policy-integrity/126-02-SUMMARY.md`
</output>
