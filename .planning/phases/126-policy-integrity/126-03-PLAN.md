---
phase: 126-policy-integrity
plan: 03
type: execute
wave: 3
depends_on: ["126-01", "126-02"]
files_modified: [lambda/handler.go, lambda/config.go, lambda/handler_test.go, lambda/config_test.go, policy/security_test.go]
autonomous: true
---

<objective>
Integrate signature verification into Lambda TVM and create security tests for policy cache poisoning prevention.

Purpose: Ensure Lambda TVM rejects tampered policies by enforcing signature verification, completing the cache poisoning defense.

Output: Lambda TVM with signature-verified policy loading, security regression tests validating tampering rejection.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan outputs (must exist before execution):
@.planning/phases/126-policy-integrity/126-01-SUMMARY.md
@.planning/phases/126-policy-integrity/126-02-SUMMARY.md

# Existing Lambda code:
@lambda/handler.go
@lambda/config.go
@lambda/secrets.go

# Security test patterns:
@lambda/handler_security_test.go
@sentinel/security_integration_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add policy signing configuration to Lambda TVM</name>
  <files>lambda/config.go, lambda/config_test.go</files>
  <action>
Extend lambda/config.go to support policy signing:

1. **Add fields to TVMConfig**:
```go
type TVMConfig struct {
    // ... existing fields ...

    // PolicySigningKeyID is the KMS key ARN for verifying policy signatures.
    // If set, policies without valid signatures will be rejected.
    // Environment variable: SENTINEL_POLICY_SIGNING_KEY
    PolicySigningKeyID string

    // EnforcePolicySigning controls whether unsigned policies are rejected.
    // If true, policies without signatures return an error.
    // If false, unsigned policies are allowed with a warning log.
    // Default: true when PolicySigningKeyID is set.
    // Environment variable: SENTINEL_ENFORCE_POLICY_SIGNING (default: "true")
    EnforcePolicySigning bool
}
```

2. **Update LoadFromEnv()**:
   - Read SENTINEL_POLICY_SIGNING_KEY (optional)
   - Read SENTINEL_ENFORCE_POLICY_SIGNING (default "true" if signing key is set, "false" otherwise)
   - Validate: if EnforcePolicySigning is true, PolicySigningKeyID must be set

3. **Add validation method**:
```go
func (c *TVMConfig) ValidateSigning() error {
    if c.EnforcePolicySigning && c.PolicySigningKeyID == "" {
        return fmt.Errorf("SENTINEL_POLICY_SIGNING_KEY required when SENTINEL_ENFORCE_POLICY_SIGNING=true")
    }
    return nil
}
```

Update lambda/config_test.go with:
- TestTVMConfig_LoadFromEnv_WithSigningKey
- TestTVMConfig_LoadFromEnv_WithoutSigningKey
- TestTVMConfig_LoadFromEnv_EnforcementDisabled
- TestTVMConfig_ValidateSigning_MissingKey
- TestTVMConfig_ValidateSigning_Valid
  </action>
  <verify>go test ./lambda/... -run TestTVMConfig -v</verify>
  <done>TVMConfig extended with PolicySigningKeyID and EnforcePolicySigning, environment loading, validation</done>
</task>

<task type="auto">
  <name>Task 2: Integrate VerifyingLoader into Lambda handler</name>
  <files>lambda/handler.go, lambda/handler_test.go</files>
  <action>
Modify lambda/handler.go to use signature-verified policy loading:

1. **Update Handler struct** (if needed):
```go
type Handler struct {
    // ... existing fields ...
    policyLoader policy.PolicyLoader  // This can be VerifyingLoader or plain Loader
}
```

2. **Update NewHandler or initialization**:
   - If config.PolicySigningKeyID is set:
     a. Create PolicySigner with KMS key
     b. Create base Loader for policies
     c. Create base Loader for signatures (different SSM client or same with different prefix)
     d. Wrap with VerifyingLoader:
        ```go
        verifyingLoader := policy.NewVerifyingLoader(
            policyLoader,
            sigLoader,
            signer,
            policy.WithEnforcement(config.EnforcePolicySigning),
        )
        ```
     e. Wrap with CachedLoader for performance:
        ```go
        cachedLoader := policy.NewCachedLoader(verifyingLoader, 5*time.Minute)
        ```
   - If config.PolicySigningKeyID is not set:
     - Use existing plain Loader (backward compatible)
     - Log info: "Policy signature verification disabled (SENTINEL_POLICY_SIGNING_KEY not set)"

3. **Error handling in credential vending**:
   - If policy load fails with ErrSignatureInvalid or ErrSignatureEnforced:
     - Log as SECURITY event: "SECURITY: Policy signature verification failed: %v"
     - Return 403 Forbidden with sanitized error (don't expose signature details to client)
     - Do NOT cache failed verifications

4. **Logging for security events**:
   - Log successful verification: "Policy %s signature verified (key: %s)"
   - Log failed verification: "SECURITY: Policy %s signature INVALID"
   - Log missing signature (non-enforced): "WARN: Policy %s has no signature"

Update lambda/handler_test.go with:
- TestHandler_CredentialRequest_ValidSignature
- TestHandler_CredentialRequest_InvalidSignature_Rejected
- TestHandler_CredentialRequest_MissingSignature_Enforced
- TestHandler_CredentialRequest_MissingSignature_NotEnforced
- TestHandler_CredentialRequest_NoSigningConfigured (backward compatible)
  </action>
  <verify>go test ./lambda/... -run TestHandler_CredentialRequest -v</verify>
  <done>Lambda handler uses VerifyingLoader when signing configured, rejects invalid signatures, backward compatible when not configured</done>
</task>

<task type="auto">
  <name>Task 3: Create policy integrity security tests</name>
  <files>policy/security_test.go</files>
  <action>
Create policy/security_test.go with security regression tests:

1. **TestSecurityRegression_PolicyTampering_Rejected**:
   - Create valid policy and sign it
   - Modify policy content (change rule effect from deny to allow)
   - Attempt to verify modified policy with original signature
   - Assert: verification fails
   - Comment: "SECURITY: Verifies that policy modifications after signing are detected and rejected"

2. **TestSecurityRegression_SignatureReplay_Rejected**:
   - Create two different policies
   - Sign policy A
   - Attempt to verify policy B with policy A's signature
   - Assert: verification fails
   - Comment: "SECURITY: Verifies that signatures cannot be replayed across different policies"

3. **TestSecurityRegression_TruncatedSignature_Rejected**:
   - Create valid policy and sign it
   - Truncate signature bytes
   - Attempt to verify with truncated signature
   - Assert: verification fails or returns error
   - Comment: "SECURITY: Verifies that corrupted signatures are rejected"

4. **TestSecurityRegression_EmptySignature_Rejected**:
   - Create valid policy
   - Attempt to verify with empty/nil signature
   - Assert: verification fails
   - Comment: "SECURITY: Verifies that missing signatures fail verification"

5. **TestSecurityRegression_CachePoisoning_Prevented**:
   - Set up VerifyingLoader with enforcement enabled
   - Mock: SSM returns valid policy YAML
   - Mock: SSM returns invalid signature for that policy
   - Attempt to load policy
   - Assert: load fails with ErrSignatureInvalid
   - Assert: invalid policy is NOT cached
   - Comment: "SECURITY: Verifies that cache poisoning via SSM manipulation is prevented"

6. **TestSecurityRegression_PolicyHashMismatch_Detected**:
   - Create SignedPolicy with mismatched policy_hash in metadata
   - Call ValidateHash()
   - Assert: returns false
   - Comment: "SECURITY: Verifies that policy_hash provides additional integrity check"

Use TestSecurityRegression_ prefix for CI/CD filtering (consistent with existing security tests).
Include explicit SECURITY comments explaining each attack scenario.
  </action>
  <verify>go test ./policy/... -run TestSecurityRegression -v</verify>
  <done>Security regression tests for policy tampering, signature replay, cache poisoning prevention</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./lambda/... ./policy/...` succeeds
- [ ] `go test ./lambda/... -run TestTVMConfig` passes
- [ ] `go test ./lambda/... -run TestHandler_CredentialRequest` passes
- [ ] `go test ./policy/... -run TestSecurityRegression` passes
- [ ] `go vet ./lambda/... ./policy/...` reports no issues
- [ ] All security tests have SECURITY comments explaining attack scenarios
</verification>

<success_criteria>

- Lambda TVM enforces policy signature verification when configured
- Invalid signatures result in 403 Forbidden (fail-closed)
- Backward compatible when SENTINEL_POLICY_SIGNING_KEY not set
- Security tests validate cache poisoning prevention
- SECURITY logging for verification events
- All attack scenarios documented in test comments
</success_criteria>

<output>
After completion, create `.planning/phases/126-policy-integrity/126-03-SUMMARY.md`
</output>
