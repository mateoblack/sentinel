---
phase: 126-policy-integrity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [policy/signer.go, policy/signer_test.go, policy/signature.go, policy/signature_test.go]
autonomous: true
---

<objective>
Create KMS-based policy signing infrastructure for preventing policy cache poisoning attacks.

Purpose: Establish cryptographic foundation for signed policies - KMS asymmetric signing interface, signature types, and storage schema for policy signatures.

Output: policy/signer.go with KMSAPI interface and Sign/Verify operations, policy/signature.go with SignedPolicy and SignatureMetadata types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing patterns to follow:
@lambda/secrets.go
@policy/loader.go
@policy/types.go
@policy/cache.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create KMS signer interface and implementation</name>
  <files>policy/signer.go, policy/signer_test.go</files>
  <action>
Create policy/signer.go with:

1. **KMSAPI interface** (follow secretsManagerAPI pattern from lambda/secrets.go):
```go
type KMSAPI interface {
    Sign(ctx context.Context, params *kms.SignInput, optFns ...func(*kms.Options)) (*kms.SignOutput, error)
    Verify(ctx context.Context, params *kms.VerifyInput, optFns ...func(*kms.Options)) (*kms.VerifyOutput, error)
}
```

2. **PolicySigner struct** with:
   - client KMSAPI
   - keyID string (KMS key ARN or alias)
   - algorithm types.SigningAlgorithmSpec (default RSASSA_PSS_SHA_256)

3. **NewPolicySigner(cfg aws.Config, keyID string) *PolicySigner** constructor

4. **NewPolicySignerWithClient(client KMSAPI, keyID string) *PolicySigner** for testing

5. **Sign(ctx context.Context, policyYAML []byte) ([]byte, error)** method:
   - Use KMS Sign with MessageType MESSAGE (not DIGEST)
   - Policy YAML is the message to sign
   - Returns raw signature bytes

6. **Verify(ctx context.Context, policyYAML []byte, signature []byte) (bool, error)** method:
   - Use KMS Verify with same MessageType
   - Returns (true, nil) if valid, (false, nil) if invalid, (false, error) on KMS errors
   - IMPORTANT: Do NOT return error for invalid signature (that's a normal validation result)

Import: github.com/aws/aws-sdk-go-v2/service/kms and kms/types

Create policy/signer_test.go with:
- TestPolicySigner_Sign_Success with mock KMSAPI
- TestPolicySigner_Sign_KMSError
- TestPolicySigner_Verify_Valid
- TestPolicySigner_Verify_Invalid (returns false, nil)
- TestPolicySigner_Verify_KMSError
- Use table-driven tests for multiple scenarios
  </action>
  <verify>go test ./policy/... -run TestPolicySigner -v</verify>
  <done>PolicySigner with Sign/Verify methods, KMSAPI interface, comprehensive tests passing</done>
</task>

<task type="auto">
  <name>Task 2: Create signature types and storage schema</name>
  <files>policy/signature.go, policy/signature_test.go</files>
  <action>
Create policy/signature.go with:

1. **Constants for signature parameter naming**:
```go
const (
    // PolicyParameterPrefix is the SSM parameter path prefix for policies.
    PolicyParameterPrefix = "/sentinel/policies/"
    // SignatureParameterPrefix is the SSM parameter path prefix for policy signatures.
    SignatureParameterPrefix = "/sentinel/signatures/"
)
```

2. **SignatureMetadata struct**:
```go
type SignatureMetadata struct {
    KeyID       string    `json:"key_id"`       // KMS key ARN or ID used for signing
    Algorithm   string    `json:"algorithm"`    // Signing algorithm (e.g., RSASSA_PSS_SHA_256)
    SignedAt    time.Time `json:"signed_at"`    // When the signature was created
    PolicyHash  string    `json:"policy_hash"`  // SHA-256 hash of the policy YAML (hex encoded)
}
```

3. **SignedPolicy struct** (combines policy with signature info):
```go
type SignedPolicy struct {
    Policy          *Policy           `json:"policy"`
    Signature       []byte            `json:"signature"`        // Raw signature bytes
    SignatureBase64 string            `json:"signature_base64"` // Base64-encoded for storage
    Metadata        SignatureMetadata `json:"metadata"`
}
```

4. **Helper functions**:
   - `SignatureParameterName(policyParam string) string` - converts /sentinel/policies/foo to /sentinel/signatures/foo
   - `PolicyParameterName(signatureParam string) string` - reverse conversion
   - `ComputePolicyHash(policyYAML []byte) string` - SHA-256 hex hash of policy content

5. **Validation methods**:
   - `(m *SignatureMetadata) Validate() error` - ensure required fields present
   - `(s *SignedPolicy) ValidateHash() bool` - verify PolicyHash matches actual policy content

Create policy/signature_test.go with:
- TestSignatureParameterName (various conversions)
- TestPolicyParameterName
- TestComputePolicyHash (known inputs â†’ expected hashes)
- TestSignatureMetadata_Validate (valid, missing fields)
- TestSignedPolicy_ValidateHash (match, mismatch)
  </action>
  <verify>go test ./policy/... -run TestSignature -v && go test ./policy/... -run TestCompute -v</verify>
  <done>SignedPolicy type, SignatureMetadata type, parameter naming helpers, hash computation, validation tests passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./policy/...` succeeds
- [ ] `go test ./policy/... -run "TestPolicySigner|TestSignature|TestCompute"` passes
- [ ] `go vet ./policy/...` reports no issues
- [ ] No new linting errors in policy package
</verification>

<success_criteria>

- PolicySigner with Sign/Verify methods implemented
- KMSAPI interface defined for testability
- SignedPolicy and SignatureMetadata types defined
- Parameter naming convention helpers implemented
- All new code has test coverage
- Follows existing patterns from lambda/secrets.go and policy/loader.go
</success_criteria>

<output>
After completion, create `.planning/phases/126-policy-integrity/126-01-SUMMARY.md`
</output>
