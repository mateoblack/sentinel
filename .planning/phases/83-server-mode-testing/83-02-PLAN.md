---
phase: 83-server-mode-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [cli/sentinel_server_test.go]
autonomous: true
---

<objective>
Add comprehensive tests for the CLI server-revoke command.

Purpose: The ServerRevokeCommand in cli/sentinel_server.go has ZERO test coverage. This is a security-critical command that enables immediate session termination. All code paths need test coverage.
Output: CLI server-revoke command tests covering success, error cases, input validation, and output formats.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@cli/sentinel_server.go
@cli/sentinel_server_test.go
@session/revoke.go
@session/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add server-revoke success test</name>
  <files>cli/sentinel_server_test.go</files>
  <action>
Add test `TestServerRevokeCommand_Success` that:
1. Creates mockSessionStore with an active session
2. Creates mockSTSClient returning a known username
3. Calls ServerRevokeCommand with valid session ID and reason
4. Verifies session was revoked (status changed to revoked)
5. Verifies human output contains success message

Pattern from existing tests:
```go
func TestServerRevokeCommand_Success(t *testing.T) {
    mockStore := newMockSessionStore()
    activeSession := &session.ServerSession{
        ID:     "abc1234567890def",
        User:   "alice",
        Profile: "production",
        Status: session.StatusActive,
        // ... other fields
    }
    mockStore.sessions[activeSession.ID] = activeSession

    mockSTS := &testutil.MockSTSClient{
        GetCallerIdentityFunc: func(ctx context.Context, input *sts.GetCallerIdentityInput, opts ...func(*sts.Options)) (*sts.GetCallerIdentityOutput, error) {
            return &sts.GetCallerIdentityOutput{
                Arn: aws.String("arn:aws:iam::123456789012:user/admin"),
            }, nil
        },
    }

    input := ServerRevokeCommandInput{
        SessionID: activeSession.ID,
        Reason:    "Security incident",
        Store:     mockStore,
        STSClient: mockSTS,
    }

    err := ServerRevokeCommand(context.Background(), input)
    if err != nil {
        t.Fatalf("Expected no error, got: %v", err)
    }

    // Verify session was revoked
    revokedSession := mockStore.sessions[activeSession.ID]
    if revokedSession.Status != session.StatusRevoked {
        t.Errorf("Expected status revoked, got %s", revokedSession.Status)
    }
}
```
  </action>
  <verify>go test -v -run TestServerRevokeCommand_Success ./cli/</verify>
  <done>Test passes, proving successful revocation works</done>
</task>

<task type="auto">
  <name>Task 2: Add server-revoke error case tests</name>
  <files>cli/sentinel_server_test.go</files>
  <action>
Add tests for error cases:

1. `TestServerRevokeCommand_NotFound` - session ID doesn't exist, verify ErrSessionNotFound returned
2. `TestServerRevokeCommand_AlreadyRevoked` - session already revoked, verify ErrSessionAlreadyRevoked returned
3. `TestServerRevokeCommand_Expired` - session already expired, verify ErrSessionExpired returned

Pattern:
```go
func TestServerRevokeCommand_NotFound(t *testing.T) {
    mockStore := newMockSessionStore()
    // Don't add any sessions - store is empty

    mockSTS := &testutil.MockSTSClient{
        GetCallerIdentityFunc: func(...) (*sts.GetCallerIdentityOutput, error) {
            return &sts.GetCallerIdentityOutput{
                Arn: aws.String("arn:aws:iam::123456789012:user/admin"),
            }, nil
        },
    }

    input := ServerRevokeCommandInput{
        SessionID: "abc1234567890def",
        Reason:    "Test reason",
        Store:     mockStore,
        STSClient: mockSTS,
    }

    err := ServerRevokeCommand(context.Background(), input)
    if !errors.Is(err, session.ErrSessionNotFound) {
        t.Errorf("Expected ErrSessionNotFound, got: %v", err)
    }
}
```
  </action>
  <verify>go test -v -run "TestServerRevokeCommand_(NotFound|AlreadyRevoked|Expired)" ./cli/</verify>
  <done>Tests pass for all error scenarios</done>
</task>

<task type="auto">
  <name>Task 3: Add server-revoke validation tests</name>
  <files>cli/sentinel_server_test.go</files>
  <action>
Add input validation tests:

1. `TestServerRevokeCommand_InvalidSessionID` - invalid format (not 16 hex chars), verify error returned
2. `TestServerRevokeCommand_EmptyReason` - empty reason string, verify error returned
3. `TestServerRevokeCommand_JSONOutput` - verify JSON output format is correct

Pattern for validation test:
```go
func TestServerRevokeCommand_InvalidSessionID(t *testing.T) {
    input := ServerRevokeCommandInput{
        SessionID: "invalid",  // Not 16 hex chars
        Reason:    "Test",
    }

    err := ServerRevokeCommand(context.Background(), input)
    if err == nil {
        t.Error("Expected error for invalid session ID")
    }
    // Should fail before Store/STS are even called
}
```

For JSON output test, use a successful revocation and verify JSON structure:
```go
func TestServerRevokeCommand_JSONOutput(t *testing.T) {
    // ... setup mock store and STS
    input := ServerRevokeCommandInput{
        SessionID:    "abc1234567890def",
        Reason:       "Test",
        OutputFormat: "json",
        Store:        mockStore,
        STSClient:    mockSTS,
    }
    // Capture stdout and verify JSON structure
}
```
  </action>
  <verify>go test -v -run "TestServerRevokeCommand_(InvalidSessionID|EmptyReason|JSONOutput)" ./cli/</verify>
  <done>Tests pass for input validation and output formats</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go test -v ./cli/... passes all tests
- [ ] ServerRevokeCommand has test coverage for success path
- [ ] Error cases tested: not found, already revoked, expired
- [ ] Input validation tested: invalid session ID, empty reason
- [ ] JSON output format tested
</verification>

<success_criteria>

- All tasks completed
- ServerRevokeCommand has comprehensive test coverage
- All error paths verified
- Input validation enforced
</success_criteria>

<output>
After completion, create `.planning/phases/83-server-mode-testing/83-02-SUMMARY.md`
</output>
