---
phase: 33-rate-limiting
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - breakglass/checker.go
  - breakglass/checker_test.go
  - cli/breakglass.go
  - cli/breakglass_test.go
autonomous: true
---

<objective>
Create rate limit checker function and integrate into break-glass CLI command.

Purpose: Enforce rate limits at break-glass invocation time, preventing abuse while providing clear feedback on why requests are blocked and when they can retry.
Output: CheckRateLimit function with RateLimitResult, CLI integration with rate limit enforcement.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase - provides types and store methods
@.planning/phases/33-rate-limiting/33-01-SUMMARY.md

# CLI pattern to extend
@cli/breakglass.go
@cli/breakglass_test.go

# Existing checker pattern from Phase 30
@breakglass/types.go
@breakglass/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CheckRateLimit function</name>
  <files>breakglass/checker.go, breakglass/checker_test.go</files>
  <action>
Create rate limit checker following existing checker patterns:

**RateLimitResult struct:**
```go
type RateLimitResult struct {
    Allowed       bool          // Whether break-glass is allowed
    Reason        string        // Why blocked (empty if allowed)
    RetryAfter    time.Duration // When to retry (0 if allowed or permanent block)
    UserCount     int           // Current count for user in window
    ProfileCount  int           // Current count for profile in window
    ShouldEscalate bool         // Whether escalation threshold exceeded
}
```

**CheckRateLimit function:**
```go
// CheckRateLimit checks if break-glass is allowed for the given user and profile.
// It checks cooldown, per-user quota, and per-profile quota against the policy.
// Returns RateLimitResult indicating if allowed and why if blocked.
func CheckRateLimit(ctx context.Context, store Store, policy *RateLimitPolicy, invoker, profile string, now time.Time) (*RateLimitResult, error)
```

**Logic:**
1. Find matching rule via FindRateLimitRule - if nil, return allowed (no limits configured)
2. If Cooldown > 0:
   - Call store.GetLastByInvokerAndProfile(ctx, invoker, profile)
   - If last event exists and now.Sub(last.CreatedAt) < Cooldown, blocked with RetryAfter
3. If MaxPerUser > 0:
   - Call store.CountByInvokerSince(ctx, invoker, now.Add(-rule.QuotaWindow))
   - If count >= MaxPerUser, blocked with reason "user quota exceeded"
4. If MaxPerProfile > 0:
   - Call store.CountByProfileSince(ctx, profile, now.Add(-rule.QuotaWindow))
   - If count >= MaxPerProfile, blocked with reason "profile quota exceeded"
5. If EscalationThreshold > 0 and userCount >= EscalationThreshold:
   - Set ShouldEscalate = true (doesn't block, just flags for notification)
6. Return allowed with counts and escalation flag

**Tests in breakglass/checker_test.go:**
- TestCheckRateLimit_NilPolicy (returns allowed)
- TestCheckRateLimit_NoMatchingRule (returns allowed)
- TestCheckRateLimit_CooldownBlocked (recent event blocks)
- TestCheckRateLimit_CooldownElapsed (after cooldown passes, allowed)
- TestCheckRateLimit_UserQuotaExceeded (too many events by user)
- TestCheckRateLimit_ProfileQuotaExceeded (too many events on profile)
- TestCheckRateLimit_EscalationFlagged (threshold met, still allowed but flagged)
- TestCheckRateLimit_AllChecksPass (allowed with correct counts)
  </action>
  <verify>go test ./breakglass/... -run "CheckRateLimit" -v</verify>
  <done>CheckRateLimit function works correctly with all rate limiting scenarios</done>
</task>

<task type="auto">
  <name>Task 2: Integrate rate limiting into breakglass CLI command</name>
  <files>cli/breakglass.go, cli/breakglass_test.go</files>
  <action>
Wire rate limiting into break-glass CLI command following existing patterns:

**Add to BreakGlassCommandInput:**
```go
// RateLimitPolicy is an optional policy for rate limiting break-glass invocations.
// If nil, no rate limiting is enforced.
RateLimitPolicy *breakglass.RateLimitPolicy
```

**Modify BreakGlassCommand function:**
After step 6 (check for existing active break-glass) and before step 7 (build event):

```go
// 6.5 Check rate limits if policy is provided
if input.RateLimitPolicy != nil {
    result, err := breakglass.CheckRateLimit(ctx, store, input.RateLimitPolicy, username, input.ProfileName, time.Now())
    if err != nil {
        fmt.Fprintf(os.Stderr, "Failed to check rate limits: %v\n", err)
        return err
    }
    if !result.Allowed {
        errMsg := fmt.Sprintf("Break-glass rate limited: %s", result.Reason)
        if result.RetryAfter > 0 {
            errMsg += fmt.Sprintf(" (retry after %v)", result.RetryAfter.Round(time.Second))
        }
        fmt.Fprintf(os.Stderr, "%s\n", errMsg)
        return errors.New("rate limit exceeded")
    }
    // If escalation threshold reached, notify with elevated severity
    if result.ShouldEscalate && input.Notifier != nil {
        // Note: escalation notification will be handled in notification - defer to Phase 31 pattern
        fmt.Fprintf(os.Stderr, "Warning: break-glass usage approaching escalation threshold\n")
    }
}
```

**Add tests in cli/breakglass_test.go:**
- TestBreakGlassCommand_RateLimitBlocked_Cooldown (blocked with retry after message)
- TestBreakGlassCommand_RateLimitBlocked_Quota (blocked with quota exceeded)
- TestBreakGlassCommand_RateLimitAllowed (passes rate check, creates event)
- TestBreakGlassCommand_NilRateLimitPolicy (no rate limiting, existing behavior preserved)

Use mock store that implements the new Count and GetLast methods.
  </action>
  <verify>go test ./cli/... -run "BreakGlass" -v</verify>
  <done>Break-glass CLI enforces rate limits with clear error messages and retry hints</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go test ./breakglass/... -v passes all tests
- [ ] go test ./cli/... -run BreakGlass -v passes all tests
- [ ] go build ./... succeeds
- [ ] Rate limiting blocks correctly with clear messages
- [ ] Retry-after hints are provided for cooldown blocks
- [ ] Nil policy preserves existing behavior (backward compatible)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- CheckRateLimit enforces cooldowns and quotas
- CLI provides clear feedback on rate limit blocks
- Backward compatible with nil RateLimitPolicy
  </success_criteria>

<output>
After completion, create `.planning/phases/33-rate-limiting/33-02-SUMMARY.md`
</output>
