---
phase: 33-rate-limiting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - breakglass/ratelimit.go
  - breakglass/ratelimit_test.go
  - breakglass/store.go
  - breakglass/dynamodb.go
  - breakglass/dynamodb_test.go
autonomous: true
---

<objective>
Define rate limiting types, validation, and store interface extensions for break-glass abuse prevention.

Purpose: Establish the schema and storage layer for cooldowns, quotas, and escalation thresholds that prevent break-glass abuse while allowing legitimate emergency access.
Output: RateLimitPolicy types with validation, CountSince store methods for quota checking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries - Phase 32 completed break-glass review commands
@.planning/phases/32-post-incident-review/32-02-SUMMARY.md

# Existing patterns to follow
@breakglass/types.go
@breakglass/store.go
@breakglass/dynamodb.go
@policy/approval.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limit types with validation</name>
  <files>breakglass/ratelimit.go, breakglass/ratelimit_test.go</files>
  <action>
Create rate limiting schema following ApprovalPolicy pattern from policy/approval.go:

**RateLimitPolicy struct:**
- Version string (for compatibility)
- Rules []RateLimitRule

**RateLimitRule struct:**
- Name string (rule identifier for logging)
- Profiles []string (empty = all profiles, follows existing wildcard pattern)
- Cooldown time.Duration (minimum time between break-glass events per user+profile)
- MaxPerUser int (max events per user within QuotaWindow)
- MaxPerProfile int (max events per profile within QuotaWindow)
- QuotaWindow time.Duration (time window for quota counting, e.g., 24h)
- EscalationThreshold int (if user exceeds this count, escalate notification - 0 = no escalation)

**Validation rules (Validate() method on RateLimitPolicy):**
- At least one rule required
- Each rule must have Name
- Cooldown must be >= 0 (0 = no cooldown)
- MaxPerUser must be >= 0 (0 = no user quota)
- MaxPerProfile must be >= 0 (0 = no profile quota)
- QuotaWindow must be > 0 if MaxPerUser > 0 or MaxPerProfile > 0
- At least one limit must be set (Cooldown > 0, MaxPerUser > 0, or MaxPerProfile > 0)

**Helper functions:**
- FindRateLimitRule(policy *RateLimitPolicy, profile string) *RateLimitRule
- containsOrEmpty helper already exists in policy package, reuse pattern

**Tests in breakglass/ratelimit_test.go:**
- TestRateLimitPolicy_Validate (valid policy, empty rules, missing name, no limits set, invalid quota window)
- TestFindRateLimitRule (matching profile, wildcard, no match)
  </action>
  <verify>go test ./breakglass/... -run "RateLimit" -v</verify>
  <done>RateLimitPolicy and RateLimitRule types exist with validation, FindRateLimitRule works correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add CountSince methods to Store interface and DynamoDB</name>
  <files>breakglass/store.go, breakglass/dynamodb.go, breakglass/dynamodb_test.go</files>
  <action>
Extend Store interface with count methods for rate limiting:

**Add to Store interface (breakglass/store.go):**
```go
// CountByInvokerSince counts events from a specific user since the given time.
// Used for per-user quota checking in rate limiting.
CountByInvokerSince(ctx context.Context, invoker string, since time.Time) (int, error)

// CountByProfileSince counts events for a specific profile since the given time.
// Used for per-profile quota checking in rate limiting.
CountByProfileSince(ctx context.Context, profile string, since time.Time) (int, error)

// GetLastByInvokerAndProfile returns the most recent event for a user+profile combination.
// Returns nil, nil if no events found. Used for cooldown checking.
GetLastByInvokerAndProfile(ctx context.Context, invoker, profile string) (*BreakGlassEvent, error)
```

**Implement in DynamoDBStore (breakglass/dynamodb.go):**
- CountByInvokerSince: Query gsi-invoker with invoker key, filter created_at >= since, return count
- CountByProfileSince: Query gsi-profile with profile key, filter created_at >= since, return count
- GetLastByInvokerAndProfile: Query gsi-invoker with invoker key, filter profile, limit 1, ScanIndexForward=false

Use Select: COUNT for count queries to minimize data transfer. Filter expression: "created_at >= :since".

**Tests in breakglass/dynamodb_test.go:**
- TestDynamoDBStore_CountByInvokerSince (multiple events, filter works, empty result)
- TestDynamoDBStore_CountByProfileSince (multiple events, filter works, empty result)
- TestDynamoDBStore_GetLastByInvokerAndProfile (returns newest, no events returns nil)
  </action>
  <verify>go test ./breakglass/... -run "Count|GetLast" -v</verify>
  <done>Store interface has CountByInvokerSince, CountByProfileSince, GetLastByInvokerAndProfile methods with DynamoDB implementation</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go test ./breakglass/... -v passes all tests
- [ ] go build ./... succeeds
- [ ] RateLimitPolicy validates correctly
- [ ] Store interface has count methods
- [ ] DynamoDB implements count queries efficiently (SELECT COUNT)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Rate limit types follow existing policy schema patterns
- Store count methods use efficient DynamoDB queries
  </success_criteria>

<output>
After completion, create `.planning/phases/33-rate-limiting/33-01-SUMMARY.md`
</output>
