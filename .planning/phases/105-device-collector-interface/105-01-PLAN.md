---
phase: 105-device-collector-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [device/collector.go, device/collector_test.go]
autonomous: true
---

<objective>
Define abstract Collector interface for collecting device posture from multiple sources.

Purpose: Establishes the contract for device posture collection, enabling Phase 106 (local collection) and future MDM/EDR integrations to implement the same interface.
Output: Collector interface, MultiCollector for composition, NoopCollector for testing, and CollectorConfig types.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/104-device-fingerprint-schema/104-01-SUMMARY.md

@device/types.go
@notification/notifier.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Collector interface and implementations</name>
  <files>device/collector.go</files>
  <action>
Create device/collector.go with:

1. **Collector interface** - returns *DevicePosture from collection:
   ```go
   type Collector interface {
       // Collect gathers device posture claims from this collector source.
       // Returns error if collection fails (permission denied, service unavailable, etc.).
       Collect(ctx context.Context) (*DevicePosture, error)

       // Name returns a human-readable name for this collector (e.g., "local", "jamf-mdm").
       Name() string
   }
   ```

2. **CollectorError** - structured error for collection failures:
   ```go
   type CollectorError struct {
       Collector string // Name of the collector that failed
       Err       error  // Underlying error
   }
   ```
   Implement Error() and Unwrap() methods for error chain compatibility.

3. **MultiCollector** - composes collectors with merge semantics (follows MultiNotifier pattern):
   - Takes multiple Collectors
   - Collects from all, merges results into single DevicePosture
   - Uses first non-nil value for each field (first collector wins)
   - Aggregates errors via errors.Join()
   - Returns merged result even if some collectors fail (partial posture)

4. **NoopCollector** - returns empty DevicePosture with StatusUnknown:
   - Useful for testing and when collection is disabled
   - Always succeeds with minimal posture

5. **CollectorConfig** - configuration for collector initialization:
   ```go
   type CollectorConfig struct {
       // EnableLocal enables local posture collection (disk encryption, firewall, OS).
       EnableLocal bool `json:"enable_local"`

       // DeviceID allows providing a persistent device ID instead of generating new.
       // If empty, NewDeviceID() is called.
       DeviceID string `json:"device_id,omitempty"`

       // CollectorVersion is the version string for posture reports.
       CollectorVersion string `json:"collector_version,omitempty"`
   }
   ```

Follow these patterns from the codebase:
- notification/notifier.go MultiNotifier pattern for composition
- context.Context as first parameter for async operations
- Sentinel errors (var ErrX = errors.New()) for expected failures
- GoDoc comments on all exported types and methods

Add sentinel errors:
```go
var (
    // ErrCollectionFailed is returned when posture collection fails.
    ErrCollectionFailed = errors.New("device posture collection failed")

    // ErrCollectionTimeout is returned when collection exceeds context deadline.
    ErrCollectionTimeout = errors.New("device posture collection timed out")
)
```
  </action>
  <verify>File exists with all types: Collector interface, CollectorError, MultiCollector, NoopCollector, CollectorConfig, sentinel errors</verify>
  <done>device/collector.go contains complete interface and implementation types with GoDoc comments</done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for collector types</name>
  <files>device/collector_test.go</files>
  <action>
Create device/collector_test.go with table-driven tests following the patterns in device/types_test.go:

1. **TestNoopCollector** - verify NoopCollector behavior:
   - Returns DevicePosture with StatusUnknown
   - DeviceID is valid 32-char hex
   - CollectedAt is set
   - No error returned
   - Name() returns "noop"

2. **TestMultiCollector_SingleCollector** - single collector passes through:
   - One collector → returns its result
   - Error from collector → returns error with result

3. **TestMultiCollector_MergeOrder** - first non-nil wins:
   - Create mock collectors with different field values
   - First collector's DiskEncrypted = true, second's = false
   - Merged result has DiskEncrypted = true (first wins)
   - Test with nil values to confirm nil doesn't override non-nil

4. **TestMultiCollector_PartialFailure** - handles collector errors:
   - First collector succeeds with partial data
   - Second collector fails with error
   - Result contains partial data AND joined error
   - Verify errors.Is() works with joined error

5. **TestMultiCollector_AllFail** - all collectors fail:
   - All collectors return errors
   - Result is minimal DevicePosture (generated ID, unknown status)
   - Error contains all collector errors joined

6. **TestCollectorError** - error formatting:
   - Error() returns formatted string with collector name
   - Unwrap() returns underlying error
   - errors.Is() works through the chain

7. **TestCollectorConfig_Validation** - config edge cases:
   - Empty DeviceID → generates new
   - Provided DeviceID → uses as-is
   - Invalid DeviceID → still works (validation at use time)

Create a mock collector for testing:
```go
type mockCollector struct {
    name    string
    posture *DevicePosture
    err     error
}

func (m *mockCollector) Collect(ctx context.Context) (*DevicePosture, error) {
    return m.posture, m.err
}

func (m *mockCollector) Name() string {
    return m.name
}
```

Use table-driven tests with descriptive names matching device/types_test.go style.
  </action>
  <verify>go test ./device/... -run Collector passes all tests</verify>
  <done>All collector tests pass with >90% coverage on collector.go</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] device/collector.go exists with Collector interface, MultiCollector, NoopCollector, CollectorConfig
- [ ] device/collector_test.go exists with comprehensive tests
- [ ] All tests pass: `go test ./device/...`
- [ ] No linting errors in new files
</verification>

<success_criteria>
- Collector interface defined with Collect(ctx) and Name() methods
- MultiCollector merges results from multiple collectors (first non-nil wins)
- NoopCollector provides testing/disabled fallback
- CollectorError provides structured error handling
- All types follow existing codebase patterns (MultiNotifier, session.Store)
- Comprehensive tests with table-driven structure
</success_criteria>

<output>
After completion, create `.planning/phases/105-device-collector-interface/105-01-SUMMARY.md`
</output>
