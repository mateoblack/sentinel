---
phase: 106-local-device-collector
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [device/local_linux.go, device/local_linux_test.go]
autonomous: true
---

<objective>
Implement Linux posture collection for LocalCollector.

Purpose: Enable device posture collection on Linux by detecting disk encryption (LUKS), OS version, and firewall status from local system commands.
Output: Linux-specific implementation with build tag for LocalCollector.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/105-device-collector-interface/105-01-SUMMARY.md

# Source files:
@device/collector.go
@device/types.go
@device/local.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Linux posture collection</name>
  <files>device/local_linux.go</files>
  <action>
Create device/local_linux.go with build tag `//go:build linux`:

1. collectDiskEncryption(runner CommandRunner) (*bool, error):
   - Run: `lsblk -f -o FSTYPE` to get filesystem types
   - Look for "crypto_LUKS" in output
   - Return *true if LUKS found on any device
   - Return *false if no LUKS (system is unencrypted)
   - Return nil, error if command fails
   - Alternative: Check `/proc/crypto` for dm-crypt, or use `dmsetup table --target crypt`

2. collectFirewallStatus(runner CommandRunner) (*bool, error):
   - Linux has multiple firewall options (iptables, nftables, ufw, firewalld)
   - Strategy: Check for common firewall managers in order:
     a. ufw: `ufw status` - look for "Status: active"
     b. firewalld: `systemctl is-active firewalld` - returns "active"
     c. iptables: `iptables -L -n 2>/dev/null | grep -c "^Chain"` - >3 chains means rules exist
   - Return *true if any active firewall found
   - Return *false if no active firewall detected
   - Return nil, error only if all checks fail to execute

3. collectOSInfo(runner CommandRunner) (string, string, error):
   - OSType is always "linux" (runtime.GOOS)
   - Read /etc/os-release for VERSION_ID or VERSION
   - Fallback: `uname -r` for kernel version
   - Return "linux", version, nil on success
   - Return "linux", "", error if all methods fail

IMPORTANT: Linux is diverse - prioritize common distributions (Ubuntu, Debian, RHEL/CentOS, Fedora). Return partial data if some checks fail rather than failing completely.
  </action>
  <verify>gofmt -l device/local_linux.go returns empty (properly formatted)</verify>
  <done>Linux posture collection for LUKS encryption, firewall (ufw/firewalld/iptables), and OS version</done>
</task>

<task type="auto">
  <name>Task 2: Add Linux-specific tests</name>
  <files>device/local_linux_test.go</files>
  <action>
Create device/local_linux_test.go with build tag `//go:build linux`:

Test cases using MockCommandRunner (from local_test.go):

1. LUKS detection tests:
   - Test_Linux_collectDiskEncryption_LUKS: lsblk shows crypto_LUKS → true
   - Test_Linux_collectDiskEncryption_NoEncryption: No LUKS in lsblk output → false
   - Test_Linux_collectDiskEncryption_Error: lsblk fails → nil, error

2. Firewall detection tests:
   - Test_Linux_collectFirewallStatus_UFW: ufw status active → true
   - Test_Linux_collectFirewallStatus_Firewalld: firewalld active → true
   - Test_Linux_collectFirewallStatus_NoFirewall: All checks return inactive → false
   - Test_Linux_collectFirewallStatus_Error: All commands fail → nil, error

3. OS info tests:
   - Test_Linux_collectOSInfo_OsRelease: /etc/os-release parsed correctly
   - Test_Linux_collectOSInfo_Uname: Fallback to uname -r works
   - Test_Linux_collectOSInfo_Error: All methods fail → linux, "", error

Use realistic command output samples from actual Linux systems.
  </action>
  <verify>gofmt -l device/local_linux_test.go returns empty (properly formatted)</verify>
  <done>Linux-specific tests for LUKS, firewall, and OS detection with realistic output samples</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] gofmt -l device/local_linux*.go returns empty
- [ ] Build tag `//go:build linux` present on both files
- [ ] All three collection methods implemented with error handling
- [ ] Tests cover success, partial failure, and error cases
</verification>

<success_criteria>

- All tasks completed
- Linux implementation with LUKS detection
- Multi-firewall strategy (ufw, firewalld, iptables)
- OS version from /etc/os-release with uname fallback
- Comprehensive tests with mock output
</success_criteria>

<output>
After completion, create `.planning/phases/106-local-device-collector/106-02-SUMMARY.md`
</output>
