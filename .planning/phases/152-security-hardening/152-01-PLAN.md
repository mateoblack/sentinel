---
phase: 152-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [deploy/ssm.go, cli/ssm.go, deploy/ssm_test.go, cli/ssm_test.go]
autonomous: true
---

<objective>
Replace SSM backup feature with encrypted backup using AWS KMS to prevent unencrypted secrets on disk.

Purpose: SEC-01/SEC-05 - Current SSM backup writes decrypted parameter values (including SecureString secrets) to plaintext JSON files. This creates risk of local credential exposure if backup files are accessed by unauthorized users.

Output: SSM backup feature encrypts backup files with KMS before writing to disk. Restore operation decrypts with KMS. Backup files contain ciphertext, not plaintext values.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing SSM backup implementation:
@deploy/ssm.go
@cli/ssm.go

# Pattern for KMS operations (see policy signing):
@policy/signing.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add KMS encryption to SSM backup in deploy package</name>
  <files>deploy/ssm.go</files>
  <action>
Modify deploy/ssm.go to encrypt backup data with KMS:

1. **Add KMS key ID field to SSMHardener**:
   ```go
   type SSMHardener struct {
       client    ssmHardenAPI
       kmsClient kmsEncryptAPI  // New: KMS client for encryption
       kmsKeyID  string         // New: KMS key ID for backup encryption
   }
   ```

2. **Add kmsEncryptAPI interface**:
   ```go
   type kmsEncryptAPI interface {
       Encrypt(ctx context.Context, params *kms.EncryptInput, optFns ...func(*kms.Options)) (*kms.EncryptOutput, error)
       Decrypt(ctx context.Context, params *kms.DecryptInput, optFns ...func(*kms.Options)) (*kms.DecryptOutput, error)
   }
   ```

3. **Update NewSSMHardener** to accept optional KMS key:
   ```go
   func NewSSMHardener(cfg aws.Config, kmsKeyID string) *SSMHardener
   ```
   - If kmsKeyID is non-empty, create KMS client
   - If empty, backups will fail with clear error (no unencrypted backups allowed)

4. **Update ParameterBackup struct** to store ciphertext:
   ```go
   type ParameterBackup struct {
       Name           string    `json:"name"`
       Type           string    `json:"type"`
       EncryptedValue string    `json:"encrypted_value"`  // Base64-encoded KMS ciphertext
       Version        int64     `json:"version"`
       BackupAt       time.Time `json:"backup_at"`
       KMSKeyID       string    `json:"kms_key_id"`  // Track which key was used
   }
   ```
   - Remove `Value` field entirely - no plaintext storage
   - `EncryptedValue` is base64-encoded KMS ciphertext

5. **Update BackupParameters method**:
   - After getting parameter value, call kms.Encrypt with the value
   - Store base64-encoded ciphertext in EncryptedValue
   - If kmsKeyID is empty, return error: "KMS key required for backup encryption (SEC-05)"

6. **Update RestoreParameters method**:
   - Read EncryptedValue from backup file
   - Call kms.Decrypt to get plaintext value
   - Use decrypted value in PutParameter call

7. **Update LoadBackup function** to handle both formats:
   - If `encrypted_value` field present: new encrypted format
   - If `value` field present: return error "Legacy unencrypted backup format not supported. Re-run backup with KMS key."

**AVOID:**
- Don't store plaintext values anywhere (not even temporarily in struct)
- Don't allow fallback to unencrypted backup
- Don't use hardcoded KMS key - must be provided by caller
  </action>
  <verify>go build ./deploy/... compiles without errors</verify>
  <done>SSMHardener encrypts backup data with KMS, refuses to create unencrypted backups</done>
</task>

<task type="auto">
  <name>Task 2: Update CLI ssm commands to require KMS key</name>
  <files>cli/ssm.go</files>
  <action>
Update cli/ssm.go to require KMS key for backup:

1. **Add --kms-key flag to backup command**:
   ```go
   backupCmd.Flag("kms-key", "KMS key ID or ARN for encrypting backup (required)").
       Required().
       StringVar(&backupInput.KMSKeyID)
   ```
   - Flag is REQUIRED - no unencrypted backups allowed
   - Accepts key ID, key ARN, or alias ARN

2. **Add --kms-key flag to restore command** (optional, for explicit key):
   ```go
   restoreCmd.Flag("kms-key", "KMS key ID for decryption (optional, uses key from backup if not specified)").
       StringVar(&restoreInput.KMSKeyID)
   ```
   - If not provided, uses KMSKeyID stored in backup file
   - If provided, overrides (useful for key rotation scenarios)

3. **Update SSMBackupCommandInput**:
   ```go
   type SSMBackupCommandInput struct {
       Parameters []string
       Prefix     string
       OutputDir  string
       KMSKeyID   string  // NEW: Required for backup encryption
       JSONOutput bool
       AWSProfile string
       Region     string
       Hardener   *deploy.SSMHardener
       // ...
   }
   ```

4. **Update SSMBackupCommand**:
   - Pass kmsKeyID to NewSSMHardener
   - Update human-readable output to show KMS key used
   - Update JSON output to include kms_key_id

5. **Update SSMRestoreCommand**:
   - Pass kmsKeyID (from flag or backup file) to hardener
   - If backup file has no KMSKeyID and flag not provided, error clearly

6. **Update help text** to explain KMS requirement:
   "Backup files are encrypted with KMS to protect secrets at rest (SEC-05)."

**AVOID:**
- Don't make --kms-key optional for backup
- Don't silently fall back to unencrypted
  </action>
  <verify>go build ./cli/... compiles without errors</verify>
  <done>CLI ssm backup requires --kms-key, restore uses KMS decryption</done>
</task>

<task type="auto">
  <name>Task 3: Update tests for encrypted backup/restore</name>
  <files>deploy/ssm_test.go, cli/ssm_test.go</files>
  <action>
Update tests to cover encrypted backup functionality:

1. **deploy/ssm_test.go**:
   - Add mock kmsEncryptAPI implementation
   - Test BackupParameters encrypts values with KMS
   - Test BackupParameters fails if no KMS key provided
   - Test RestoreParameters decrypts values with KMS
   - Test LoadBackup rejects legacy unencrypted format
   - Test KMS error handling (encrypt failure, decrypt failure)

2. **cli/ssm_test.go**:
   - Update existing tests to provide mock KMS key
   - Test that --kms-key flag is required for backup
   - Test restore uses KMS key from backup file if not specified
   - Test restore uses explicit --kms-key if provided
   - Test error messages are clear for:
     - Missing KMS key on backup
     - KMS permission errors
     - Legacy backup format rejection

3. **Add security regression test**:
   - Test that backup files never contain plaintext Value field
   - Test that EncryptedValue is not the same as original value (actually encrypted)

**Test patterns to follow from jamf_test.go for mock injection.**
  </action>
  <verify>go test ./deploy/... ./cli/... -run SSM -v passes all tests</verify>
  <done>All SSM backup/restore tests pass with KMS encryption</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./deploy/... ./cli/...` succeeds
- [ ] `go test ./deploy/... -run SSM -v` passes
- [ ] `go test ./cli/... -run SSM -v` passes
- [ ] `go vet ./deploy/... ./cli/...` reports no issues
- [ ] Backup files contain `encrypted_value` not `value`
- [ ] Backup without --kms-key flag fails with clear error
</verification>

<success_criteria>

- SSM backup feature requires KMS key for encryption
- Backup files contain only ciphertext (no plaintext secrets)
- Restore operation decrypts with KMS
- Legacy unencrypted backups are rejected with clear error
- All existing tests updated and passing
</success_criteria>

<output>
After completion, create `.planning/phases/152-security-hardening/152-01-SUMMARY.md`
</output>
