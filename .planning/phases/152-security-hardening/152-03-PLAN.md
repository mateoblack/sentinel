---
phase: 152-security-hardening
plan: 03
type: execute
wave: 1
depends_on: []
files_modified: [cli/credentials.go, cli/sentinel_exec.go, cli/policy.go, cli/policy_sign.go, cli/config.go]
autonomous: true
---

<objective>
Audit and harden file permissions across CLI commands to prevent unauthorized access.

Purpose: SEC-03 - Some file operations use overly permissive modes (0644) for files that may contain sensitive data like policy files, signatures, or logs. Enforce restrictive permissions (0600) for all sensitive files.

Output: All sensitive file writes use 0600 permissions. Config/non-sensitive files remain 0644/0755. File permission constants documented and consistent.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Files with WriteFile operations:
@cli/credentials.go
@cli/sentinel_exec.go
@cli/policy.go
@cli/policy_sign.go
@cli/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define file permission constants and update sensitive file writes</name>
  <files>cli/credentials.go, cli/sentinel_exec.go, cli/policy.go, cli/policy_sign.go</files>
  <action>
Create consistent file permission constants and apply to all sensitive file writes:

1. **Add permission constants to cli/global.go** (or create cli/permissions.go):
   ```go
   // File permission constants for security hardening (SEC-03)
   const (
       // SensitiveFileMode is for files that may contain secrets or sensitive data
       // (policy files, signatures, encrypted backups, etc.)
       SensitiveFileMode = 0600

       // LogFileMode is for audit logs (readable by owner, no write for group/other)
       LogFileMode = 0640

       // ConfigFileMode is for non-sensitive configuration files
       ConfigFileMode = 0644

       // SensitiveDirMode is for directories containing sensitive files
       SensitiveDirMode = 0700

       // ConfigDirMode is for general configuration directories
       ConfigDirMode = 0755
   )
   ```

2. **Update cli/credentials.go** (line ~135):
   ```go
   // Before: os.OpenFile(input.LogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
   // After:
   f, err := os.OpenFile(input.LogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, LogFileMode)
   ```
   Log files may contain decision details - use 0640.

3. **Update cli/sentinel_exec.go** (line ~267):
   ```go
   // Before: os.OpenFile(input.LogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
   // After:
   f, err := os.OpenFile(input.LogFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, LogFileMode)
   ```
   Same pattern as credentials.go.

4. **Update cli/policy.go** (line ~314):
   ```go
   // Before: os.WriteFile(input.OutputFile, yamlData, 0644)
   // After:
   if err := os.WriteFile(input.OutputFile, yamlData, SensitiveFileMode); err != nil {
   ```
   Policy files may contain user lists and profile mappings - use 0600.

5. **Update cli/policy_sign.go** (line ~209):
   ```go
   // Before: os.WriteFile(input.OutputFile, outputJSON, 0644)
   // After:
   if err := os.WriteFile(input.OutputFile, outputJSON, SensitiveFileMode); err != nil {
   ```
   Signature files are security artifacts - use 0600.

6. **Add comments** explaining why each permission level is used:
   ```go
   // Use SensitiveFileMode (0600) for policy output - may contain user/profile mappings (SEC-03)
   ```

**AVOID:**
- Don't change permissions for config generation (those stay 0644)
- Don't change directory permissions that break functionality
- Don't use 0600 for files that legitimately need group read (logs)
  </action>
  <verify>go build ./cli/... compiles without errors</verify>
  <done>Sensitive file writes use 0600, log files use 0640, constants defined</done>
</task>

<task type="auto">
  <name>Task 2: Keep config generation files at appropriate permissions</name>
  <files>cli/config.go</files>
  <action>
Review and document config.go file permissions:

1. **Review cli/config.go line ~457 and ~478**:
   - Directory creation: `os.MkdirAll(dir, 0755)` - OK for .aws directory
   - Config files: `os.WriteFile(path, []byte(f.content), 0644)` - OK for aws config

2. **Add comment explaining rationale**:
   ```go
   // ConfigDirMode (0755) for ~/.aws directory - standard AWS config location
   if err := os.MkdirAll(dir, ConfigDirMode); err != nil {
   ```

   ```go
   // ConfigFileMode (0644) for AWS config files - these contain profile names,
   // not credentials (credentials are in keyring). 0644 matches aws-cli default.
   if err := os.WriteFile(path, []byte(f.content), ConfigFileMode); err != nil {
   ```

3. **Document the distinction** in comment:
   ```go
   // Note: AWS config files (~/.aws/config) use 0644 because they contain
   // profile configuration, not credentials. Credentials are stored in the
   // system keyring, not in files. This matches aws-cli behavior.
   ```

This task is mostly documentation to confirm the current permissions are appropriate.

**AVOID:**
- Don't change ~/.aws/config permissions (would break compatibility)
- Don't add unnecessary restrictions that break interoperability
  </action>
  <verify>go build ./cli/... compiles without errors</verify>
  <done>Config generation uses appropriate permissions with documentation</done>
</task>

<task type="auto">
  <name>Task 3: Add file permission tests</name>
  <files>cli/policy_test.go, cli/policy_sign_test.go</files>
  <action>
Add tests to verify file permissions are applied correctly:

1. **Add test in cli/policy_test.go** for policy pull --output:
   ```go
   func TestPolicyPullCommand_OutputFilePermissions(t *testing.T) {
       // Create temp dir
       // Run policy pull with --output flag
       // Verify output file has 0600 permissions
       info, err := os.Stat(outputFile)
       require.NoError(t, err)
       require.Equal(t, os.FileMode(0600), info.Mode().Perm(),
           "Policy output file should have 0600 permissions (SEC-03)")
   }
   ```

2. **Add test in cli/policy_sign_test.go** for signature output:
   ```go
   func TestPolicySignCommand_OutputFilePermissions(t *testing.T) {
       // Create temp dir
       // Run policy sign with --output flag
       // Verify output file has 0600 permissions
       info, err := os.Stat(outputFile)
       require.NoError(t, err)
       require.Equal(t, os.FileMode(0600), info.Mode().Perm(),
           "Signature output file should have 0600 permissions (SEC-03)")
   }
   ```

3. **Add test for log file permissions** (if test infrastructure allows):
   - May need to verify in integration tests or skip if impractical

4. **Ensure tests run on Linux/macOS** (Windows has different permission model):
   ```go
   if runtime.GOOS == "windows" {
       t.Skip("File permissions test not applicable on Windows")
   }
   ```

**AVOID:**
- Don't create flaky tests that fail on permission edge cases
- Don't test permissions on temp files if OS applies umask
  </action>
  <verify>go test ./cli/... -run Permission -v passes</verify>
  <done>File permission tests verify 0600 for sensitive outputs</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./cli/...` succeeds
- [ ] `go test ./cli/... -v` passes
- [ ] `go vet ./cli/...` reports no issues
- [ ] grep confirms no remaining 0644 for sensitive files (policy, signatures)
- [ ] Constants defined in one place and used consistently
</verification>

<success_criteria>

- File permission constants defined and documented
- Policy output files use 0600
- Signature output files use 0600
- Log files use 0640 (owner read/write, group read)
- Config files documented as intentionally 0644
- Permission tests added and passing
</success_criteria>

<output>
After completion, create `.planning/phases/152-security-hardening/152-03-SUMMARY.md`
</output>
