---
phase: 152-security-hardening
plan: 04
type: execute
wave: 1
depends_on: []
files_modified: [validate/fuzz_test.go, policy/fuzz_test.go, identity/fuzz_test.go, device/fuzz_test.go]
autonomous: true
---

<objective>
Add fuzz tests for CLI inputs to detect injection vulnerabilities and edge cases.

Purpose: SEC-04 - Fuzz testing can discover input handling bugs that manual testing misses. Target high-risk input parsing: profile names, policy YAML, identity/ARN strings, and device IDs.

Output: Fuzz tests for 4 input categories that can be run with `go test -fuzz`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Input validation functions:
@validate/profile.go
@policy/schema.go
@identity/parse.go
@device/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fuzz tests for profile name validation</name>
  <files>validate/fuzz_test.go</files>
  <action>
Create fuzz tests for profile name validation:

```go
// validate/fuzz_test.go
package validate

import (
    "testing"
    "unicode/utf8"
)

// FuzzValidateProfileName tests profile name validation with random inputs
// to catch injection vulnerabilities and edge cases.
//
// Run: go test -fuzz=FuzzValidateProfileName -fuzztime=30s ./validate/...
func FuzzValidateProfileName(f *testing.F) {
    // Seed corpus with known edge cases
    seeds := []string{
        "",                          // empty
        "valid-profile",             // normal
        "profile_with_underscore",   // underscore
        "Profile123",                // numbers
        "a",                         // single char
        strings.Repeat("a", 100),    // long
        strings.Repeat("a", 1000),   // very long
        "profile; rm -rf /",         // command injection attempt
        "profile\ncommand",          // newline injection
        "profile`id`",               // backtick injection
        "profile$(whoami)",          // subshell injection
        "profile\x00null",           // null byte
        "../../../etc/passwd",       // path traversal
        "profile\t\ttabs",           // tabs
        "profile\r\nCRLF",           // CRLF injection
        "profile with spaces",       // spaces
        "日本語プロファイル",          // unicode
        "\xff\xfe",                  // invalid UTF-8
    }

    for _, seed := range seeds {
        f.Add(seed)
    }

    f.Fuzz(func(t *testing.T, input string) {
        // Call the validation function
        err := ValidateProfileName(input)

        // If validation passes, verify it's actually safe
        if err == nil {
            // Must be valid UTF-8
            if !utf8.ValidString(input) {
                t.Errorf("ValidateProfileName accepted invalid UTF-8: %q", input)
            }

            // Must not contain shell metacharacters
            shellMetachars := []string{";", "`", "$", "(", ")", "|", "&", "\n", "\r", "\x00"}
            for _, meta := range shellMetachars {
                if strings.Contains(input, meta) {
                    t.Errorf("ValidateProfileName accepted shell metachar %q in: %q", meta, input)
                }
            }

            // Must not be empty after validation
            if len(input) == 0 {
                t.Error("ValidateProfileName accepted empty string")
            }
        }

        // Function should never panic regardless of input
        // (test framework catches panics)
    })
}

// FuzzSanitizeProfileName tests the sanitization function
func FuzzSanitizeProfileName(f *testing.F) {
    // Similar seeds as above
    f.Add("valid-profile")
    f.Add("profile; rm -rf /")
    f.Add("profile\x00null")

    f.Fuzz(func(t *testing.T, input string) {
        sanitized := SanitizeProfileName(input)

        // Sanitized output should always be safe
        if sanitized != "" {
            // Should not contain dangerous chars
            dangerous := []string{";", "`", "$", "(", ")", "|", "&", "\n", "\r", "\x00", ".."}
            for _, d := range dangerous {
                if strings.Contains(sanitized, d) {
                    t.Errorf("SanitizeProfileName output contains %q: input=%q output=%q", d, input, sanitized)
                }
            }
        }
    })
}
```

**Key behaviors to verify:**
- Never panic on any input
- Never accept shell metacharacters
- Never accept null bytes
- Never accept newlines/CRLF
- Reject invalid UTF-8 or sanitize it

**AVOID:**
- Don't make fuzz tests that take too long to run
- Don't test internal functions not exposed to CLI input
  </action>
  <verify>go test -fuzz=FuzzValidateProfileName -fuzztime=10s ./validate/... passes without finding issues</verify>
  <done>Profile name fuzz tests created and pass initial corpus</done>
</task>

<task type="auto">
  <name>Task 2: Add fuzz tests for policy YAML parsing</name>
  <files>policy/fuzz_test.go</files>
  <action>
Create fuzz tests for policy YAML parsing:

```go
// policy/fuzz_test.go
package policy

import (
    "testing"
)

// FuzzParsePolicy tests policy YAML parsing with random inputs
// to catch parsing bugs and edge cases that could cause panics or crashes.
//
// Run: go test -fuzz=FuzzParsePolicy -fuzztime=60s ./policy/...
func FuzzParsePolicy(f *testing.F) {
    // Seed corpus with valid and malformed policies
    seeds := []string{
        // Valid minimal policy
        `version: "1"
rules:
  - effect: allow
    profiles: ["test"]`,

        // Empty
        "",

        // Invalid YAML
        "{{{{",

        // Deeply nested
        `version: "1"
rules:
  - effect: allow
    profiles:
      - a:
          b:
            c:
              d: deep`,

        // Very long values
        `version: "1"
rules:
  - effect: allow
    users: ["` + strings.Repeat("a", 10000) + `"]`,

        // Unicode
        `version: "1"
rules:
  - effect: allow
    users: ["用户名"]`,

        // Null bytes in YAML
        "version: \"1\"\x00rules: []",

        // YAML bombs (billion laughs style) - test parser limits
        `a: &a ["lol","lol","lol"]
b: &b [*a,*a,*a]
c: &c [*b,*b,*b]`,

        // Type coercion attempts
        `version: 1
rules:
  - effect: yes
    profiles: true`,
    }

    for _, seed := range seeds {
        f.Add(seed)
    }

    f.Fuzz(func(t *testing.T, input string) {
        // Parse should never panic
        policy, err := ParsePolicy([]byte(input))

        if err == nil && policy != nil {
            // If parsing succeeds, validate the result
            if validateErr := policy.Validate(); validateErr != nil {
                // Parsing succeeded but validation failed - that's OK
                // (invalid policy data, but no panic)
            }

            // Check rules don't have excessive data
            for _, rule := range policy.Rules {
                if len(rule.Users) > 10000 {
                    t.Errorf("ParsePolicy accepted rule with >10000 users")
                }
                if len(rule.Profiles) > 10000 {
                    t.Errorf("ParsePolicy accepted rule with >10000 profiles")
                }
            }
        }
    })
}

// FuzzValidatePolicy focuses on validation logic after successful parse
func FuzzValidatePolicy(f *testing.F) {
    // Seed with structurally valid but semantically questionable policies
    f.Add(`version: "1"
rules:
  - effect: allow
    users: []
    profiles: []`)

    f.Add(`version: "999"
rules: []`)

    f.Fuzz(func(t *testing.T, input string) {
        policy, parseErr := ParsePolicy([]byte(input))
        if parseErr != nil {
            return // Can't validate unparseable input
        }

        // Validate should never panic
        _ = policy.Validate()
    })
}
```

**Key behaviors to verify:**
- Never panic on malformed YAML
- Don't exhaust memory on YAML bombs
- Handle type coercion gracefully
- Reject excessively large inputs

**AVOID:**
- Don't add seeds that would make normal test runs slow
- Keep fuzz time reasonable in verify step
  </action>
  <verify>go test -fuzz=FuzzParsePolicy -fuzztime=10s ./policy/... passes</verify>
  <done>Policy YAML fuzz tests created and pass initial corpus</done>
</task>

<task type="auto">
  <name>Task 3: Add fuzz tests for identity/ARN parsing and device ID validation</name>
  <files>identity/fuzz_test.go, device/fuzz_test.go</files>
  <action>
Create fuzz tests for identity parsing and device ID validation:

**identity/fuzz_test.go:**
```go
package identity

import (
    "testing"
)

// FuzzParseARN tests ARN parsing with random inputs
// to catch parsing edge cases and injection attempts.
//
// Run: go test -fuzz=FuzzParseARN -fuzztime=30s ./identity/...
func FuzzParseARN(f *testing.F) {
    seeds := []string{
        // Valid ARNs
        "arn:aws:sts::123456789012:assumed-role/MyRole/session",
        "arn:aws:iam::123456789012:user/MyUser",
        "arn:aws-us-gov:iam::123456789012:user/GovUser",
        "arn:aws-cn:iam::123456789012:user/ChinaUser",
        "arn:aws-iso:iam::123456789012:user/ISOUser",
        "arn:aws-iso-b:iam::123456789012:user/ISOBUser",

        // Invalid ARNs
        "",
        "not-an-arn",
        "arn:",
        "arn:aws:",
        "arn:aws:sts:",
        "arn:aws:sts:::",

        // Injection attempts
        "arn:aws:sts::123:assumed-role/Role/session; rm -rf /",
        "arn:aws:sts::123:assumed-role/Role/session\ncommand",
        "arn:aws:sts::123:assumed-role/../../etc/passwd/session",

        // Unicode
        "arn:aws:iam::123:user/日本語",

        // Long values
        "arn:aws:iam::123:user/" + strings.Repeat("a", 10000),
    }

    for _, seed := range seeds {
        f.Add(seed)
    }

    f.Fuzz(func(t *testing.T, input string) {
        // Parse should never panic
        arn, err := ParseARN(input)

        if err == nil && arn != nil {
            // If parsing succeeds, verify extracted components are safe
            if strings.ContainsAny(arn.Resource, ";\n\r`$") {
                t.Errorf("ParseARN allowed shell chars in resource: %q", input)
            }
        }
    })
}

// FuzzExtractUsername tests username extraction from ARN
func FuzzExtractUsername(f *testing.F) {
    f.Add("arn:aws:iam::123:user/testuser")
    f.Add("arn:aws:sts::123:assumed-role/Role/session-name")
    f.Add("")

    f.Fuzz(func(t *testing.T, input string) {
        // Should never panic
        username := ExtractUsername(input)

        // Username should never contain dangerous chars
        if username != "" {
            dangerous := []string{";", "`", "$", "(", ")", "|", "&", "\n", "\r", "\x00"}
            for _, d := range dangerous {
                if strings.Contains(username, d) {
                    t.Errorf("ExtractUsername returned dangerous char %q: input=%q output=%q", d, input, username)
                }
            }
        }
    })
}
```

**device/fuzz_test.go:**
```go
package device

import (
    "testing"
)

// FuzzValidateDeviceID tests device ID validation with random inputs.
// Device IDs should be 64-char hex strings (HMAC-SHA256 output).
//
// Run: go test -fuzz=FuzzValidateDeviceID -fuzztime=30s ./device/...
func FuzzValidateDeviceID(f *testing.F) {
    seeds := []string{
        // Valid 64-char hex
        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
        "ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789",

        // Invalid
        "",
        "short",
        "0123456789abcdef", // 16 chars
        "0123456789abcdef0123456789abcdef", // 32 chars
        "ghijklmnopqrstuv", // not hex

        // Injection attempts
        "0123456789abcdef0123456789abcdef0123456789abcdef012345678; rm",
        "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abc\n",
    }

    for _, seed := range seeds {
        f.Add(seed)
    }

    f.Fuzz(func(t *testing.T, input string) {
        // Validation should never panic
        err := ValidateDeviceID(input)

        if err == nil {
            // If valid, must be exactly 64 hex chars
            if len(input) != 64 {
                t.Errorf("ValidateDeviceID accepted non-64-char string: len=%d", len(input))
            }

            // Must be valid hex
            for _, c := range input {
                if !((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')) {
                    t.Errorf("ValidateDeviceID accepted non-hex char: %q in %q", c, input)
                }
            }
        }
    })
}
```

**AVOID:**
- Don't make tests that are too slow for regular CI runs
- Fuzztime in verify should be short (10-30s)
  </action>
  <verify>go test -fuzz=FuzzParseARN -fuzztime=10s ./identity/... && go test -fuzz=FuzzValidateDeviceID -fuzztime=10s ./device/... passes</verify>
  <done>Identity and device fuzz tests created and pass initial corpus</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./validate/... -run Fuzz` runs seed corpus
- [ ] `go test ./policy/... -run Fuzz` runs seed corpus
- [ ] `go test ./identity/... -run Fuzz` runs seed corpus
- [ ] `go test ./device/... -run Fuzz` runs seed corpus
- [ ] Each fuzz test can run for 10s without finding crashes
</verification>

<success_criteria>

- Fuzz tests for profile name validation
- Fuzz tests for policy YAML parsing
- Fuzz tests for ARN/identity parsing
- Fuzz tests for device ID validation
- All fuzz tests pass initial seed corpus
- No panics or crashes found in 10s fuzz runs
</success_criteria>

<output>
After completion, create `.planning/phases/152-security-hardening/152-04-SUMMARY.md`
</output>
