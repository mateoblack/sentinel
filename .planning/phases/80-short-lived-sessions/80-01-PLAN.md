---
phase: 80-short-lived-sessions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - sentinel/server.go
  - cli/sentinel_exec.go
  - cli/sentinel_exec_test.go
  - policy/types.go
  - policy/evaluate.go
  - policy/evaluate_test.go
autonomous: true
---

<objective>
Implement short-lived session support for server mode enabling rapid credential revocation.

Purpose: In server mode, credentials should have short TTLs (default 15 minutes) so that policy changes take effect quickly. When policy denies access, the next credential refresh (within 15 minutes) will enforce the denial. This is the key enabler for real-time revocation.

Output: Server mode with default 15-minute sessions, policy-based MaxServerDuration rule constraint, and --server-duration CLI flag for explicit control.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/78-server-infrastructure/78-02-SUMMARY.md
@.planning/phases/79-server-policy-integration/79-01-SUMMARY.md

@sentinel/server.go
@cli/sentinel_exec.go
@policy/types.go
@breakglass/policy.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DefaultServerSessionDuration constant and --server-duration flag</name>
  <files>sentinel/server.go, cli/sentinel_exec.go</files>
  <action>
1. In sentinel/server.go, add a constant for default server session duration:
   ```go
   const (
       // DefaultServerSessionDuration is the default session duration in server mode.
       // Short sessions enable rapid credential revocation - policy changes take effect
       // within this window as credentials are refreshed per-request.
       DefaultServerSessionDuration = 15 * time.Minute
   )
   ```

2. In cli/sentinel_exec.go, add a new flag ServerDuration to SentinelExecCommandInput:
   ```go
   ServerDuration  time.Duration // Duration for server mode sessions (0 = use default)
   ```

3. Add the CLI flag in ConfigureSentinelExecCommand:
   ```go
   cmd.Flag("server-duration", "Session duration in server mode (default 15m for rapid revocation)").
       DurationVar(&input.ServerDuration)
   ```

4. Update the server mode branch in SentinelExecCommand to use ServerDuration:
   - If input.ServerDuration is 0, use sentinel.DefaultServerSessionDuration
   - If input.ServerDuration is set, use that value
   - Pass the resolved duration to serverConfig.SessionDuration

Why short default: 15 minutes balances security (rapid revocation) with performance (SDK caches credentials). AWS SDKs typically refresh 5 minutes before expiry, so 15-minute credentials refresh roughly every 10 minutes.
  </action>
  <verify>go build ./... succeeds (or gofmt -l verifies syntax)</verify>
  <done>DefaultServerSessionDuration constant exists, --server-duration flag added, server mode uses 15-minute default when no explicit duration</done>
</task>

<task type="auto">
  <name>Task 2: Add MaxServerDuration to policy Rule for per-rule duration limits</name>
  <files>policy/types.go, policy/evaluate.go</files>
  <action>
1. In policy/types.go, extend the Rule struct with MaxServerDuration:
   ```go
   type Rule struct {
       Name              string         `yaml:"name" json:"name"`
       Effect            Effect         `yaml:"effect" json:"effect"`
       Conditions        Condition      `yaml:"conditions" json:"conditions"`
       Reason            string         `yaml:"reason,omitempty" json:"reason,omitempty"`
       MaxServerDuration time.Duration  `yaml:"max_server_duration,omitempty" json:"max_server_duration,omitempty"`
   }
   ```

2. In policy/evaluate.go, extend the Decision struct to include the duration cap:
   ```go
   type Decision struct {
       Effect            Effect
       MatchedRule       string
       Reason            string
       MaxServerDuration time.Duration // 0 = no cap from policy
   }
   ```

3. Update the Evaluate function to populate Decision.MaxServerDuration from the matched rule:
   - When a rule matches, copy rule.MaxServerDuration to decision.MaxServerDuration
   - When no rule matches (default deny), leave MaxServerDuration as 0

Pattern follows BreakGlassPolicyRule.MaxDuration - policy rules can cap duration but 0 means no policy-imposed limit.
  </action>
  <verify>go build ./... succeeds (or gofmt -l verifies syntax)</verify>
  <done>Rule has MaxServerDuration field, Decision includes MaxServerDuration from matched rule</done>
</task>

<task type="auto">
  <name>Task 3: Apply policy-based duration capping in server credential handler</name>
  <files>sentinel/server.go</files>
  <action>
1. In server.go DefaultRoute, after policy evaluation, apply the duration cap from the Decision:

   After `decision := policy.Evaluate(loadedPolicy, policyRequest)`:
   ```go
   // Apply policy-based session duration cap (if set)
   sessionDuration := s.config.SessionDuration
   if decision.MaxServerDuration > 0 {
       if sessionDuration == 0 || sessionDuration > decision.MaxServerDuration {
           sessionDuration = decision.MaxServerDuration
           log.Printf("Capping session duration to policy max_server_duration: %v", decision.MaxServerDuration)
       }
   }
   ```

2. Update the existing break-glass duration capping to work with the already-capped sessionDuration:
   - The break-glass cap already operates on sessionDuration
   - Ensure the flow is: policy cap -> break-glass cap -> final duration
   - This means if policy says max 10m and break-glass has 5m remaining, result is 5m

3. Move the sessionDuration declaration earlier (before the deny check) so both allow and deny-with-override paths use the capped duration.
  </action>
  <verify>go build ./... succeeds (or gofmt -l verifies syntax)</verify>
  <done>Server mode applies policy MaxServerDuration cap, duration capping order is policy -> break-glass -> final</done>
</task>

<task type="auto">
  <name>Task 4: Add tests for server duration handling</name>
  <files>cli/sentinel_exec_test.go, policy/evaluate_test.go, sentinel/server_test.go</files>
  <action>
1. In cli/sentinel_exec_test.go, add tests for ServerDuration flag:
   - Test that ServerDuration field is correctly initialized from flag
   - Test that 0 value means use default

2. In policy/evaluate_test.go, add tests for MaxServerDuration:
   - TestEvaluate_MaxServerDuration: verify Decision.MaxServerDuration is populated from matched rule
   - Test with 0 (no cap) and non-zero (capped) values
   - Test that default deny has 0 MaxServerDuration

3. In sentinel/server_test.go, add tests for duration capping:
   - Test DefaultServerSessionDuration constant value (15 * time.Minute)
   - Test policy-based duration capping in credential serving
   - Test policy cap + break-glass cap interaction (smallest wins)

Test patterns follow existing tests in these files.
  </action>
  <verify>go test ./policy/... ./sentinel/... ./cli/... -run "Duration|Server" passes</verify>
  <done>Tests cover default duration, policy-based capping, flag handling, and cap interaction</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./... succeeds (or gofmt -l shows no errors if build unavailable)
- [ ] go test ./policy/... passes
- [ ] go test ./sentinel/... passes
- [ ] go test ./cli/... passes
- [ ] DefaultServerSessionDuration is 15 minutes
- [ ] --server-duration flag documented in help text
- [ ] Policy MaxServerDuration field works as expected
</verification>

<success_criteria>

- Server mode defaults to 15-minute sessions (DefaultServerSessionDuration)
- --server-duration flag allows explicit override
- Policy rules can set MaxServerDuration to cap sessions
- Duration capping order: policy cap -> break-glass cap -> final
- All tests pass
- 4 commits (one per task)
</success_criteria>

<output>
After completion, create `.planning/phases/80-short-lived-sessions/80-01-SUMMARY.md`
</output>
