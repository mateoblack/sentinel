---
phase: 99-policy-session-integration
plan: 02
type: execute
wave: 2
depends_on: ["99-01"]
files_modified: [lambda/handler.go, lambda/handler_test.go]
autonomous: true
---

<objective>
Integrate policy evaluation into Lambda handler following SentinelServer.DefaultRoute() pattern.

Purpose: Lambda TVM must evaluate Sentinel policy before issuing credentials. Policy deny blocks issuance, enforcing the core security control.
Output: Updated handler that evaluates policy, respecting CredentialMode (Lambda is treated as server mode).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/99-policy-session-integration/99-01-SUMMARY.md

Reference the policy evaluation pattern:
@sentinel/server.go (DefaultRoute lines 216-272)
@policy/evaluate.go

Lambda handler to update:
@lambda/handler.go
@lambda/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Handler struct to use TVMConfig</name>
  <files>lambda/handler.go</files>
  <action>
Update `lambda/handler.go` to integrate policy evaluation:

1. Update Handler struct to use TVMConfig:
   ```go
   type Handler struct {
       Config *TVMConfig
   }
   ```

2. Update NewHandler to accept TVMConfig:
   ```go
   func NewHandler(cfg *TVMConfig) *Handler {
       return &Handler{Config: cfg}
   }
   ```

3. Add policy evaluation in HandleRequest (after profile extraction, before VendCredentials):
   ```go
   // Build policy request - Lambda TVM acts as server mode
   policyRequest := &policy.Request{
       User:             username,  // Extracted from caller ARN
       Profile:          profile,   // From query parameter
       Time:             time.Now(),
       Mode:             policy.ModeServer,  // TVM is server-side
       SessionTableName: h.Config.SessionTableName,
   }

   // Load policy
   loadedPolicy, err := h.Config.PolicyLoader.Load(ctx, h.Config.PolicyParameter)
   if err != nil {
       log.Printf("ERROR: Failed to load policy: %v", err)
       return errorResponse(http.StatusInternalServerError, "POLICY_ERROR",
           "Failed to load policy")
   }

   // Evaluate policy
   decision := policy.Evaluate(loadedPolicy, policyRequest)

   // Handle deny (approval/break-glass check will be added in 99-03)
   if decision.Effect == policy.EffectDeny {
       log.Printf("DENY: user=%s profile=%s rule=%s reason=%s",
           username, profile, decision.MatchedRule, decision.Reason)
       return errorResponse(http.StatusForbidden, "POLICY_DENY",
           fmt.Sprintf("Policy denied: %s", decision.Reason))
   }
   ```

4. Extract username BEFORE policy evaluation (move extractUsername call earlier):
   ```go
   // Extract username from caller ARN for policy evaluation
   username, err := extractUsername(caller.UserARN)
   if err != nil {
       return errorResponse(http.StatusBadRequest, "INVALID_IDENTITY",
           fmt.Sprintf("Could not extract username: %v", err))
   }
   ```

5. Apply max_server_duration from policy decision:
   ```go
   // Apply duration from policy cap
   duration := parsedDuration
   if decision.MaxServerDuration > 0 {
       if duration == 0 || duration > decision.MaxServerDuration {
           duration = decision.MaxServerDuration
           log.Printf("INFO: Capping duration to policy max_server_duration: %v", duration)
       }
   }
   ```

6. Use config's STSClient and Region:
   ```go
   vendInput := &VendInput{
       Caller:          caller,
       RoleARN:         roleARN,
       SessionDuration: duration,
       Region:          h.Config.Region,
   }

   var vendOutput *VendOutput
   if h.Config.STSClient != nil {
       vendOutput, err = VendCredentialsWithClient(ctx, vendInput, h.Config.STSClient)
   } else {
       vendOutput, err = VendCredentials(ctx, vendInput)
   }
   ```

Import: github.com/byteness/aws-vault/v7/policy
  </action>
  <verify>
  - `gofmt -e lambda/handler.go` shows no syntax errors
  - Handler uses TVMConfig
  - Policy evaluation before credential vending
  </verify>
  <done>
  - Handler uses TVMConfig for configuration
  - Policy loaded and evaluated before credentials
  - Deny returns 403 with reason
  - MaxServerDuration capping applied
  </done>
</task>

<task type="auto">
  <name>Task 2: Update handler tests for policy integration</name>
  <files>lambda/handler_test.go</files>
  <action>
Update `lambda/handler_test.go` to test policy integration:

1. Create mock policy loader:
   ```go
   type mockPolicyLoader struct {
       policy *policy.Policy
       err    error
   }

   func (m *mockPolicyLoader) Load(ctx context.Context, param string) (*policy.Policy, error) {
       return m.policy, m.err
   }
   ```

2. Create helper for test policies:
   ```go
   func allowAllPolicy() *policy.Policy {
       return &policy.Policy{
           Rules: []policy.Rule{{
               Name:   "allow-all",
               Effect: policy.EffectAllow,
           }},
       }
   }

   func denyAllPolicy() *policy.Policy {
       return &policy.Policy{
           Rules: []policy.Rule{{
               Name:   "deny-all",
               Effect: policy.EffectDeny,
               Reason: "test deny reason",
           }},
       }
   }

   func maxDurationPolicy(duration time.Duration) *policy.Policy {
       return &policy.Policy{
           Rules: []policy.Rule{{
               Name:              "with-duration-cap",
               Effect:            policy.EffectAllow,
               MaxServerDuration: duration,
           }},
       }
   }
   ```

3. Update existing tests to use TVMConfig:
   - Create config with mock policy loader and mock STS
   - Pass config to NewHandler

4. Add new test cases:
   - `TestHandleRequest_PolicyDeny`: Policy deny returns 403
   - `TestHandleRequest_PolicyLoadError`: Policy load failure returns 500
   - `TestHandleRequest_MaxServerDuration`: Duration capped to policy value
   - `TestHandleRequest_MissingPolicyParameter`: Error if PolicyParameter empty

5. Update success tests to include allow policy
  </action>
  <verify>
  - `gofmt -e lambda/handler_test.go` shows no syntax errors
  - All test cases compile
  </verify>
  <done>
  - Mock policy loader enables testing
  - Policy deny tested (403 response)
  - Policy load error tested (500 response)
  - MaxServerDuration capping tested
  - Existing tests updated for new Handler signature
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `gofmt -e lambda/*.go` shows no syntax errors
- [ ] Handler uses TVMConfig from 99-01
- [ ] Policy evaluated before credential issuance
- [ ] Deny returns 403 with reason
</verification>

<success_criteria>

- Handler integrates TVMConfig
- Policy loaded from SSM via PolicyLoader
- Policy evaluated with ModeServer
- Deny blocks credential issuance
- MaxServerDuration capping applied
- Tests cover allow, deny, load error cases
</success_criteria>

<output>
After completion, create `.planning/phases/99-policy-session-integration/99-02-SUMMARY.md`
</output>
