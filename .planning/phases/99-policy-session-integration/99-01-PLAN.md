---
phase: 99-policy-session-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [lambda/config.go, lambda/config_test.go]
autonomous: true
---

<objective>
Create TVM configuration layer that mirrors SentinelServerConfig for Lambda handler.

Purpose: Establish the configuration foundation that all other Phase 99 plans depend on. The Lambda handler needs access to policy loader, stores (approval, break-glass, session), and logger - same as SentinelServer.
Output: `lambda/config.go` with TVMConfig type and helper functions for environment-based configuration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
@./.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Reference the existing SentinelServerConfig pattern:
@sentinel/server.go

Existing Lambda handler:
@lambda/handler.go
@lambda/vend.go

Packages to integrate:
@policy/loader.go
@session/store.go
@request/store.go
@breakglass/store.go
@logging/logger.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TVM configuration types</name>
  <files>lambda/config.go</files>
  <action>
Create `lambda/config.go` with TVMConfig that mirrors SentinelServerConfig:

```go
package lambda

import (
    "context"
    "os"
    "time"

    "github.com/aws/aws-sdk-go-v2/config"
    "github.com/aws/aws-sdk-go-v2/service/dynamodb"
    "github.com/aws/aws-sdk-go-v2/service/ssm"
    "github.com/byteness/aws-vault/v7/breakglass"
    "github.com/byteness/aws-vault/v7/logging"
    "github.com/byteness/aws-vault/v7/policy"
    "github.com/byteness/aws-vault/v7/request"
    "github.com/byteness/aws-vault/v7/session"
)

// Environment variable names for TVM configuration.
const (
    EnvPolicyParameter      = "SENTINEL_POLICY_PARAMETER"
    EnvApprovalTable        = "SENTINEL_APPROVAL_TABLE"
    EnvBreakGlassTable      = "SENTINEL_BREAKGLASS_TABLE"
    EnvSessionTable         = "SENTINEL_SESSION_TABLE"
    EnvRegion               = "AWS_REGION"
)

// TVMConfig contains configuration for the Lambda TVM handler.
// This mirrors SentinelServerConfig for consistency with server mode.
type TVMConfig struct {
    // PolicyParameter is the SSM parameter path for policy (required).
    PolicyParameter string

    // PolicyLoader is the cached policy loader.
    PolicyLoader policy.PolicyLoader

    // ApprovalStore is the optional approval request store.
    // If nil, approval checking is disabled.
    ApprovalStore request.Store

    // BreakGlassStore is the optional break-glass store.
    // If nil, break-glass checking is disabled.
    BreakGlassStore breakglass.Store

    // SessionStore is the optional session store.
    // If nil, session tracking is disabled.
    SessionStore session.Store

    // SessionTableName is the DynamoDB table name for sessions.
    // Passed to policy.Request for require_server_session evaluation.
    SessionTableName string

    // Logger is used for decision logging.
    // If nil, logging is disabled.
    Logger logging.Logger

    // STSClient is an optional custom STS client for testing.
    STSClient STSClient

    // Region is the AWS region.
    Region string

    // DefaultDuration is the default session duration if not specified.
    // Defaults to 15 minutes (matching server mode).
    DefaultDuration time.Duration
}

// LoadConfigFromEnv creates a TVMConfig from environment variables.
// This is the primary way to configure the Lambda TVM in production.
func LoadConfigFromEnv(ctx context.Context) (*TVMConfig, error) {
    cfg := &TVMConfig{
        PolicyParameter:  os.Getenv(EnvPolicyParameter),
        SessionTableName: os.Getenv(EnvSessionTable),
        Region:           os.Getenv(EnvRegion),
        DefaultDuration:  15 * time.Minute,
    }

    // Load AWS config for creating clients
    awsCfg, err := config.LoadDefaultConfig(ctx, config.WithRegion(cfg.Region))
    if err != nil {
        return nil, fmt.Errorf("failed to load AWS config: %w", err)
    }

    // Create SSM client and policy loader
    ssmClient := ssm.NewFromConfig(awsCfg)
    cfg.PolicyLoader = policy.NewSSMLoader(ssmClient)

    // Create DynamoDB clients for stores if tables are configured
    if approvalTable := os.Getenv(EnvApprovalTable); approvalTable != "" {
        ddbClient := dynamodb.NewFromConfig(awsCfg)
        cfg.ApprovalStore = request.NewDynamoDBStore(ddbClient, approvalTable)
    }

    if breakglassTable := os.Getenv(EnvBreakGlassTable); breakglassTable != "" {
        ddbClient := dynamodb.NewFromConfig(awsCfg)
        cfg.BreakGlassStore = breakglass.NewDynamoDBStore(ddbClient, breakglassTable)
    }

    if cfg.SessionTableName != "" {
        ddbClient := dynamodb.NewFromConfig(awsCfg)
        cfg.SessionStore = session.NewDynamoDBStore(ddbClient, cfg.SessionTableName)
    }

    // Create JSON Lines logger (writes to stdout, captured by CloudWatch)
    cfg.Logger = logging.NewJSONLinesLogger(os.Stdout)

    return cfg, nil
}
```

Key design decisions:
1. Mirror SentinelServerConfig field names for consistency
2. All stores are optional (nil = feature disabled)
3. Environment variables follow existing SENTINEL_* convention
4. Logger writes to stdout (CloudWatch Logs captures Lambda stdout)
5. DefaultDuration matches server mode (15 min)
  </action>
  <verify>
  - `gofmt -e lambda/config.go` shows no syntax errors
  </verify>
  <done>
  - TVMConfig type exists with all store fields
  - LoadConfigFromEnv creates config from environment
  - Environment variable names defined as constants
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for configuration</name>
  <files>lambda/config_test.go</files>
  <action>
Create `lambda/config_test.go` with tests:

```go
package lambda

import (
    "os"
    "testing"
)

func TestEnvVariableNames(t *testing.T) {
    // Verify environment variable names match documentation
    tests := []struct {
        name     string
        constant string
        expected string
    }{
        {"PolicyParameter", EnvPolicyParameter, "SENTINEL_POLICY_PARAMETER"},
        {"ApprovalTable", EnvApprovalTable, "SENTINEL_APPROVAL_TABLE"},
        {"BreakGlassTable", EnvBreakGlassTable, "SENTINEL_BREAKGLASS_TABLE"},
        {"SessionTable", EnvSessionTable, "SENTINEL_SESSION_TABLE"},
        {"Region", EnvRegion, "AWS_REGION"},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if tt.constant != tt.expected {
                t.Errorf("expected %q, got %q", tt.expected, tt.constant)
            }
        })
    }
}

func TestTVMConfig_Defaults(t *testing.T) {
    cfg := &TVMConfig{}

    // Verify nil stores don't cause issues
    if cfg.ApprovalStore != nil {
        t.Error("expected nil ApprovalStore")
    }
    if cfg.BreakGlassStore != nil {
        t.Error("expected nil BreakGlassStore")
    }
    if cfg.SessionStore != nil {
        t.Error("expected nil SessionStore")
    }
    if cfg.Logger != nil {
        t.Error("expected nil Logger")
    }
}

func TestTVMConfig_DefaultDuration(t *testing.T) {
    cfg := &TVMConfig{
        DefaultDuration: 15 * time.Minute,
    }

    if cfg.DefaultDuration != 15*time.Minute {
        t.Errorf("expected 15 minutes, got %v", cfg.DefaultDuration)
    }
}
```

Note: LoadConfigFromEnv cannot be fully tested without AWS credentials.
Tests focus on configuration structure and constants.
  </action>
  <verify>
  - `gofmt -e lambda/config_test.go` shows no syntax errors
  </verify>
  <done>
  - Environment variable constants verified
  - TVMConfig structure verified
  - Optional stores default to nil
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `gofmt -e lambda/*.go` shows no syntax errors
- [ ] TVMConfig mirrors SentinelServerConfig pattern
- [ ] Environment variables follow SENTINEL_* convention
</verification>

<success_criteria>

- TVMConfig type with policy loader, stores, and logger fields
- LoadConfigFromEnv creates config from environment variables
- All stores are optional (nil = disabled)
- Constants for environment variable names
- Unit tests verify structure and constants
</success_criteria>

<output>
After completion, create `.planning/phases/99-policy-session-integration/99-01-SUMMARY.md`
</output>
