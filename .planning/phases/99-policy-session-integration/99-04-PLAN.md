---
phase: 99-policy-session-integration
plan: 04
type: execute
wave: 3
depends_on: ["99-02", "99-03"]
files_modified: [lambda/handler.go, lambda/handler_test.go, lambda/logging.go]
autonomous: true
---

<objective>
Complete handler integration with approval/break-glass checking and decision logging.

Purpose: After policy evaluation (99-02) and session tracking (99-03), integrate the remaining features: approved request fallback, break-glass fallback, and decision logging. This completes the TVM handler with full parity to SentinelServer.DefaultRoute().
Output: Fully integrated handler with approval/break-glass overrides and CloudWatch-compatible logging.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/99-policy-session-integration/99-01-SUMMARY.md
@.planning/phases/99-policy-session-integration/99-02-SUMMARY.md
@.planning/phases/99-policy-session-integration/99-03-SUMMARY.md

Reference the full DefaultRoute pattern:
@sentinel/server.go (lines 216-367)

Approval and break-glass packages:
@request/find.go
@breakglass/find.go
@logging/decision.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate approval and break-glass checking</name>
  <files>lambda/handler.go</files>
  <action>
Update `lambda/handler.go` to add approval/break-glass override when policy denies:

1. After policy evaluation deny block, add approval/break-glass check:
   ```go
   var approvedReq *request.Request
   var activeBreakGlass *breakglass.BreakGlassEvent

   if decision.Effect == policy.EffectDeny {
       // Check for approved request first
       if h.Config.ApprovalStore != nil {
           var storeErr error
           approvedReq, storeErr = request.FindApprovedRequest(ctx, h.Config.ApprovalStore, username, profile)
           if storeErr != nil {
               log.Printf("Warning: failed to check approved requests: %v", storeErr)
           }
       }

       // If no approved request, check for active break-glass
       if approvedReq == nil && h.Config.BreakGlassStore != nil {
           var bgErr error
           activeBreakGlass, bgErr = breakglass.FindActiveBreakGlass(ctx, h.Config.BreakGlassStore, username, profile)
           if bgErr != nil {
               log.Printf("Warning: failed to check break-glass: %v", bgErr)
           }
       }

       // If neither approved request nor break-glass, deny
       if approvedReq == nil && activeBreakGlass == nil {
           // Log deny decision
           if h.Config.Logger != nil {
               entry := logging.NewDecisionLogEntry(policyRequest, decision, h.Config.PolicyParameter)
               h.Config.Logger.LogDecision(entry)
           }
           return errorResponse(http.StatusForbidden, "POLICY_DENY",
               fmt.Sprintf("Policy denied: %s", decision.Reason))
       }
       // Approved or break-glass - continue to credential issuance
   }
   ```

2. Apply break-glass duration capping (after policy cap):
   ```go
   // Cap duration to break-glass remaining time if applicable
   if activeBreakGlass != nil {
       remainingTime := breakglass.RemainingDuration(activeBreakGlass)
       if duration == 0 || duration > remainingTime {
           duration = remainingTime
           log.Printf("INFO: Capping duration to break-glass remaining time: %v", duration)
       }
   }
   ```

3. Include approval ID in VendInput when using approved request:
   ```go
   vendInput := &VendInput{
       // ... existing fields ...
   }

   // Include approval ID for SourceIdentity stamping
   if approvedReq != nil {
       vendInput.ApprovalID = approvedReq.ID
   }
   ```

4. Add ApprovalID field to VendInput in vend.go and use it:
   - Add `ApprovalID string` to VendInput struct
   - Pass ApprovalID to identity.New() instead of empty string

Import: github.com/byteness/aws-vault/v7/request, github.com/byteness/aws-vault/v7/breakglass
  </action>
  <verify>
  - `gofmt -e lambda/handler.go` shows no syntax errors
  - Approval check before deny
  - Break-glass check as fallback
  - Duration capping applied
  </verify>
  <done>
  - Approved request override policy deny
  - Break-glass override policy deny (when no approved request)
  - Duration capped to break-glass remaining time
  - ApprovalID passed through for SourceIdentity
  </done>
</task>

<task type="auto">
  <name>Task 2: Add decision logging</name>
  <files>lambda/handler.go</files>
  <action>
Add decision logging after successful credential issuance (matching SentinelServer pattern):

```go
// After successful credential issuance, log decision with credential context
if h.Config.Logger != nil {
    credFields := &logging.CredentialIssuanceFields{
        RequestID:       vendOutput.SourceIdentity.RequestID(),
        SourceIdentity:  vendOutput.SourceIdentity.Format(),
        RoleARN:         roleARN,
        SessionDuration: duration,
    }

    // Include approved request ID if credentials were issued via approval
    if approvedReq != nil {
        credFields.ApprovedRequestID = approvedReq.ID
    }

    // Include break-glass event ID if credentials were issued via break-glass
    if activeBreakGlass != nil {
        credFields.BreakGlassEventID = activeBreakGlass.ID
    }

    entry := logging.NewEnhancedDecisionLogEntry(policyRequest, decision, h.Config.PolicyParameter, credFields)
    h.Config.Logger.LogDecision(entry)
}
```

This produces JSON Lines output like:
```json
{"timestamp":"...","user":"alice","profile":"prod","effect":"allow","rule":"...","request_id":"...","source_identity":"sentinel:..."}
```

CloudWatch Logs captures Lambda stdout, so this integrates with existing logging infrastructure.

Import: github.com/byteness/aws-vault/v7/logging
  </action>
  <verify>
  - Decision logged after credential issuance
  - Credential fields included in log entry
  - Approval/break-glass IDs included when applicable
  </verify>
  <done>
  - Decision logging after allow
  - Decision logging on deny (before return)
  - Credential issuance fields in log
  - Approval/break-glass IDs in log when applicable
  </done>
</task>

<task type="auto">
  <name>Task 3: Complete handler flow with session integration</name>
  <files>lambda/handler.go</files>
  <action>
Wire session tracking into the complete handler flow:

1. Create session context early in handler:
   ```go
   // Create session context (after username extraction)
   sessionCtx := CreateSessionContext(ctx, h.Config, username, profile)
   ```

2. Check session revocation before credential issuance:
   ```go
   // Check session revocation (after policy/approval/break-glass checks)
   if sessionCtx.CheckRevocation(ctx) {
       return errorResponse(http.StatusForbidden, "SESSION_REVOKED",
           "Session has been revoked")
   }
   ```

3. Pass session ID to VendInput:
   ```go
   vendInput := &VendInput{
       // ... other fields ...
       SessionID: sessionCtx.ID,
   }
   ```

4. Touch session after successful issuance:
   ```go
   // Touch session to update LastAccessAt
   sessionCtx.Touch(ctx)
   ```

Complete handler flow order:
1. Extract caller identity
2. Parse profile parameter
3. Extract username from caller ARN
4. Create session context
5. Build policy request
6. Load and evaluate policy
7. If deny: check approval, check break-glass
8. If still deny: log and return 403
9. Check session revocation
10. Apply duration caps (policy, break-glass)
11. Vend credentials
12. Touch session
13. Log decision
14. Return credentials
  </action>
  <verify>
  - Session context created early
  - Revocation checked before credentials
  - Session ID passed to VendInput
  - Session touched after success
  </verify>
  <done>
  - Complete handler flow matches SentinelServer.DefaultRoute()
  - Session lifecycle properly managed
  - All integration points wired together
  </done>
</task>

<task type="auto">
  <name>Task 4: Add integration tests</name>
  <files>lambda/handler_test.go</files>
  <action>
Add tests for the complete integrated flow:

1. Create mock approval store:
   ```go
   type mockApprovalStore struct {
       approvedRequest *request.Request
       err             error
   }

   func (m *mockApprovalStore) FindByID(ctx context.Context, id string) (*request.Request, error) {
       return m.approvedRequest, m.err
   }
   // ... implement other Store methods as no-ops
   ```

2. Create mock break-glass store:
   ```go
   type mockBreakGlassStore struct {
       activeEvent *breakglass.BreakGlassEvent
       err         error
   }

   func (m *mockBreakGlassStore) FindActiveByInvokerAndProfile(ctx context.Context, invoker, profile string) (*breakglass.BreakGlassEvent, error) {
       return m.activeEvent, m.err
   }
   // ... implement other Store methods as no-ops
   ```

3. Create mock logger:
   ```go
   type mockLogger struct {
       entries []logging.DecisionLogEntry
   }

   func (m *mockLogger) LogDecision(entry logging.DecisionLogEntry) {
       m.entries = append(m.entries, entry)
   }
   ```

4. Add test cases:
   - `TestHandleRequest_ApprovalOverride`: Policy deny + approved request = allow
   - `TestHandleRequest_BreakGlassOverride`: Policy deny + no approval + break-glass = allow
   - `TestHandleRequest_NeitherOverride`: Policy deny + no approval + no break-glass = deny
   - `TestHandleRequest_SessionRevoked`: Session revoked = deny
   - `TestHandleRequest_Logging`: Verify logger called with correct fields
   - `TestHandleRequest_FullFlow`: Complete success path with session + logging
  </action>
  <verify>
  - `gofmt -e lambda/handler_test.go` shows no syntax errors
  - All mock stores implement required interfaces
  </verify>
  <done>
  - Mock stores for testing approval/break-glass
  - Mock logger for testing decision logging
  - Complete integration tests covering all paths
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `gofmt -e lambda/*.go` shows no syntax errors
- [ ] Handler matches SentinelServer.DefaultRoute() flow
- [ ] Approval and break-glass overrides work
- [ ] Decision logging produces JSON Lines
- [ ] Session lifecycle properly managed
</verification>

<success_criteria>

- Approved request overrides policy deny
- Break-glass overrides policy deny (when no approval)
- Duration capped to break-glass remaining time
- Decision logging in JSON Lines format
- Session revocation check before credentials
- Complete handler flow matches SentinelServer
- All integration paths tested
</success_criteria>

<output>
After completion, create `.planning/phases/99-policy-session-integration/99-04-SUMMARY.md`
</output>
