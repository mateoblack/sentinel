---
phase: 99-policy-session-integration
plan: 03
type: execute
wave: 2
depends_on: ["99-01"]
files_modified: [lambda/session.go, lambda/session_test.go, lambda/vend.go]
autonomous: true
---

<objective>
Integrate DynamoDB session tracking with session tagging on AssumeRole.

Purpose: Track Lambda TVM sessions in DynamoDB and stamp session ID as a session tag on AssumeRole calls. This enables downstream services to verify credentials via session lookup and supports instant revocation patterns.
Output: Session lifecycle management (create/touch/expire) and session tag stamping on credentials.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/99-policy-session-integration/99-01-SUMMARY.md

Reference the session tracking pattern:
@sentinel/server.go (lines 173-204 for session creation, 276-287 for revocation check, 359-363 for touch)
@session/store.go
@session/types.go

Lambda files to update:
@lambda/vend.go
@lambda/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create session management functions</name>
  <files>lambda/session.go</files>
  <action>
Create `lambda/session.go` with session lifecycle functions:

```go
package lambda

import (
    "context"
    "log"
    "time"

    "github.com/byteness/aws-vault/v7/identity"
    "github.com/byteness/aws-vault/v7/session"
)

// SessionContext holds session state for a TVM request.
// Created at the start of HandleRequest, used throughout the request lifecycle.
type SessionContext struct {
    // ID is the session ID (empty if session tracking disabled).
    ID string

    // Session is the ServerSession record (nil if session tracking disabled).
    Session *session.ServerSession

    // Store is the session store (nil if disabled).
    Store session.Store
}

// CreateSessionContext creates a new session if session tracking is enabled.
// Returns empty SessionContext if SessionStore is nil.
func CreateSessionContext(ctx context.Context, cfg *TVMConfig, username, profile string) *SessionContext {
    sc := &SessionContext{
        Store: cfg.SessionStore,
    }

    if cfg.SessionStore == nil {
        return sc
    }

    // Generate session ID
    sessionID := session.NewSessionID()
    now := time.Now().UTC()

    // Calculate expiry based on config
    duration := cfg.DefaultDuration
    if duration == 0 {
        duration = 15 * time.Minute
    }

    // Create session record
    serverSession := &session.ServerSession{
        ID:               sessionID,
        User:             username,
        Profile:          profile,
        ServerInstanceID: identity.NewRequestID(), // Each Lambda invocation is unique
        Status:           session.StatusActive,
        StartedAt:        now,
        LastAccessAt:     now,
        ExpiresAt:        now.Add(duration),
        RequestCount:     0,
        CreatedAt:        now,
        UpdatedAt:        now,
    }

    // Store session (best-effort - don't fail request on session error)
    if err := cfg.SessionStore.Create(ctx, serverSession); err != nil {
        log.Printf("Warning: failed to create session: %v", err)
        return sc
    }

    sc.ID = sessionID
    sc.Session = serverSession
    log.Printf("Session created: %s user=%s profile=%s", sessionID, username, profile)

    return sc
}

// TouchSession updates LastAccessAt and increments RequestCount.
// No-op if session tracking is disabled.
func (sc *SessionContext) Touch(ctx context.Context) {
    if sc.Store == nil || sc.ID == "" {
        return
    }

    if err := sc.Store.Touch(ctx, sc.ID); err != nil {
        log.Printf("Warning: failed to touch session: %v", err)
    }
}

// CheckRevocation checks if the session has been revoked.
// Returns true if revoked, false otherwise.
// Fails-closed: revoked = deny. Fails-open on store errors for availability.
func (sc *SessionContext) CheckRevocation(ctx context.Context) bool {
    if sc.Store == nil || sc.ID == "" {
        return false // Not tracking, not revoked
    }

    revoked, err := session.IsSessionRevoked(ctx, sc.Store, sc.ID)
    if err != nil {
        // Store error - fail open for availability
        log.Printf("Warning: failed to check session revocation: %v", err)
        return false
    }

    if revoked {
        log.Printf("Session revoked: %s - denying credentials", sc.ID)
    }
    return revoked
}

// ExpireSession marks the session as expired.
// Called on handler completion or error.
func (sc *SessionContext) Expire(ctx context.Context) {
    if sc.Store == nil || sc.ID == "" {
        return
    }

    sess, err := sc.Store.Get(ctx, sc.ID)
    if err != nil {
        log.Printf("Warning: failed to get session for expiry: %v", err)
        return
    }

    if !sess.Status.IsTerminal() {
        sess.Status = session.StatusExpired
        sess.UpdatedAt = time.Now().UTC()
        if err := sc.Store.Update(ctx, sess); err != nil {
            log.Printf("Warning: failed to expire session: %v", err)
        }
    }
}
```

Key design decisions:
1. SessionContext wraps session state for the request lifecycle
2. CreateSessionContext creates session at request start (like SentinelServer)
3. CheckRevocation fails-closed for security but fails-open on errors (availability)
4. Touch updates LastAccessAt (called after successful credential issuance)
5. Expire marks session terminal on request completion
  </action>
  <verify>
  - `gofmt -e lambda/session.go` shows no syntax errors
  </verify>
  <done>
  - SessionContext type created
  - CreateSessionContext, Touch, CheckRevocation, Expire functions
  - Matches SentinelServer session patterns
  </done>
</task>

<task type="auto">
  <name>Task 2: Add session tag to AssumeRole call</name>
  <files>lambda/vend.go</files>
  <action>
Update `lambda/vend.go` to add session tag on AssumeRole:

1. Add SessionID field to VendInput:
   ```go
   type VendInput struct {
       // ... existing fields ...

       // SessionID is the session ID to stamp as a session tag.
       // Optional - if empty, no session tag is added.
       SessionID string
   }
   ```

2. Update VendCredentialsWithClient to add session tag:
   ```go
   // Build AssumeRole input
   assumeRoleInput := &sts.AssumeRoleInput{
       RoleArn:         aws.String(input.RoleARN),
       RoleSessionName: aws.String(roleSessionName),
       DurationSeconds: aws.Int32(int32(input.SessionDuration.Seconds())),
       SourceIdentity:  aws.String(sourceIdentity.Format()),
   }

   // Add session tag if session tracking is enabled
   if input.SessionID != "" {
       assumeRoleInput.Tags = []types.Tag{{
           Key:   aws.String("SentinelSessionID"),
           Value: aws.String(input.SessionID),
       }}
   }
   ```

3. Add import for STS types:
   ```go
   import (
       "github.com/aws/aws-sdk-go-v2/service/sts/types"
   )
   ```

The session tag enables:
- Downstream Lambda authorizers to verify session validity
- CloudTrail correlation between TVM sessions and API calls
- Instant revocation by checking session status via tag value
  </action>
  <verify>
  - `gofmt -e lambda/vend.go` shows no syntax errors
  - SessionID added to VendInput
  - Tags added to AssumeRoleInput when SessionID present
  </verify>
  <done>
  - VendInput includes SessionID field
  - AssumeRole call includes SentinelSessionID tag when session tracking enabled
  - Tag enables downstream revocation checks
  </done>
</task>

<task type="auto">
  <name>Task 3: Add session tests</name>
  <files>lambda/session_test.go</files>
  <action>
Create `lambda/session_test.go` with tests:

```go
package lambda

import (
    "context"
    "testing"
    "time"

    "github.com/byteness/aws-vault/v7/session"
)

// mockSessionStore implements session.Store for testing.
type mockSessionStore struct {
    sessions map[string]*session.ServerSession
    createErr error
    getErr    error
    touchErr  error
    updateErr error
}

func newMockSessionStore() *mockSessionStore {
    return &mockSessionStore{
        sessions: make(map[string]*session.ServerSession),
    }
}

func (m *mockSessionStore) Create(ctx context.Context, sess *session.ServerSession) error {
    if m.createErr != nil {
        return m.createErr
    }
    m.sessions[sess.ID] = sess
    return nil
}

func (m *mockSessionStore) Get(ctx context.Context, id string) (*session.ServerSession, error) {
    if m.getErr != nil {
        return nil, m.getErr
    }
    sess, ok := m.sessions[id]
    if !ok {
        return nil, session.ErrSessionNotFound
    }
    return sess, nil
}

func (m *mockSessionStore) Touch(ctx context.Context, id string) error {
    if m.touchErr != nil {
        return m.touchErr
    }
    sess, ok := m.sessions[id]
    if !ok {
        return session.ErrSessionNotFound
    }
    sess.LastAccessAt = time.Now().UTC()
    sess.RequestCount++
    return nil
}

func (m *mockSessionStore) Update(ctx context.Context, sess *session.ServerSession) error {
    if m.updateErr != nil {
        return m.updateErr
    }
    m.sessions[sess.ID] = sess
    return nil
}

// Implement remaining Store interface methods as no-ops for testing
func (m *mockSessionStore) Delete(ctx context.Context, id string) error { return nil }
func (m *mockSessionStore) ListByUser(ctx context.Context, user string, limit int) ([]*session.ServerSession, error) { return nil, nil }
func (m *mockSessionStore) ListByStatus(ctx context.Context, status session.SessionStatus, limit int) ([]*session.ServerSession, error) { return nil, nil }
func (m *mockSessionStore) ListByProfile(ctx context.Context, profile string, limit int) ([]*session.ServerSession, error) { return nil, nil }
func (m *mockSessionStore) FindActiveByServerInstance(ctx context.Context, serverInstanceID string) (*session.ServerSession, error) { return nil, nil }
func (m *mockSessionStore) ListByTimeRange(ctx context.Context, start, end time.Time, limit int) ([]*session.ServerSession, error) { return nil, nil }
func (m *mockSessionStore) GetBySourceIdentity(ctx context.Context, sourceIdentity string) (*session.ServerSession, error) { return nil, nil }

func TestCreateSessionContext_NoStore(t *testing.T) {
    cfg := &TVMConfig{SessionStore: nil}
    sc := CreateSessionContext(context.Background(), cfg, "alice", "dev")

    if sc.ID != "" {
        t.Errorf("expected empty ID when store is nil")
    }
    if sc.Session != nil {
        t.Errorf("expected nil session when store is nil")
    }
}

func TestCreateSessionContext_WithStore(t *testing.T) {
    store := newMockSessionStore()
    cfg := &TVMConfig{
        SessionStore:    store,
        DefaultDuration: 15 * time.Minute,
    }

    sc := CreateSessionContext(context.Background(), cfg, "alice", "dev")

    if sc.ID == "" {
        t.Error("expected session ID to be set")
    }
    if sc.Session == nil {
        t.Error("expected session to be created")
    }
    if sc.Session.User != "alice" {
        t.Errorf("expected user alice, got %s", sc.Session.User)
    }
    if sc.Session.Profile != "dev" {
        t.Errorf("expected profile dev, got %s", sc.Session.Profile)
    }
}

func TestSessionContext_CheckRevocation_NotRevoked(t *testing.T) {
    store := newMockSessionStore()
    sess := &session.ServerSession{
        ID:     "test-session",
        Status: session.StatusActive,
    }
    store.sessions[sess.ID] = sess

    sc := &SessionContext{
        ID:    sess.ID,
        Store: store,
    }

    if sc.CheckRevocation(context.Background()) {
        t.Error("expected not revoked")
    }
}

func TestSessionContext_CheckRevocation_Revoked(t *testing.T) {
    store := newMockSessionStore()
    sess := &session.ServerSession{
        ID:     "test-session",
        Status: session.StatusRevoked,
    }
    store.sessions[sess.ID] = sess

    sc := &SessionContext{
        ID:    sess.ID,
        Store: store,
    }

    if !sc.CheckRevocation(context.Background()) {
        t.Error("expected revoked")
    }
}

func TestVendInput_SessionTag(t *testing.T) {
    input := &VendInput{
        SessionID: "test-session-id",
    }

    if input.SessionID != "test-session-id" {
        t.Errorf("expected session ID test-session-id, got %s", input.SessionID)
    }
}
```
  </action>
  <verify>
  - `gofmt -e lambda/session_test.go` shows no syntax errors
  </verify>
  <done>
  - Mock session store for testing
  - CreateSessionContext tests with and without store
  - Revocation check tests for active and revoked states
  - SessionID field verified in VendInput
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `gofmt -e lambda/*.go` shows no syntax errors
- [ ] SessionContext created with proper lifecycle
- [ ] VendInput includes SessionID field
- [ ] AssumeRole includes SentinelSessionID tag
</verification>

<success_criteria>

- SessionContext manages session lifecycle (create/touch/revoke/expire)
- VendInput.SessionID enables session tag stamping
- AssumeRole call includes SentinelSessionID session tag
- Revocation check fails-closed (revoked = deny)
- Tests cover session lifecycle scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/99-policy-session-integration/99-03-SUMMARY.md`
</output>
