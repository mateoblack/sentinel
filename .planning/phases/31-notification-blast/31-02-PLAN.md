---
phase: 31-notification-blast
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified: [notification/breakglass_notifier.go, notification/breakglass_notifier_test.go, cli/breakglass.go, cli/breakglass_test.go]
autonomous: true
---

<objective>
Create BreakGlassNotifier interface and integrate notifications into break-glass command.

Purpose: Fire immediate security alerts when break-glass is invoked, enabling security teams to respond to emergency access in real-time.
Output: Working notification delivery when break-glass command is executed.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan summary from this phase
@.planning/phases/31-notification-blast/31-01-SUMMARY.md

# Notification patterns to follow
@notification/notifier.go
@notification/sns.go
@notification/webhook.go

# Break-glass CLI to integrate with
@cli/breakglass.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BreakGlassNotifier interface and implementations</name>
  <files>notification/breakglass_notifier.go</files>
  <action>
Create break-glass notifier interface and implementations:

1. Create BreakGlassNotifier interface:
   ```go
   type BreakGlassNotifier interface {
       NotifyBreakGlass(ctx context.Context, event *BreakGlassEvent) error
   }
   ```

2. Create SNSBreakGlassNotifier that wraps SNS for break-glass:
   - Reuse same sns client and topic as regular SNSNotifier
   - Publish with "event_type" message attribute set to breakglass.* event type
   - Use NewSNSBreakGlassNotifier(cfg aws.Config, topicARN string)

3. Create WebhookBreakGlassNotifier that wraps webhook for break-glass:
   - Reuse same HTTP client pattern as WebhookNotifier
   - Same retry logic with exponential backoff
   - Use NewWebhookBreakGlassNotifier(config WebhookConfig)

4. Create MultiBreakGlassNotifier for composing multiple targets:
   - Same pattern as MultiNotifier
   - Filters nil notifiers
   - Uses errors.Join for combining errors

5. Create NoopBreakGlassNotifier for testing/disabled notifications.

Follow exact patterns from notification/notifier.go, notification/sns.go, notification/webhook.go.
  </action>
  <verify>go build ./notification/...</verify>
  <done>BreakGlassNotifier interface and all implementations compile</done>
</task>

<task type="auto">
  <name>Task 2: Add BreakGlassNotifier tests</name>
  <files>notification/breakglass_notifier_test.go</files>
  <action>
Add comprehensive tests for break-glass notifiers:

1. Test SNSBreakGlassNotifier:
   - Mock snsAPI interface
   - Verify Publish called with correct topic and message attributes
   - Test error propagation

2. Test WebhookBreakGlassNotifier:
   - Use httptest.Server to capture requests
   - Verify POST with correct Content-Type and X-Sentinel-Event header
   - Test retry on 5xx errors
   - Test no retry on 4xx errors
   - Test exponential backoff delays

3. Test MultiBreakGlassNotifier:
   - Test fanout to all notifiers
   - Test nil filtering
   - Test error aggregation with errors.Join

4. Test NoopBreakGlassNotifier returns nil.

Follow exact patterns from notification/sns_test.go and notification/webhook_test.go.
  </action>
  <verify>go test ./notification/... -v -run "BreakGlass"</verify>
  <done>All break-glass notifier tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Integrate notifications into break-glass command</name>
  <files>cli/breakglass.go, cli/breakglass_test.go</files>
  <action>
Wire break-glass notifications into the CLI command:

1. Update BreakGlassCommandInput:
   - Change Notifier type from notification.Notifier to notification.BreakGlassNotifier

2. After successful store.Create() in BreakGlassCommand:
   - If input.Notifier != nil:
     - Create BreakGlassEvent with EventBreakGlassInvoked type
     - Call input.Notifier.NotifyBreakGlass(ctx, bgEvent)
     - Log notification errors but don't fail the command (security alerts are best-effort)
   - Fire notification AFTER successful store and logging (store is source of truth)

3. Update cli/breakglass_test.go:
   - Add mock BreakGlassNotifier
   - Test notification is called on successful invocation
   - Test notification error doesn't fail command
   - Test nil notifier doesn't panic

The pattern mirrors how request command handles notifications but uses BreakGlassNotifier directly (no NotifyStore wrapper needed since break-glass only has invocation event from CLI).
  </action>
  <verify>go test ./cli/... -v -run "BreakGlass"</verify>
  <done>Break-glass command fires notifications on invocation, tests pass</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./notification/...` passes all tests
- [ ] `go test ./cli/...` passes all tests
- [ ] Break-glass invocation fires notification event
</verification>

<success_criteria>
- All tasks completed
- BreakGlassNotifier interface with SNS, Webhook, Multi, Noop implementations
- Break-glass command fires EventBreakGlassInvoked notification
- Notification errors are logged but don't fail the command
- Full test coverage for new code
</success_criteria>

<output>
After completion, create `.planning/phases/31-notification-blast/31-02-SUMMARY.md`
</output>
