---
phase: 110-session-device-binding
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - session/types.go
  - session/types_test.go
  - session/dynamodb.go
  - session/store.go
  - lambda/session.go
  - lambda/session_test.go
autonomous: true
---

<objective>
Add device ID binding to server sessions for forensic correlation and device-based revocation.

Purpose: Enable security teams to query sessions by device, correlate device with session metadata for forensics, and revoke all sessions from a compromised device.

Output: ServerSession with DeviceID field, DynamoDB serialization, Lambda integration, and ListByDeviceID query method.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/109-device-attestation-flow/109-01-SUMMARY.md

# Key source files:
@session/types.go
@session/dynamodb.go
@session/store.go
@lambda/session.go
@lambda/handler.go
@device/identity.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DeviceID field to ServerSession and DynamoDB serialization</name>
  <files>session/types.go, session/types_test.go, session/dynamodb.go</files>
  <action>
1. Add DeviceID field to ServerSession struct in types.go:
   - Field: `DeviceID string` with yaml/json tags `device_id,omitempty`
   - Position: After SourceIdentity field (logically groups identity fields)
   - Comment: "DeviceID is the device fingerprint associated with this session (64 lowercase hex chars, empty if not provided)."

2. Add DeviceID to dynamoItem struct in dynamodb.go:
   - Field: `DeviceID string` with dynamodbav tag `device_id`
   - Position: After SourceIdentity

3. Update toItem() in dynamodb.go:
   - Add: `DeviceID: session.DeviceID,`

4. Update fromItem() in dynamodb.go:
   - Add: `DeviceID: item.DeviceID,`

5. Add GSI constant for device queries in dynamodb.go:
   - Add: `GSIDeviceID = "gsi-device-id"` after GSIServerInstance
   - Comment: "GSIDeviceID indexes sessions by device_id with created_at sort key."

Device ID format: 64 lowercase hex chars (HMAC-SHA256 hashed, validated by device.ValidateDeviceIdentifier). Empty string if device ID not provided during session creation. Use omitempty for backward compatibility with sessions created before device binding.
  </action>
  <verify>go build ./session/... && go vet ./session/...</verify>
  <done>ServerSession has DeviceID field, dynamoItem serializes it, GSI constant defined</done>
</task>

<task type="auto">
  <name>Task 2: Add ListByDeviceID query method to Store interface and DynamoDB implementation</name>
  <files>session/store.go, session/dynamodb.go</files>
  <action>
1. Add ListByDeviceID to Store interface in store.go:
```go
// ListByDeviceID returns all sessions from a specific device, ordered by created_at desc.
// Returns empty slice if no sessions found for the device.
// If limit is 0, DefaultQueryLimit is used. Limit is capped at MaxQueryLimit.
// The deviceID should be a 64-char lowercase hex string (device.ValidateDeviceIdentifier format).
ListByDeviceID(ctx context.Context, deviceID string, limit int) ([]*ServerSession, error)
```

2. Implement ListByDeviceID in DynamoDBStore (dynamodb.go):
```go
// ListByDeviceID returns all sessions from a specific device, ordered by created_at desc.
// Returns empty slice if no sessions found for the device.
func (s *DynamoDBStore) ListByDeviceID(ctx context.Context, deviceID string, limit int) ([]*ServerSession, error) {
    return s.queryByIndex(ctx, GSIDeviceID, "device_id", deviceID, limit)
}
```

This follows the same pattern as ListByUser, ListByStatus, ListByProfile - reuses queryByIndex helper which handles pagination and sorting.
  </action>
  <verify>go build ./session/... && go vet ./session/...</verify>
  <done>Store interface has ListByDeviceID method, DynamoDB implements it using GSI</done>
</task>

<task type="auto">
  <name>Task 3: Wire device ID into Lambda session creation</name>
  <files>lambda/session.go, lambda/session_test.go, lambda/handler.go</files>
  <action>
1. Update CreateSessionContext signature in lambda/session.go:
   - Change: `func CreateSessionContext(ctx context.Context, cfg *TVMConfig, username, profile string) *SessionContext`
   - To: `func CreateSessionContext(ctx context.Context, cfg *TVMConfig, username, profile, deviceID string) *SessionContext`

2. Wire deviceID into ServerSession creation in CreateSessionContext:
   - Add to serverSession struct literal: `DeviceID: deviceID,`
   - Position: After SourceIdentity assignment

3. Update the log message to include device ID when present:
   - Change: `log.Printf("Session created: %s user=%s profile=%s", sessionID, username, profile)`
   - To: Include deviceID only when non-empty for privacy (log presence, not value)

4. Update handler.go call site:
   - Change: `sessionCtx := CreateSessionContext(ctx, h.Config, username, profile)`
   - To: `sessionCtx := CreateSessionContext(ctx, h.Config, username, profile, deviceID)`
   - Note: deviceID is already extracted earlier in HandleRequest via extractDeviceID()

5. Update any tests in lambda/session_test.go that call CreateSessionContext to pass empty string for deviceID (backward compatible - empty means no device binding).

Note: deviceID may be empty string if client didn't provide it. This is valid - sessions work without device binding for backward compatibility. The field uses omitempty so empty values don't appear in JSON/DynamoDB.
  </action>
  <verify>go build ./lambda/... && go vet ./lambda/...</verify>
  <done>Lambda session creation accepts and stores device ID, handler passes device ID from request</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go vet ./...` passes without errors
- [ ] ServerSession struct has DeviceID field with proper tags
- [ ] DynamoDB serialization includes device_id
- [ ] Store interface includes ListByDeviceID method
- [ ] DynamoDB implementation uses GSI for device queries
- [ ] Lambda session creation accepts and stores device ID
</verification>

<success_criteria>
- All tasks completed
- ServerSession has DeviceID field for forensic correlation
- Sessions can be queried by device ID via ListByDeviceID
- Lambda TVM stores device ID in session metadata
- Backward compatible - sessions without device ID continue to work
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/110-session-device-binding/110-01-SUMMARY.md`
</output>
