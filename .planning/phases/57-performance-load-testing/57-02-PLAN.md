---
phase: 57-performance-load-testing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [policy/concurrency_test.go, breakglass/concurrency_test.go, request/concurrency_test.go]
autonomous: true
---

<objective>
Create concurrency tests verifying thread-safety of cached loaders, state machines, and store operations.

Purpose: Validate that concurrent access doesn't cause data races or incorrect behavior under parallel load.
Output: Concurrent tests using goroutines, sync primitives, and -race detector.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@policy/cache.go
@breakglass/dynamodb.go
@request/dynamodb.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create policy cache concurrency tests</name>
  <files>policy/concurrency_test.go</files>
  <action>
Create concurrency tests for CachedLoader:

1. TestCachedLoader_ConcurrentRead - 100 goroutines reading same key
2. TestCachedLoader_ConcurrentReadWrite - 50 readers + 50 writers simultaneously
3. TestCachedLoader_ConcurrentExpiry - reads during cache expiry window
4. TestCachedLoader_ConcurrentDifferentKeys - parallel loads of different keys

Use sync.WaitGroup for goroutine coordination.
Use sync.atomic for shared counters (loadCount).

Create a mockLoader that:
- Tracks call count atomically
- Has configurable latency (time.Sleep) to increase race likelihood
- Returns predictable policies

Verify:
- No double-loading on cache hit
- Correct policy returned to all goroutines
- No panics under concurrent access

Run with -race flag to detect data races.
  </action>
  <verify>go test -race -run=Concurrent ./policy/... passes with no race conditions</verify>
  <done>Cache concurrency tests pass with -race flag, verify no double-loading</done>
</task>

<task type="auto">
  <name>Task 2: Create break-glass concurrency tests</name>
  <files>breakglass/concurrency_test.go</files>
  <action>
Create concurrency tests for break-glass store operations:

1. TestStore_ConcurrentCreate - 50 goroutines creating events simultaneously
2. TestStore_ConcurrentGet - 100 goroutines reading same event
3. TestStore_ConcurrentUpdate - 50 goroutines updating same event (last-writer-wins)
4. TestStore_ConcurrentListByInvoker - parallel list queries

Use in-memory mock store with mutex protection.
Track operation counts atomically.

Verify:
- All creates succeed or fail consistently
- Gets return consistent data
- Updates don't lose data
- List operations don't panic on concurrent mutation

These tests use mock stores, not DynamoDB, to test the store interface contract.
  </action>
  <verify>go test -race -run=Concurrent ./breakglass/... passes with no race conditions</verify>
  <done>Break-glass store concurrency tests pass with -race flag</done>
</task>

<task type="auto">
  <name>Task 3: Create request concurrency tests</name>
  <files>request/concurrency_test.go</files>
  <action>
Create concurrency tests for approval request store operations:

1. TestRequestStore_ConcurrentCreate - 50 goroutines creating requests
2. TestRequestStore_ConcurrentStateTransition - parallel approve/deny on same request
3. TestRequestStore_ConcurrentListByStatus - parallel queries during mutations
4. TestRequestStore_ConcurrentFindApproved - parallel approved request lookups

Use in-memory mock store with mutex protection.

Verify state machine integrity:
- First transition wins (pending -> approved/denied)
- Subsequent transitions fail appropriately
- No invalid state transitions occur

Test the optimistic locking pattern:
- Simulate UpdatedAt version conflicts
- Verify retry logic or error handling

Run with -race flag to detect data races.
  </action>
  <verify>go test -race -run=Concurrent ./request/... passes with no race conditions</verify>
  <done>Request store concurrency tests pass with -race flag, state machine integrity verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go test -race -run=Concurrent ./policy/... succeeds
- [ ] go test -race -run=Concurrent ./breakglass/... succeeds
- [ ] go test -race -run=Concurrent ./request/... succeeds
- [ ] No data races detected
- [ ] No test failures introduced
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- All tests pass with -race detector enabled
- Concurrency patterns documented in test comments
  </success_criteria>

<output>
After completion, create `.planning/phases/57-performance-load-testing/57-02-SUMMARY.md`
</output>
