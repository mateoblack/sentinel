---
phase: 81-session-management
plan: 04
type: execute
wave: 3
depends_on: ["81-02", "81-03"]
files_modified: [session/revoke.go, cli/sentinel_server.go, sentinel/server.go, session/revoke_test.go]
autonomous: true
---

<objective>
Add session revocation capability for immediate access termination.

Purpose: Enable security teams to revoke active server sessions for immediate credential denial.
Output: Revocation logic, CLI command, and server-side revocation checking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/81-session-management/81-02-SUMMARY.md
@.planning/phases/81-session-management/81-03-SUMMARY.md

# Patterns for revocation:
@breakglass/checker.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add session revocation logic</name>
  <files>session/revoke.go</files>
  <action>
Create revocation logic following breakglass state transition patterns:

1. Define RevokeInput struct:
   - SessionID string
   - RevokedBy string (who is revoking)
   - Reason string (why revoked)

2. Define validation errors:
   - ErrSessionAlreadyRevoked
   - ErrSessionExpired
   - ErrInvalidRevokeInput

3. Create Revoke function:
   - func Revoke(ctx context.Context, store Store, input RevokeInput) (*ServerSession, error)
   - Validate input (non-empty fields, valid session ID)
   - Get session from store
   - Check current status:
     - If revoked: return ErrSessionAlreadyRevoked
     - If expired: return ErrSessionExpired
     - If active: proceed with revocation
   - Update session:
     - Status = StatusRevoked
     - RevokedBy = input.RevokedBy
     - RevokedReason = input.Reason
     - UpdatedAt = now
   - Call store.Update with optimistic locking
   - Return updated session

4. Create IsSessionRevoked helper:
   - func IsSessionRevoked(ctx context.Context, store Store, sessionID string) (bool, error)
   - Get session, return true if Status == StatusRevoked
   - Return false, nil if not found or active
  </action>
  <verify>go build ./session/... compiles without errors</verify>
  <done>Revocation logic implemented with state validation</done>
</task>

<task type="auto">
  <name>Task 2: Add sentinel server revoke command</name>
  <files>cli/sentinel_server.go</files>
  <action>
Add revoke command to CLI:

1. Define ServerRevokeCommandInput struct:
   - Region string
   - TableName string
   - SessionID string (required, positional)
   - Reason string (required)
   - OutputFormat string
   - AWSProfile string
   - STSClient identity.STSAPI (for testing)

2. Create ConfigureServerRevokeCommand function:
   - Register "server revoke" subcommand
   - Positional arg: session ID
   - Required flag: --reason
   - Other flags: --region, --table, --output, --aws-profile

3. Create ServerRevokeCommand function:
   - Validate session ID format
   - Load AWS config with SSO support
   - Get AWS identity for RevokedBy (using identity.GetAWSUsername pattern)
   - Create session store
   - Call session.Revoke with input
   - Handle errors:
     - ErrSessionNotFound: "Session not found"
     - ErrSessionAlreadyRevoked: "Session already revoked"
     - ErrSessionExpired: "Session already expired"
   - Output:
     - Human: "Session {id} revoked by {user}"
     - JSON: Marshal revoked session

4. Require --reason flag to be non-empty (like break-glass justification).
  </action>
  <verify>go build ./... compiles without errors</verify>
  <done>sentinel server revoke command terminates sessions</done>
</task>

<task type="auto">
  <name>Task 3: Add revocation check to credential serving</name>
  <files>sentinel/server.go</files>
  <action>
Check for session revocation before serving credentials:

1. In DefaultRoute, after policy evaluation and before credential retrieval:
   - If s.sessionID != "" && s.config.SessionStore != nil:
     - Check if session is revoked using session.IsSessionRevoked
     - If revoked:
       - Log revocation denial
       - writeErrorMessage with "Session revoked" and 403
       - Return (do not serve credentials)

2. This check happens on every credential request, enabling real-time revocation.

3. Error handling:
   - Store errors should be logged but not deny access (fail-open for availability)
   - Revoked status should deny access (fail-closed for security)

The revocation check adds minimal latency (single DynamoDB Get) but provides immediate revocation capability.
  </action>
  <verify>go build ./sentinel/... compiles without errors</verify>
  <done>Revoked sessions are denied credentials immediately</done>
</task>

<task type="auto">
  <name>Task 4: Add tests for revocation</name>
  <files>session/revoke_test.go</files>
  <action>
Create comprehensive tests for revocation:

1. TestRevoke_Success:
   - Active session gets revoked
   - Status changes to revoked
   - RevokedBy and Reason populated

2. TestRevoke_AlreadyRevoked:
   - Revoked session returns ErrSessionAlreadyRevoked

3. TestRevoke_Expired:
   - Expired session returns ErrSessionExpired

4. TestRevoke_NotFound:
   - Non-existent session returns ErrSessionNotFound

5. TestRevoke_InvalidInput:
   - Empty SessionID
   - Empty RevokedBy
   - Empty Reason
   - All return ErrInvalidRevokeInput

6. TestIsSessionRevoked:
   - Returns true for revoked session
   - Returns false for active session
   - Returns false for not found (fail-open)

Use mock store following existing test patterns.
  </action>
  <verify>go test ./session/... -v passes all tests</verify>
  <done>Revocation logic fully tested</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./... succeeds
- [ ] go test ./... passes
- [ ] Session revocation changes status
- [ ] CLI command revokes session
- [ ] Server denies credentials for revoked sessions
- [ ] State transitions validated (can't revoke expired)
</verification>

<success_criteria>
- All tasks completed
- Sessions can be revoked via CLI
- Revoked sessions are immediately denied credentials
- State machine prevents invalid transitions
- Comprehensive test coverage
</success_criteria>

<output>
After completion, create `.planning/phases/81-session-management/81-04-SUMMARY.md`
</output>
