---
phase: 81-session-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [session/types.go, session/store.go, session/dynamodb.go, session/types_test.go]
autonomous: true
---

<objective>
Define session schema, state machine, and DynamoDB store for tracking active server sessions.

Purpose: Enable visibility into active server-mode credential sessions for security monitoring and management.
Output: New `session` package with types, Store interface, and DynamoDB implementation following break-glass patterns.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/80-short-lived-sessions/80-01-SUMMARY.md

# Existing patterns to follow:
@breakglass/types.go
@breakglass/store.go
@breakglass/dynamodb.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define ServerSession type with state machine</name>
  <files>session/types.go</files>
  <action>
Create new `session` package with ServerSession type for tracking server-mode credential sessions.

Follow breakglass/types.go patterns exactly:

1. Package comment explaining session tracking purpose
2. Constants:
   - SessionIDLength = 16 (same as break-glass)
   - DefaultSessionTTL = 1 * time.Hour (cleanup buffer beyond credential expiry)

3. SessionStatus type with states:
   - StatusActive: Session is active, credentials being served
   - StatusRevoked: Session was manually revoked
   - StatusExpired: Session expired (TTL elapsed)

4. ServerSession struct fields:
   - ID string (16 lowercase hex chars)
   - User string (AWS identity who started session)
   - Profile string (AWS profile being served)
   - ServerInstanceID string (unique ID for this server instance, for multi-server scenarios)
   - Status SessionStatus
   - StartedAt time.Time (when server started)
   - LastAccessAt time.Time (last credential request)
   - ExpiresAt time.Time (when session auto-expires)
   - RequestCount int64 (number of credential requests served)
   - SourceIdentity string (the SourceIdentity being used, for correlation)
   - CreatedAt time.Time
   - UpdatedAt time.Time
   - RevokedBy string (omitempty, who revoked if revoked)
   - RevokedReason string (omitempty, why revoked)

5. Helper functions:
   - NewSessionID() string (crypto/rand, 8 bytes -> 16 hex chars)
   - ValidateSessionID(id string) bool (regex match)
   - SessionStatus.IsValid() bool
   - SessionStatus.IsTerminal() bool (revoked, expired)

Use yaml and json struct tags like break-glass. Include package-level regex for ID validation.
  </action>
  <verify>go build ./session/... compiles without errors</verify>
  <done>ServerSession type defined with all fields and helper functions</done>
</task>

<task type="auto">
  <name>Task 2: Define Store interface for session persistence</name>
  <files>session/store.go</files>
  <action>
Create Store interface following breakglass/store.go patterns:

1. Query limit constants:
   - DefaultQueryLimit = 100
   - MaxQueryLimit = 1000

2. Sentinel errors (var block):
   - ErrSessionNotFound
   - ErrSessionExists
   - ErrConcurrentModification

3. Store interface methods:
   - Create(ctx, session) error - create new session
   - Get(ctx, id) (*ServerSession, error) - get by ID
   - Update(ctx, session) error - update with optimistic locking
   - Delete(ctx, id) error - delete session (idempotent)
   - ListByUser(ctx, user, limit) ([]*ServerSession, error) - list user's sessions
   - ListByStatus(ctx, status, limit) ([]*ServerSession, error) - list by status
   - ListByProfile(ctx, profile, limit) ([]*ServerSession, error) - list by profile
   - FindActiveByServerInstance(ctx, serverInstanceID) (*ServerSession, error) - find active session for server
   - Touch(ctx, id) error - update LastAccessAt and increment RequestCount

Include doc comments explaining each method's behavior. Touch is a hot-path operation so it should be efficient.
  </action>
  <verify>go build ./session/... compiles without errors</verify>
  <done>Store interface defined with all CRUD and query methods</done>
</task>

<task type="auto">
  <name>Task 3: Add DynamoDB Store implementation</name>
  <files>session/dynamodb.go</files>
  <action>
Implement DynamoDBStore following breakglass/dynamodb.go patterns exactly:

1. GSI constants:
   - GSIUser = "gsi-user"
   - GSIStatus = "gsi-status"
   - GSIProfile = "gsi-profile"
   - GSIServerInstance = "gsi-server-instance"

2. dynamoDBAPI interface (same pattern as break-glass)

3. DynamoDBStore struct with client and tableName

4. NewDynamoDBStore(cfg aws.Config, tableName string) constructor

5. newDynamoDBStoreWithClient for testing

6. dynamoItem struct with explicit field mapping:
   - All string fields map directly
   - time.Time fields as RFC3339Nano strings
   - int64 for RequestCount

7. Implement all Store interface methods:
   - Create: PutItem with condition attribute_not_exists(id)
   - Get: GetItem with proper unmarshaling
   - Update: PutItem with UpdatedAt condition expression for optimistic locking
   - Delete: DeleteItem (no condition, idempotent)
   - ListByUser: Query on gsi-user
   - ListByStatus: Query on gsi-status
   - ListByProfile: Query on gsi-profile
   - FindActiveByServerInstance: Query on gsi-server-instance with status=active filter
   - Touch: UpdateItem with SET lastAccessAt, requestCount = requestCount + 1

8. Helper functions:
   - toItem(session) -> dynamoItem
   - fromItem(item) -> ServerSession
   - enforceLimit(limit) int

Table schema (to be created via Terraform):
- Partition key: id (S)
- TTL attribute: ttl (N)
- GSI: gsi-user (user, created_at)
- GSI: gsi-status (status, created_at)
- GSI: gsi-profile (profile, created_at)
- GSI: gsi-server-instance (server_instance_id, status)
  </action>
  <verify>go build ./session/... compiles without errors</verify>
  <done>DynamoDBStore implements Store interface with all methods</done>
</task>

<task type="auto">
  <name>Task 4: Add unit tests for session types</name>
  <files>session/types_test.go</files>
  <action>
Create unit tests following breakglass/types_test.go patterns:

1. TestNewSessionID:
   - Generates valid 16-char hex string
   - Multiple calls produce unique IDs
   - ID passes ValidateSessionID

2. TestValidateSessionID:
   - Valid: 16 lowercase hex chars
   - Invalid: wrong length, uppercase, non-hex, empty

3. TestSessionStatus_IsValid:
   - All known statuses return true
   - Unknown status returns false

4. TestSessionStatus_IsTerminal:
   - active returns false
   - revoked, expired return true

Use table-driven tests with t.Run for subtests.
  </action>
  <verify>go test ./session/... -v passes all tests</verify>
  <done>Unit tests cover session ID generation, validation, and status helpers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] go build ./session/... succeeds
- [ ] go test ./session/... passes
- [ ] ServerSession type follows break-glass patterns
- [ ] Store interface matches break-glass patterns
- [ ] DynamoDB implementation compiles (runtime testing in later plan)
</verification>

<success_criteria>
- All tasks completed
- New session package created with types, store interface, and DynamoDB implementation
- Follows established break-glass patterns for consistency
- Unit tests pass for type helpers
</success_criteria>

<output>
After completion, create `.planning/phases/81-session-management/81-01-SUMMARY.md`
</output>
