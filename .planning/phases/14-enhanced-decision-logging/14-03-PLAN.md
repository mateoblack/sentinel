---
phase: 14-enhanced-decision-logging
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified: [cli/sentinel_exec.go]
autonomous: true
---

<objective>
Update exec command to use enhanced decision logging with SourceIdentity correlation.

Purpose: Parallel to Plan 02 changes for credentials command, apply same enhanced logging pattern to exec command.
Output: exec command logs enhanced decision entries with request-id, source-identity, role-arn when issuing credentials.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-enhanced-decision-logging/14-01-SUMMARY.md

@cli/sentinel_exec.go
@cli/sentinel_provider.go
@logging/decision.go
@identity/request_id.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update exec command to use enhanced logging</name>
  <files>cli/sentinel_exec.go</files>
  <action>
Apply same logging pattern as credentials command (from 14-02):

1. After policy evaluation, check if decision.Effect == policy.EffectAllow:
   - Generate request-id: `requestID := identity.NewRequestID()`
   - Include in credential request: `credReq.RequestID = requestID`

2. After GetCredentialsWithSourceIdentity returns successfully:
   - Build CredentialIssuanceFields from result:
     ```go
     credFields := &logging.CredentialIssuanceFields{
         RequestID:       requestID,
         SourceIdentity:  creds.SourceIdentity,
         RoleARN:         creds.RoleARN,
         SessionDuration: input.SessionDuration,
     }
     ```

3. Change logging flow:
   - For DENY: Log immediately with NewDecisionLogEntry (line ~154-157), then return error
   - For ALLOW: Move logging AFTER credential retrieval (after line ~180):
     ```go
     if logger != nil {
         credFields := &logging.CredentialIssuanceFields{...}
         entry := logging.NewEnhancedDecisionLogEntry(policyRequest, decision, input.PolicyParameter, credFields)
         logger.LogDecision(entry)
     }
     ```

4. Remove the existing logging block (lines ~154-157) for allow path - it will be logged after credentials.

Current code structure (lines ~151-180):
```go
// 7. Evaluate policy
decision := policy.Evaluate(loadedPolicy, policyRequest)

// 8. Log decision (before handling, so both allow and deny are logged)
if logger != nil {
    entry := logging.NewDecisionLogEntry(policyRequest, decision, input.PolicyParameter)
    logger.LogDecision(entry)
}

// 9. Handle decision
if decision.Effect == policy.EffectDeny {
    // ...
}

// 10. EffectAllow: proceed to credential retrieval
```

New structure:
```go
// 7. Evaluate policy
decision := policy.Evaluate(loadedPolicy, policyRequest)

// 8. Handle deny decision - log and exit
if decision.Effect == policy.EffectDeny {
    if logger != nil {
        entry := logging.NewDecisionLogEntry(policyRequest, decision, input.PolicyParameter)
        logger.LogDecision(entry)
    }
    fmt.Fprintf(os.Stderr, "Access denied: %s\n", decision.String())
    return 1, fmt.Errorf("access denied: %s", decision.String())
}

// 9. EffectAllow: generate request-id and retrieve credentials
requestID := identity.NewRequestID()
credReq := SentinelCredentialRequest{
    // ... existing fields
    RequestID: requestID,
}

creds, err := s.GetCredentialsWithSourceIdentity(ctx, credReq)
// ... error handling

// 10. Log allow decision with credential context
if logger != nil {
    credFields := &logging.CredentialIssuanceFields{
        RequestID:       requestID,
        SourceIdentity:  creds.SourceIdentity,
        RoleARN:         creds.RoleARN,
        SessionDuration: input.SessionDuration,
    }
    entry := logging.NewEnhancedDecisionLogEntry(policyRequest, decision, input.PolicyParameter, credFields)
    logger.LogDecision(entry)
}

// 11. Continue with subprocess execution...
```

Import identity package if not already imported.
  </action>
  <verify>go build ./cli/... compiles; exec command logs with request_id</verify>
  <done>exec command logs request_id, source_identity, role_arn for allow decisions</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds
- [ ] `go test ./...` passes
- [ ] exec command logs request_id for allow decisions
- [ ] exec command logs source_identity when role assumed
- [ ] Deny decisions log without new fields (backward compat)
</verification>

<success_criteria>

- All tasks completed
- exec command emits enhanced decision logs
- Logging behavior matches credentials command
</success_criteria>

<output>
After completion, create `.planning/phases/14-enhanced-decision-logging/14-03-SUMMARY.md`
</output>
