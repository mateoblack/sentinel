---
phase: 66-config-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [config/types.go, config/types_test.go, config/validator.go, config/validator_test.go, cli/config.go, cli/config_test.go]
autonomous: true
---

<objective>
Add `sentinel config validate` command to catch misconfigurations before runtime.

Purpose: Help users validate policy files, approval policies, break-glass policies, and bootstrap configs before deploying. Catches YAML syntax errors, semantic validation failures, and profile reference issues.
Output: New config package with validation logic, CLI command with human/JSON output.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 65 established error patterns:
@.planning/phases/65-error-enhancement/65-01-SUMMARY.md
@.planning/phases/65-error-enhancement/65-02-SUMMARY.md

# Existing validation functions to leverage:
@policy/validate.go
@policy/approval.go
@breakglass/policy.go
@breakglass/ratelimit.go
@bootstrap/validate.go
@errors/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config validation types and registry</name>
  <files>config/types.go, config/types_test.go, config/validator.go, config/validator_test.go</files>
  <action>
Create new config package with:

1. **config/types.go** - Validation types:
```go
// ConfigType identifies the type of configuration being validated
type ConfigType string

const (
    ConfigTypePolicy       ConfigType = "policy"
    ConfigTypeApproval     ConfigType = "approval"
    ConfigTypeBreakGlass   ConfigType = "breakglass"
    ConfigTypeRateLimit    ConfigType = "ratelimit"
    ConfigTypeBootstrap    ConfigType = "bootstrap"
)

// ValidationIssue represents a single validation problem
type ValidationIssue struct {
    Severity    IssueSeverity `json:"severity"`
    Location    string        `json:"location"`     // e.g., "rules[0].name", "profiles[1]"
    Message     string        `json:"message"`
    Suggestion  string        `json:"suggestion,omitempty"`
}

type IssueSeverity string

const (
    SeverityError   IssueSeverity = "error"   // Blocks loading/usage
    SeverityWarning IssueSeverity = "warning" // Works but suspicious
)

// ValidationResult contains all validation findings
type ValidationResult struct {
    ConfigType ConfigType        `json:"config_type"`
    Source     string            `json:"source"`      // File path or SSM path
    Valid      bool              `json:"valid"`       // True if no errors (warnings OK)
    Issues     []ValidationIssue `json:"issues"`
}

// AllResults aggregates multiple validation results
type AllResults struct {
    Results []ValidationResult `json:"results"`
    Summary ResultSummary      `json:"summary"`
}

type ResultSummary struct {
    Total    int `json:"total"`
    Valid    int `json:"valid"`
    Invalid  int `json:"invalid"`
    Errors   int `json:"errors"`
    Warnings int `json:"warnings"`
}
```

2. **config/validator.go** - Validation logic:
```go
// Validate validates config content based on type
func Validate(configType ConfigType, content []byte, source string) ValidationResult

// ValidateFile validates a local YAML file
func ValidateFile(path string, configType ConfigType) (ValidationResult, error)

// DetectConfigType attempts to detect config type from YAML content
// Returns ConfigTypePolicy as default if unable to detect
func DetectConfigType(content []byte) ConfigType
```

Detection logic:
- Look for `rules` array with `effect` field → policy
- Look for `rules` array with `approvers` field → approval
- Look for `rules` array with `users` field and `allowed_reason_codes` → breakglass
- Look for `rules` array with `cooldown` or `max_per_user` → ratelimit
- Look for `policy_root` and `profiles` → bootstrap

Validation implementation:
- Parse YAML, catch parse errors first
- Use existing Validate() methods from policy, breakglass, bootstrap packages
- Convert validation errors to ValidationIssue format
- Add warnings for suspicious patterns:
  - Empty profiles list (matches all) without explicit note
  - Time windows with no hours specified
  - Rate limit rules with very short cooldowns (<1m)

Tests: Cover all config types, parse errors, semantic errors, detection logic.
  </action>
  <verify>go test ./config/... -v passes</verify>
  <done>Config validation types and logic implemented with tests</done>
</task>

<task type="auto">
  <name>Task 2: Create config validate CLI command</name>
  <files>cli/config.go, cli/config_test.go</files>
  <action>
Create CLI command at `sentinel config validate`:

1. **cli/config.go** - Command implementation:
```go
// ConfigValidateCommandInput contains the input for config validate
type ConfigValidateCommandInput struct {
    Paths      []string // Local file paths to validate
    SSMPaths   []string // SSM paths to load and validate
    ConfigType string   // Override detected type (policy, approval, breakglass, ratelimit, bootstrap)
    Output     string   // human, json
    Region     string   // AWS region for SSM

    // For testing
    Stdout *os.File
    Stderr *os.File
}

func ConfigureConfigCommand(app *kingpin.Application, s *Sentinel)
func ConfigValidateCommand(ctx context.Context, input ConfigValidateCommandInput) error
```

Command structure:
```
sentinel config validate [paths...] [flags]

Flags:
  --path PATH      Local file to validate (repeatable)
  --ssm PATH       SSM parameter to load and validate (repeatable)
  --type TYPE      Config type: policy, approval, breakglass, ratelimit, bootstrap (auto-detect if not specified)
  --output FORMAT  Output format: human (default), json
  --region REGION  AWS region for SSM operations
```

Behavior:
- If positional args provided, treat as paths
- Combine with --path flags
- For each path: read file, detect type (unless --type), validate, collect results
- For each --ssm: load from SSM, detect type, validate, collect results
- Output all results in specified format
- Exit code: 0 if all valid, 1 if any errors (warnings don't affect exit code)

Human output format:
```
Validating 2 configurations...

✓ policy.yaml (policy)
  Valid

✗ approval.yaml (approval)
  Errors:
    - rule[0]: missing name
    - rule[1].approvers: must have at least one approver
  Suggestions:
    - Add a 'name' field to identify each rule
    - Add at least one user to 'approvers' list

Summary: 1 valid, 1 invalid (2 errors, 0 warnings)
```

JSON output: Marshal AllResults directly.

Use FormatErrorWithSuggestion from cli/errors.go for SSM load failures.

Tests:
- Valid policy file → exit 0
- Invalid policy file → exit 1 with errors
- Multiple files with mixed validity
- JSON output format
- Auto-detection of config types
  </action>
  <verify>go test ./cli/... -run TestConfig -v passes</verify>
  <done>sentinel config validate command works with local files and outputs validation results</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./...` succeeds without errors
- [ ] `go test ./config/... ./cli/... -v` passes all tests
- [ ] `sentinel config validate --help` shows command help
- [ ] `sentinel config validate testdata/valid.yaml` exits 0
- [ ] `sentinel config validate testdata/invalid.yaml` exits 1 with error details
</verification>

<success_criteria>

- config package created with types and validation logic
- All config types (policy, approval, breakglass, ratelimit, bootstrap) validated
- CLI command `sentinel config validate` works with local files
- Human and JSON output formats supported
- Exit codes correct (0=valid, 1=errors)
- Tests cover core validation paths
</success_criteria>

<output>
After completion, create `.planning/phases/66-config-validation/66-01-SUMMARY.md`
</output>
