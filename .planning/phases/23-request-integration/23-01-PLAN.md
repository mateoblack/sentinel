---
phase: 23-request-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [request/checker.go, request/checker_test.go]
autonomous: true
---

<objective>
Add FindApprovedRequest function to request package for checking if a user has a valid approved request for a profile.

Purpose: Enables credential issuance flow to check for approved requests when policy denies access.
Output: checker.go with FindApprovedRequest function and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-request-schema/18-01-SUMMARY.md
@.planning/phases/19-dynamodb-backend/19-02-SUMMARY.md

@request/types.go
@request/store.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FindApprovedRequest function</name>
  <files>request/checker.go</files>
  <action>
Create request/checker.go with:

1. `FindApprovedRequest(ctx, store Store, requester string, profile string) (*Request, error)`
   - Query store.ListByRequester to get user's requests
   - Filter for: Status == StatusApproved AND Profile == profile
   - Check request is still valid: ExpiresAt > now (not expired)
   - Check request duration window: now < CreatedAt + Duration (access window still open)
   - Return first matching request, or nil if none found
   - Return error only for store errors, not for "no approved request found"

2. Add helper `isRequestValid(req *Request) bool`
   - Checks ExpiresAt > time.Now()
   - Checks time.Now() < CreatedAt + Duration

Design notes:
- Use ListByRequester not ListByStatus because we need to filter by profile
- Filter client-side since DynamoDB GSI can only filter by one attribute
- Return *Request so caller can log request ID and approver info
- Nil return (no error) means no valid approved request exists
  </action>
  <verify>go build ./request/...</verify>
  <done>FindApprovedRequest function compiles and exports correctly</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for FindApprovedRequest</name>
  <files>request/checker_test.go</files>
  <action>
Create request/checker_test.go with test cases:

1. TestFindApprovedRequest_Found - approved request for user+profile exists and is valid
2. TestFindApprovedRequest_WrongProfile - approved request exists but for different profile
3. TestFindApprovedRequest_WrongStatus - request exists for profile but is pending/denied
4. TestFindApprovedRequest_Expired - approved request exists but ExpiresAt is in the past
5. TestFindApprovedRequest_DurationElapsed - approved request exists but CreatedAt + Duration is in past
6. TestFindApprovedRequest_NoRequests - user has no requests at all
7. TestFindApprovedRequest_StoreError - store returns error, propagates correctly

Use mockStore pattern from existing tests (cli/request_test.go pattern).
Create a local mockStore in the test file that implements Store interface.

Test data setup:
- Use time.Now() for timestamps to ensure tests are time-independent
- Mock ListByRequester to return controlled test data
  </action>
  <verify>go test -v ./request/... -run TestFindApprovedRequest</verify>
  <done>All 7 test cases pass, covering happy path and edge cases</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./request/...` succeeds
- [ ] `go test ./request/...` passes all tests
- [ ] FindApprovedRequest returns nil (not error) when no valid request found
- [ ] FindApprovedRequest returns *Request when valid approved request exists
</verification>

<success_criteria>

- FindApprovedRequest function created and exported
- isRequestValid helper function created
- 7 test cases covering all scenarios
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/23-request-integration/23-01-SUMMARY.md`
</output>
