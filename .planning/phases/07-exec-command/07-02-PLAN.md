---
phase: 07-exec-command
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - cli/sentinel_exec.go
  - cli/sentinel_exec_test.go
autonomous: true
---

<objective>
Complete the sentinel exec command with environment variable injection and subprocess execution.

Purpose: Inject AWS credentials into subprocess environment and execute the command.
Output: Fully functional exec command that runs commands with policy-gated credentials.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase
@.planning/phases/07-exec-command/07-01-SUMMARY.md

# Implementation patterns
@cli/exec.go
@cli/credentials.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add environment variable injection to SentinelExecCommand</name>
  <files>cli/sentinel_exec.go</files>
  <action>
Extend SentinelExecCommand to inject credentials into subprocess environment:

1. After credential retrieval succeeds, create environment using the existing createEnv() function from exec.go:
   ```go
   cmdEnv := createEnv(input.ProfileName, config.Region, "")
   ```
   Note: config.Region should come from input.Region, and endpointURL can be empty string for now.

2. Add credentials to environment using pattern from exec.go addCredsToEnv, but inline since we already have creds:
   ```go
   cmdEnv.Set("AWS_ACCESS_KEY_ID", creds.AccessKeyID)
   cmdEnv.Set("AWS_SECRET_ACCESS_KEY", creds.SecretAccessKey)
   if creds.SessionToken != "" {
       cmdEnv.Set("AWS_SESSION_TOKEN", creds.SessionToken)
   }
   if creds.CanExpire {
       cmdEnv.Set("AWS_CREDENTIAL_EXPIRATION", iso8601.Format(creds.Expiration))
   }
   ```

3. Set AWS_SENTINEL=profileName (similar to AWS_VAULT) to indicate running in sentinel subshell

4. At start of function, check if AWS_SENTINEL already set - if so, error with "running in an existing sentinel subshell; 'exit' from the subshell or unset AWS_SENTINEL to force"

Import iso8601 from "github.com/byteness/aws-vault/v7/iso8601" for timestamp formatting.
  </action>
  <verify>go build ./cmd/sentinel/... compiles</verify>
  <done>Environment variables set with credentials before subprocess execution</done>
</task>

<task type="auto">
  <name>Task 2: Add subprocess execution</name>
  <files>cli/sentinel_exec.go</files>
  <action>
Add subprocess execution to SentinelExecCommand:

1. Use the existing runSubProcess() function from exec.go to execute the command:
   ```go
   return runSubProcess(input.Command, input.Args, cmdEnv)
   ```

2. The runSubProcess function already handles:
   - Creating osexec.Command
   - Connecting stdin/stdout/stderr
   - Signal proxying
   - Returning exit code

3. Before runSubProcess, try the exec syscall (same pattern as exec.go):
   - Only for non-server mode (which sentinel doesn't support yet)
   - Call doExecSyscall(input.Command, input.Args, cmdEnv)
   - If it fails, log and fall back to runSubProcess

Both runSubProcess and doExecSyscall are already defined in exec.go and exported (via lowercase but same package), so they can be called directly.

Final flow:
```go
// Try exec syscall first (replaces process, more efficient)
err = doExecSyscall(input.Command, input.Args, cmdEnv)
if err != nil {
    log.Println("Error doing execve syscall:", err.Error())
    log.Println("Falling back to running a subprocess")
}

return runSubProcess(input.Command, input.Args, cmdEnv)
```
  </action>
  <verify>go build ./cmd/sentinel/... compiles</verify>
  <done>Subprocess execution implemented with exec syscall fallback</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for sentinel exec command</name>
  <files>cli/sentinel_exec_test.go</files>
  <action>
Create cli/sentinel_exec_test.go with tests:

1. TestSentinelExecCommandInput_validation - if we add a validate() method (optional, can skip if no validation needed)

2. TestSentinelExecCommand_NestedSubshell - test that AWS_SENTINEL check works:
   ```go
   func TestSentinelExecCommand_NestedSubshell(t *testing.T) {
       // Set AWS_SENTINEL to simulate nested shell
       t.Setenv("AWS_SENTINEL", "test-profile")

       input := SentinelExecCommandInput{
           ProfileName:     "test",
           PolicyParameter: "/sentinel/test",
       }

       _, err := SentinelExecCommand(context.Background(), input, nil)
       if err == nil {
           t.Fatal("expected error for nested subshell")
       }
       if !strings.Contains(err.Error(), "existing sentinel subshell") {
           t.Errorf("unexpected error: %v", err)
       }
   }
   ```

3. Example test (similar to exec_test.go pattern) showing command parsing - can be an Example function for documentation.

Keep tests focused on the sentinel-specific logic (nested shell detection, policy parameter requirement). The subprocess execution is already tested in aws-vault's exec_test.go.
  </action>
  <verify>go test ./cli/... -run Sentinel -v passes</verify>
  <done>Unit tests verify nested subshell detection and basic command parsing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go build ./cmd/sentinel/...` succeeds
- [ ] `go test ./cli/... -v` passes
- [ ] Manual test: `./sentinel/sentinel exec --profile test --policy-parameter /test -- echo hello` (will fail on policy, but command parsing works)
- [ ] Code follows exec.go patterns for subprocess handling
</verification>

<success_criteria>

- All tasks completed
- Environment variable injection working
- Subprocess execution with signal proxying
- Tests pass
- exec command fully functional for policy-gated credential injection
  </success_criteria>

<output>
After completion, create `.planning/phases/07-exec-command/07-02-SUMMARY.md`
</output>
