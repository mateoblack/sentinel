---
phase: 51-policy-engine-testing
plan: 03
type: execute
wave: 2
depends_on: ["51-01", "51-02"]
files_modified: [policy/gating_test.go]
autonomous: true
---

<objective>
Add security-focused tests validating that credential gating correctly blocks or allows access.

Purpose: Validate the core security invariant - credentials are only issued when policy explicitly allows it OR an approved request/break-glass override exists. These tests verify the decision flow, not just coverage.
Output: New policy/gating_test.go with security boundary tests
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-policy-engine-testing/51-01-SUMMARY.md
@.planning/phases/51-policy-engine-testing/51-02-SUMMARY.md

@policy/evaluate.go
@policy/types.go
@cli/credentials.go
@cli/credentials_test.go
@request/finder.go
@breakglass/finder.go
@testutil/mock_stores.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gating test file with security invariant tests</name>
  <files>policy/gating_test.go</files>
  <action>
Create a new test file policy/gating_test.go focused on security-critical gating behavior:

1. TestCredentialGating_DenyBlocksAccess - Core security invariant:
   - Policy with EffectDeny rule matching request
   - No approved request exists
   - No break-glass exists
   - Verify decision.Effect == EffectDeny
   - This is the default-deny security model

2. TestCredentialGating_NoMatchBlocksAccess - Default deny:
   - Policy with no matching rules
   - Verify decision.Effect == EffectDeny
   - Verify decision.MatchedRule == "" (no rule matched)
   - Verify decision.RuleIndex == -1

3. TestCredentialGating_AllowGrantsAccess - Explicit allow:
   - Policy with EffectAllow rule matching request
   - Verify decision.Effect == EffectAllow
   - Verify decision.MatchedRule contains rule name
   - Verify decision.RuleIndex >= 0

4. TestCredentialGating_FirstMatchWins - Rule ordering:
   - Policy with deny rule before allow rule, both matching
   - Verify first matching rule (deny) wins
   - Verify decision.RuleIndex == 0 (first rule)

5. TestCredentialGating_RequireApprovalEffect - Approval flow trigger:
   - Policy with EffectRequireApproval rule matching request
   - Verify decision.Effect == EffectRequireApproval
   - This effect triggers the approval workflow

These tests exercise policy.Evaluate() directly with crafted policies to verify security-critical behavior. They complement the existing evaluate_test.go with security-focused scenarios.
  </action>
  <verify>go test -v ./policy/... -run TestCredentialGating</verify>
  <done>Security invariant tests pass, gating behavior validated</done>
</task>

<task type="auto">
  <name>Task 2: Add override flow tests</name>
  <files>policy/gating_test.go</files>
  <action>
Add tests for the override flows that bypass policy denials:

1. TestGating_ApprovedRequestOverride - Approved request bypasses deny:
   - Create test scenario: policy denies, but FindApprovedRequest would find approved request
   - Use testutil.MockRequestStore with pre-populated approved request
   - Verify the gating logic (test request.FindApprovedRequest directly)
   - Confirm approved request for matching user/profile is found

2. TestGating_BreakGlassOverride - Break-glass bypasses deny:
   - Create test scenario: policy denies, but FindActiveBreakGlass would find active event
   - Use testutil.MockBreakGlassStore with pre-populated active event
   - Verify the gating logic (test breakglass.FindActiveBreakGlass directly)
   - Confirm active break-glass for matching user/profile is found

3. TestGating_ApprovedRequestPriority - Check order:
   - Approved request is checked before break-glass
   - If approved request exists, break-glass is not checked
   - This follows the priority in cli/credentials.go

4. TestGating_ExpiredApprovalNotUsed - Expired approval is ignored:
   - Create approved request with past expiration
   - Verify FindApprovedRequest returns nil (doesn't find expired)

5. TestGating_ClosedBreakGlassNotUsed - Closed break-glass is ignored:
   - Create break-glass event with StatusClosed
   - Verify FindActiveBreakGlass returns nil

These tests verify the finder functions work correctly with mock stores, validating the complete gating logic.
  </action>
  <verify>go test -v ./policy/... -run TestGating</verify>
  <done>Override flow tests pass, approval and break-glass bypasses validated</done>
</task>

<task type="auto">
  <name>Task 3: Add boundary condition tests</name>
  <files>policy/gating_test.go</files>
  <action>
Add tests for edge cases and boundary conditions:

1. TestGating_NilPolicy - Nil policy returns default deny:
   - Evaluate(nil, &Request{...})
   - Verify returns deny decision

2. TestGating_NilRequest - Nil request returns default deny:
   - Evaluate(&Policy{...}, nil)
   - Verify returns deny decision

3. TestGating_EmptyPolicy - No rules returns default deny:
   - Policy with empty Rules slice
   - Verify default deny decision

4. TestGating_EmptyConditions - Empty conditions match all:
   - Rule with empty Users, Profiles, nil Time
   - Verify rule matches any request (wildcard behavior)

5. TestGating_CaseSensitivity - Exact matching:
   - User "Alice" should NOT match condition ["alice"]
   - Profile "Production" should NOT match condition ["production"]
   - Verify case-sensitive matching

6. TestGating_MultipleProfiles - Multiple profiles in condition:
   - Condition.Profiles = ["staging", "production"]
   - Request for "staging" should match
   - Request for "production" should match
   - Request for "development" should not match

These boundary tests ensure the policy engine behaves correctly at edges.
  </action>
  <verify>go test -v ./policy/... -run TestGating</verify>
  <done>Boundary condition tests pass, edge cases validated</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `go test ./policy/...` passes all tests
- [ ] Security invariant tests validate default-deny behavior
- [ ] Override flow tests validate approval and break-glass bypasses
- [ ] Boundary condition tests validate edge cases
- [ ] No regressions in existing tests
</verification>

<success_criteria>

- All tasks completed
- Security invariants tested (deny blocks, allow grants, first-match-wins)
- Override flows tested (approval bypass, break-glass bypass)
- Boundary conditions tested (nil inputs, empty conditions, case sensitivity)
- Policy package maintains >95% coverage
</success_criteria>

<output>
After completion, create `.planning/phases/51-policy-engine-testing/51-03-SUMMARY.md`
</output>
